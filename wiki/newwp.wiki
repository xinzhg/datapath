#summary : Instructions on how to add a new waypoint to DataPath

= Overall Plan =

To add a new waypoint to DataPath, 4 separate tasks need to be accomplished. The parser needs to be changed, the translator needs to know how to include the new waypoint into analysis, the WayPoint code that runs in the execution engine needs to establish the data flow while the operator is running and the patterns for code generation have to specify the code that is executed by the workers.

Thought this document we use the GLAWaypoint as a running example. This waypoint adds GLA execution capabilities to DataPath. GLAs are a generalization of User Defined Aggregates. Any GLA type is assumed to have the following methods:
  * A constructor, with at most 1 argument: ConstState& 
  * AddItem(const T1& v1, const T2& v2, ...), a method to add a piece of information to the state of the GLA. 
  * AddState(GLA& other), a method to merge content of other into this state
  * Optionally, a mechanism to extract result in the form 1 tuple: through the function GetResult(T1& t1, T2& t2, ...)
  * Optionally, a mechanism to extract, 0 or more tuples: bool GetNext(T1& v1,...)
  * Optionally, a method to serialize-deserialize the GLA so that it can be transported into user space

*Example of GLA*: Average

{{{
class AverageGLA {
  long long int count; // keeps the number of tuples aggregated
  double sum; // sum of the values 
public:  
  AverageGLA(){ count=0; sum=0.0; }
  AddItem(const DOUBLE& x){ count++; sum+=x; }
  AddState(AverageGLA& o){ count+=o.count; sum+=o.sum; }
  // we only support one tuple as output
  GetResult(DOUBLE& rez){ rez = (count>0) ? (sum/count) : 0.0;}
};

}}} 


== Changes to the parser ==
