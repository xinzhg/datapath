Constant States and State Passing   {#state-tutorial}
=================================
[TOC]

There may come times when the ability to construct a GF, GT, GLA, or GIST
(hereafter referred to collectively as "General Processors", or GPs)
using constant literal arguments is not enough. In these cases, it is possible
to initialize GPs using more complex objects that are created prior to any
GPs being constructed. These complex objects are known as **constant states**.
Also important to note is that the *same* set of constant states are used to
initialize all instances of a GP.
There are two types of constant states in the system:

1.  **Internal** Constant States (aka Generated Constant States)

    These states are internal to a waypoint. They are generated before any
    GPs are instantiated. If a GP uses constant states for its initialization,
    the internal constant state(s) will be passed any constructor arguments
    that would normally have been passed to the GP.

2.  **External** Constant States (aka Required Constant States)

    These states are generated by other waypoints, more specifically by
    GLAs and GISTs. These constant states are the actual states used by
    the GLA or GIST.

## Construction Using Constant States {#state-tut-construct}

In order for a GP to be constructed using constant states, its description
must contain at least one of the following tags:

-   GEN\_CONST\_STATES
-   REQ\_CONST\_STATES
-   OPT\_ITERABLE

@note OPT\_ITERABLE automatically sets GEN\_CONST\_STATES. You should not
have both tags describing a GLA.

@warning If any of these are set, all constant literal constructor arguments
will be sent to the generated constant states instead. If there are no generated
states, then nothing will receive these arguments, even if they are given.

The constructor should take constant references to the constant states,
internal states first. Example:

    MyClass( const InternalState&, const ExternalState1&, const ExternalState2& );

## Producing an External Constant State {#state-tut-produce}

Producing a GP as an external constant states requires only changing the
waypoint's `AS` statement in the Piggy file. Instead of listing attributes
in the `AS` clause, put the keyword `SELF`.

## Receiving an External Constant State {#state-tut-require}

Receiving external constant states in a query is as simple as adding an
additional clause before the `USING` clause. The
`REQUIRES` clause should list the waypoints from which the GP requires states.

@note The waypoints in the `REQUIRES` clause need to be listed in the same order
that the constructor requires them!

@note A waypoint may only send its state to **one** other waypoint! If multiple
waypoints require a state from a single waypoint, the system will refuse to
run the query.

## Example: Performing a Join {#state-example}

While DataPath has a built-in Join operator (which is recommended to use), it
is possible with GLAs, GTs, and state passing to implement a Join. In this
example, we will do exactly that for a simple join.

For this example, we will have two tables: **person** with the attributes
*id* (an integer) and *name* (a string), and **address** with the attributes
*id* (an integer) and *street* (a string). The *id* attribute in both tables
serve as a key, representing a particular person.

In this example, we will do a simple join that matches up each person with
their addresses and prints them.

First, we require a GLA that will aggregate the right hand side of the join
and create a hash table keyed on the ID. The implementation of this GLA can
be seen [here](@ref GLA/JoinRHS.h). Special note should be made that we are
free to create our own result extraction interface, as the transform that
we will use to extract the data will be the only thing that will need to
use this interface.

Next, we will pass this GLA's state
to a GT that will perform lookups into the hash table, and output matches. The
implementation of this GT can be seen [here](@ref GT/JoinLHS.h). The GT uses
the JoinRHS's lookup interface to determine if there are matches and obtain
the addresses for keys that match.

The [query](@ref Piggy/state-passing-join.pgy) mostly consists of two waypoints.
First, we must send the **address** table through the JoinRHS GLA to build up
the hash table. We make sure to have the GLA's output be itself:

@snippet Piggy/state-passing-join.pgy join-rhs

Next, we take the **person** table as input and the JoinRHS GLA as an
external constant state, and perform the lookups:

@snippet Piggy/state-passing-join.pgy join-lhs

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

\<\< @ref gist-tutorial | @ref toc | @ref template-tutorial \>\>
