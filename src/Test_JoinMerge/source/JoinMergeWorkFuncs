//#include <queue>
#include<set>
#include "WorkDescription.h"
#include "ExecEngineData.h"
#include "Column.h"
#include "ColumnIterator.cc"
#include "MMappedStorage.h"
#include "BString.h"
#include "BStringIterator.h"
//#include "IntFuncs.h"
//#include "BitstringFuncs.h"
#include <vector>

using namespace std;

// used to work on priority queue based sort merge
struct HashWrapper {
	__uint64_t hash;
	int chunkNo;
};

// priority queue comparator
struct compare_key {
	bool operator()( const HashWrapper lhs, const HashWrapper rhs ) 
	{
		return (lhs.hash < rhs.hash);
	}
};

/*
	This takes two sorted list of chunks, lhs list and rhs list, and do the sort merge join.
	It maintaines a min heap of hash values on top of each list and virtually now we have
	just 2 lists to do sort merge. When some value matches from LHS and RHS heap, we need
	to checkpoint all the iterators of all the columns of all the RHS chunks including storing
	the heap, so that we can restore them all if another consecutive LHS value matches.
*/

void CheckpointAllRHSChunks (vector <vector <ColumnIterator<int> > >& colIterVec,
														 vector<BStringIterator>& myInBStringIterVec) {

	for (int p = 0; p < colIterVec.size(); p++) {
		for (int  q = 0; q < colIterVec[p].size(); q++) {
			colIterVec[p][q].CheckpointSave ();
		}
		myInBStringIterVec[p].CheckpointSave ();
	}
}

void RestoreAllRHSChunks (vector <vector <ColumnIterator<int> > >& colIterVec,
													vector<BStringIterator>& myInBStringIterVec) {

	for (int p = 0; p < colIterVec.size(); p++) {
		for (int  q = 0; q < colIterVec[p].size(); q++) {
			colIterVec[p][q].CheckpointRestore ();
		}
		myInBStringIterVec[p].CheckpointRestore ();
	}
}

void AdvanceAllColumns (vector<BStringIterator>& myInBStringIterVec,
												vector <vector <ColumnIterator<int> > >& colIterVec,
												int chunkNo) {

	for (int j = 0; j < colIterVec[chunkNo].size(); j++) {
		colIterVec[chunkNo][j].Advance();
		myInBStringIterVec[chunkNo].Advance();
	}
}

void FillHeapOrAdvance (vector<BStringIterator>& myInBStringIterVec,
												 int chunkNo,
												 Bitstring& whichQueries,
												 vector <vector <ColumnIterator<int> > >& colIterVec,
												 multiset<HashWrapper, compare_key>& minHeap) {

	// Now look for next tuple to fill heap which has active query
	// Kind of infinite loop, we break in between
	//while (!myInBStringIterVec[chunkNo].AtUnwrittenByte()) { // TBD TBD TBD TBD, BStringIterator not working, need to fix
	while (!colIterVec[chunkNo][0].AtUnwrittenByte()) {
		// Now find the first tuple for which query is active
		Bitstring curBits = myInBStringIterVec[chunkNo].GetCurrent ();
		curBits.Intersect (whichQueries);
		// If tuple has some active query, fill the heap
		if (!curBits.IsEmpty()) {
			HashWrapper w;
			w.hash = colIterVec[chunkNo][0].GetCurrent(); // assume first column of each chunk is hash
			w.chunkNo = chunkNo;
			minHeap.insert (w);
			break; // while loop
		} else {
			// If this tuple don't have active query, advance all the columns of this chunk
			// including Bitstring column
			AdvanceAllColumns (myInBStringIterVec, colIterVec, chunkNo);
		}
	}
}

int JoinMergeFunc (WorkDescription &workDescription, ExecEngineData &result) {

	// get the input LHS and RHS chunk container from work descripton
	JoinMergeWorkDescription myWork;
	myWork.swap (workDescription);
	ContainerOfChunks &inputLHSList = myWork.get_chunksLHS ();
	ContainerOfChunks &inputRHSList = myWork.get_chunksRHS ();

	// get the number of chunks in each list to create vectors of this length
	int numLHSChunks = inputLHSList.Length();
	int numRHSChunks = inputRHSList.Length();

  // get the waypoint identifier
  unsigned int wayPointID = myWork.get_wayPointID ();

  // get the input bitmap out of the LHS input chunks
	vector<BStringIterator> myInBStringIterLhsVec;
	myInBStringIterLhsVec.resize(numLHSChunks); // set the vector size
	inputLHSList.MoveToStart();
	int i = 0;
	while (inputLHSList.RightLength()) {
		Column bitmapIn;
  	inputLHSList.Current().SwapBitmap (bitmapIn);
  	BStringIterator myInBStringIter (bitmapIn, 5); // TBD TBD, remove hardcode number of tuples
		myInBStringIterLhsVec[i].swap (myInBStringIter);
		inputLHSList.Advance ();
		i++;
	}

  // get the input bitmap out of the RHS input chunks
	vector<BStringIterator> myInBStringIterRhsVec;
	myInBStringIterRhsVec.resize(numRHSChunks); // set the vector size
	inputRHSList.MoveToStart();
	i = 0;
	while (inputRHSList.RightLength()) {
		Column bitmapIn;
  	inputRHSList.Current().SwapBitmap (bitmapIn);
  	BStringIterator myInBStringIter (bitmapIn, 5); // TBD TBD, remove hardcode number of tuples
		myInBStringIterRhsVec[i].swap (myInBStringIter);
		inputRHSList.Advance ();
		i++;
	}

  // get all of the queries that are active here
  QueryExitContainer &whichExits = myWork.get_whichQueryExits ();
  Bitstring whichQueries;
  whichQueries.Empty ();
  for (whichExits.MoveToStart (); whichExits.RightLength (); whichExits.Advance ()) {
    whichQueries.Union (whichExits.Current ().query);
  }


	// Create output BitString
	MMappedStorage myStore;
	Column bitmapOut (myStore);
	BStringIterator myOutBStringIter (bitmapOut, whichQueries);

  // extract the relevant input columns from LHS and build iterators for them
	// each vector index contains columns for that chunk
	inputLHSList.MoveToStart();
	vector <vector <ColumnIterator<int> > > colLHSIterVec;
	colLHSIterVec.resize (numLHSChunks);
	// TBD TBD assumption is that all chunks have equal column, fix later if not true
	for (int j = 0; j < numLHSChunks; j++)
		colLHSIterVec[j].resize(inputLHSList.Current().GetNumOfColumns());
	i = 0;
	while (inputLHSList.RightLength()) {
		for (int k = 0; k < inputLHSList.Current().GetNumOfColumns(); k++) {
			Column col;
			//inputLHSList.Current().SwapColumn (col, whichLHSColNumber[k]);
			inputLHSList.Current().SwapColumn (col, k);
			ColumnIterator <int> colIter (col);
			colLHSIterVec[i][k].swap(colIter);
		}
		inputLHSList.Advance ();
		i++;
	}

// This is commented, for debug purpose only
/*
	cout << "\nLeft column values:";
	for (int h = 0; h < colLHSIterVec.size(); h++) {
		for (int o = 0; o < colLHSIterVec[h].size(); o++) {
		//for (int o = 0; o < 1; o++) {
			cout << endl;
			while (!colLHSIterVec[h][o].AtUnwrittenByte()) {
				cout << " " << colLHSIterVec[h][o].GetCurrent();
				colLHSIterVec[h][o].Advance ();
			}
		}
	}
*/


  // extract the relevant input columns from RHS and build iterators for them
	// each vector index contains columns for that chunk
	inputRHSList.MoveToStart();
	vector <vector <ColumnIterator<int> > > colRHSIterVec; // assume first col of all chunks is hash value
	colRHSIterVec.resize (numRHSChunks); // we assume all chunks have same set of columns in RHS
	// TBD TBD assumption is that all chunks have equal column, fix later if not true
	for (int j = 0; j < numRHSChunks; j++)
		colRHSIterVec[j].resize(inputRHSList.Current().GetNumOfColumns()); // resize each column of all chunks
	i = 0;
	while (inputRHSList.RightLength()) {
		for (int k = 0; k < inputRHSList.Current().GetNumOfColumns(); k++) {
			Column col;
			//inputRHSList.Current().SwapColumn (col, whichRHSColNumber[k]);
			inputRHSList.Current().SwapColumn (col, k);
			ColumnIterator <int> colIter (col);
			colRHSIterVec[i][k].swap(colIter);
		}
		inputRHSList.Advance ();
		i++;
	}

// This is commented, for debug purpose only
/*
	cout << "\n\nRight column values:";
	for (int h = 0; h < colRHSIterVec.size(); h++) {
		for (int o = 0; o < colLHSIterVec[h].size(); o++) {
		//for (int o = 0; o < 1; o++) {
			cout << endl;
			while (!colRHSIterVec[h][o].AtUnwrittenByte()) {
				cout << " " << colRHSIterVec[h][o].GetCurrent();
				colRHSIterVec[h][o].Advance ();
			}
		}
	}
	return 0;
*/


	// Here we start the sort merge join
	// Create priority queue for hash column values
	multiset<HashWrapper, compare_key> minHeapLHS;
	multiset<HashWrapper, compare_key> minHeapRHS;

	// Fill the first value of each LHS chunk in LHS heap
	for (int k = 0; k < numLHSChunks; k++) {
		FillHeapOrAdvance (myInBStringIterLhsVec, k, whichQueries, colLHSIterVec, minHeapLHS);
	}

	// Fill the first value of each RHS chunk in RHS heap
	for (int k = 0; k < numRHSChunks; k++) {
		FillHeapOrAdvance (myInBStringIterRhsVec, k, whichQueries, colRHSIterVec, minHeapRHS);
	}

	// Now pick one of each heap and keep comparing until one of the heap is exhausted
	while (!minHeapLHS.empty() && !minHeapRHS.empty()) {
		HashWrapper wl = *(minHeapLHS.begin());
		HashWrapper wr = *(minHeapRHS.begin());

		if (wl.hash < wr.hash) {

			// erase the minimum element
			assert (!minHeapLHS.empty());
			minHeapLHS.erase(minHeapLHS.begin());

			// here advance all columns of LHS of chunk number wl.chunkNo
			AdvanceAllColumns (myInBStringIterLhsVec, colLHSIterVec, wl.chunkNo);

			FillHeapOrAdvance (myInBStringIterLhsVec, wl.chunkNo, whichQueries, colLHSIterVec, minHeapLHS);

		} else if (wl.hash > wr.hash) {

			// erase the minimum element
			assert (!minHeapRHS.empty());
			minHeapRHS.erase(minHeapRHS.begin());

			// here advance all columns of RHS of chunk number wr.chunkNo
			AdvanceAllColumns (myInBStringIterRhsVec, colRHSIterVec, wr.chunkNo);

			FillHeapOrAdvance (myInBStringIterRhsVec, wr.chunkNo, whichQueries, colRHSIterVec, minHeapRHS);

		} else { // (wl.hash == wr.hash)

			__uint64_t matchingHash = wl.hash;

			// Save checkpoint for all columns before incrementing both chunks
			CheckpointAllRHSChunks (colRHSIterVec, myInBStringIterRhsVec);

			// Also save the state of the heap
			multiset<HashWrapper, compare_key> minHeapRHSCheckpoint(minHeapRHS);

			while (!minHeapLHS.empty()) { // break from this if 2 consecutive LHS mismatches

				HashWrapper wl1 = *(minHeapLHS.begin());

				if (wl1.hash != matchingHash) { // next LHS dont match to previous LHS hash, first time always match
					break;

				} else { // restore everything

					// restore the RHS Column iterators to original value
					RestoreAllRHSChunks (colRHSIterVec, myInBStringIterRhsVec);
					// restore the original heap state
					minHeapRHS.clear();
					minHeapRHS = minHeapRHSCheckpoint;
				}

				while (!minHeapRHS.empty()) {

					HashWrapper wr1 = *(minHeapRHS.begin());

					if (wl1.hash == wr1.hash) { // first one will obviously match as it matched before
						// Merge the two columns here for wl1.chunkNo and wr1.chunkNo after matching attributes

						cout << "\nMerged :";
						for (int d = 0; d < colLHSIterVec[wl1.chunkNo].size(); d++) {
							cout << " " << colLHSIterVec[wl1.chunkNo][d].GetCurrent();
						}
						cout << ", ";
						for (int d = 0; d < colRHSIterVec[wr1.chunkNo].size(); d++) {
							cout << " " << colRHSIterVec[wr1.chunkNo][d].GetCurrent();
						}

						// this is the bitstring that will go in the output
						Bitstring bitstringLHS;
						bitstringLHS.Empty ();

						// Fill output bitstring
						bitstringLHS = myInBStringIterRhsVec[wr1.chunkNo].GetCurrent ();
						bitstringLHS.Intersect (whichQueries);
						myOutBStringIter.Insert (bitstringLHS);
						myOutBStringIter.Advance ();

						// erase the minimum element
						minHeapRHS.erase(minHeapRHS.begin());

						// here advance all columns of RHS of chunk number wr1.chunkNo
						AdvanceAllColumns (myInBStringIterRhsVec, colRHSIterVec, wr1.chunkNo);

						FillHeapOrAdvance (myInBStringIterRhsVec, wr1.chunkNo, whichQueries, colRHSIterVec, minHeapRHS);
					} else {
						break;
					}
				}

				// erase the minimum element
				minHeapLHS.erase(minHeapLHS.begin());

				// here advance all columns of LHS of chunk number wl1.chunkNo
				AdvanceAllColumns (myInBStringIterLhsVec, colLHSIterVec, wl1.chunkNo);

				FillHeapOrAdvance (myInBStringIterLhsVec, wl1.chunkNo, whichQueries, colLHSIterVec, minHeapLHS);
			}
		}
	}
}

