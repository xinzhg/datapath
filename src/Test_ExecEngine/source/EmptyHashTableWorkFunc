
// used to construct a lookup table to see what we need to do with each hash entry
struct WayPointInformation {
	int isDying;
	int index;
	QueryID killThese;
};

#define DYING_AND_HOLD 1
#define DYING_AND_SEND 2 
#define ALIVE 0

#include "ColumnIterator.h"
#include "MMappedStorage.h"

int EmptyHashTableWorkFunc (WorkDescription &workDescription, ExecEngineData &result) {

	// this is the area where all of the records are serialized to;
	// 10K bytes are initially used for this
	void *serializeHere = (void *) malloc (10000);

	// get the work description
	HashCleanerWorkDescription myWork;
	myWork.swap (workDescription);

	// now exract the list of dying waypoints... these are ones to create chunks from
	myWork.get_dyingWayPointsToSend ().MoveToStart ();
	int numDyingWaypoints = myWork.get_dyingWayPointsToSend ().RightLength ();

	// this 1024 is a magic number, since we can have 1024 join waypoints (10 bits are devoted to the join waypoint ID)
	WayPointInformation *wayPointInfo = new WayPointInformation[1024];
	for (int i = 0; i < 1024; i++) {
		wayPointInfo[i].isDying = ALIVE;
		wayPointInfo[i].index = -1;
		wayPointInfo[i].killThese.Empty ();
	}

	// mark all of the dying waypoints that need to be sent on
	for (int i = 0; myWork.get_dyingWayPointsToSend ().RightLength (); myWork.get_dyingWayPointsToSend ().Advance (), i++) {
		wayPointInfo[myWork.get_dyingWayPointsToSend ().Current ()].isDying = DYING_AND_SEND;
		wayPointInfo[myWork.get_dyingWayPointsToSend ().Current ()].index = i;
	}

	// mark all of the dying waypoints that need to be held
	myWork.get_dyingWayPointsToHold ().MoveToStart ();
	for (; myWork.get_dyingWayPointsToHold ().RightLength (); myWork.get_dyingWayPointsToHold ().Advance ()) {
		wayPointInfo[myWork.get_dyingWayPointsToHold ().Current ()].isDying = DYING_AND_HOLD;
	}

	// now, go through and remember all of the queries that we need to hold back
	myWork.get_theseQueriesAreDone ().MoveToStart ();
	for (; myWork.get_theseQueriesAreDone ().RightLength (); myWork.get_theseQueriesAreDone ().Advance ()) {

		// find the equivalent join waypoint id
		for (myWork.get_equivalences ().MoveToStart (); ; myWork.get_equivalences ().Advance ()) {
			if (myWork.get_theseQueriesAreDone ().Current ().exit == myWork.get_equivalences ().Current ().actualID) {
				int index = myWork.get_equivalences ().Current ().joinWayPointID;
				wayPointInfo[index].killThese = myWork.get_theseQueriesAreDone ().Current ().query;
				break;
			}
		}
	}
	
	// check out the hash table segment we are processing
	HashTableSegment mySegment;
	int whichSegment = myWork.get_whichSegment ();
	int theseAreOK[NUM_SEGS];
	for (int i = 0; i < NUM_SEGS; i++) {
		theseAreOK[i] = 0;
	}
	theseAreOK[whichSegment] = 1;
	myWork.get_centralHashTable ().CheckOutOne (theseAreOK, mySegment);

	// now set up the various attribute columns...

	// LHS IS FIRST
	// first is the hash column
	Column hashColumnLHS[numDyingWaypoints];
	ColumnIterator <HT_INDEX_TYPE> hashColumnIterLHS[numDyingWaypoints];

	// now is the bitmap column
	Column bitmapColumnLHS[numDyingWaypoints];
	BStringIterator bitmapColumnIterLHS[numDyingWaypoints];
	int bitmapColumnLHSIsUsed[numDyingWaypoints];

	// now are all of the LHS data columns... there is one of these for each LHS join column
	// IN THE ENTIRE SYSTEM
	Column col0LHS[numDyingWaypoints];
	ColumnIterator <int> col0IterLHS[numDyingWaypoints];
	int col0LHSIsUsed[numDyingWaypoints];
	
	Column col1LHS[numDyingWaypoints];
	ColumnIterator <int> col1IterLHS[numDyingWaypoints];
	int col1LHSIsUsed[numDyingWaypoints];

	Column col2LHS[numDyingWaypoints];
	ColumnIterator <int> col2IterLHS[numDyingWaypoints];
	int col2LHSIsUsed[numDyingWaypoints];

	Column col3LHS[numDyingWaypoints];
	ColumnIterator <int> col3IterLHS[numDyingWaypoints];
	int col3LHSIsUsed[numDyingWaypoints];

	Column col6LHS[numDyingWaypoints];
	ColumnIterator <int> col6IterLHS[numDyingWaypoints];
	int col6LHSIsUsed[numDyingWaypoints];

	// now, actually set up all of these columns
	for (int i = 0; i < numDyingWaypoints; i++) {
		
		// set up the hash column
		MMappedStorage hashStore;
		Column hash (hashStore);
		ColumnIterator <HT_INDEX_TYPE> hashIter (hash);
		hashIter.swap (hashColumnIterLHS[i]);

		// now is the bitmap... set it up so that it contains ALL of the queries
		// that could possibly be removed from the hash table
		MMappedStorage bitmapStore;
		Bitstring tempBits;
		tempBits.AddMember (0);
		tempBits.AddMember (1);
		tempBits.AddMember (2);
		tempBits.AddMember (3);
		Column bitmap (bitmapStore);
		BStringIterator bitmapIter (bitmap, tempBits);
		bitmapIter.swap (bitmapColumnIterLHS[i]);
		bitmapColumnLHSIsUsed[i] = 0;

		// now all of the LHS data columns
		MMappedStorage col0Store;
		Column col0 (col0Store);
		ColumnIterator <int> col0Iter (col0);
		col0Iter.swap (col0IterLHS[i]);
		col0LHSIsUsed[i] = 0;

		MMappedStorage col1Store;
		Column col1 (col1Store);
		ColumnIterator <int> col1Iter (col1);
		col1Iter.swap (col1IterLHS[i]);
		col1LHSIsUsed[i] = 0;
			
		MMappedStorage col2Store;
		Column col2 (col2Store);
		ColumnIterator <int> col2Iter (col2);
		col2Iter.swap (col2IterLHS[i]);
		col2LHSIsUsed[i] = 0;
		
		MMappedStorage col3Store;
		Column col3 (col2Store);
		ColumnIterator <int> col3Iter (col3);
		col3Iter.swap (col3IterLHS[i]);
		col3LHSIsUsed[i] = 0;
		
		MMappedStorage col6Store;
		Column col6 (col2Store);
		ColumnIterator <int> col6Iter (col6);
		col6Iter.swap (col6IterLHS[i]);
		col6LHSIsUsed[i] = 0;

	}

	// RHS IS NEXT
	// first is the hash column
	Column hashColumnRHS[numDyingWaypoints];
	ColumnIterator <HT_INDEX_TYPE> hashColumnIterRHS[numDyingWaypoints];

	// now is the bitmap column
	Column bitmapColumnRHS[numDyingWaypoints];
	BStringIterator bitmapColumnIterRHS[numDyingWaypoints];
	int bitmapColumnRHSIsUsed[numDyingWaypoints];

	// now are all of the RHS data columns... there is one of these for each RHS join column
	// IN THE ENTIRE SYSTEM
	Column col4RHS[numDyingWaypoints];
	ColumnIterator <int> col4IterRHS[numDyingWaypoints];
	int col4RHSIsUsed[numDyingWaypoints];
	
	Column col5RHS[numDyingWaypoints];
	ColumnIterator <int> col5IterRHS[numDyingWaypoints];
	int col5RHSIsUsed[numDyingWaypoints];

	// now, actually set up all of these columns
	for (int i = 0; i < numDyingWaypoints; i++) {
		
		// set up the hash column
		MMappedStorage hashStore;
		Column hash (hashStore);
		ColumnIterator <HT_INDEX_TYPE> hashIter (hash);
		hashIter.swap (hashColumnIterRHS[i]);

		// now is the bitmap
		MMappedStorage bitmapStore;
		Column bitmap (bitmapStore);
		Bitstring tempBits;
		tempBits.AddMember (0);
		tempBits.AddMember (1);
		tempBits.AddMember (2);
		tempBits.AddMember (3);
		BStringIterator bitmapIter (bitmap, tempBits);
		bitmapIter.swap (bitmapColumnIterRHS[i]);
		bitmapColumnRHSIsUsed[i] = 0;

		// now all of the RHS data columns
		MMappedStorage col4Store;
		Column col4 (col4Store);
		ColumnIterator <int> col4Iter (col4);
		col4Iter.swap (col4IterRHS[i]);
		col4RHSIsUsed[i] = 0;

		MMappedStorage col5Store;
		Column col5 (col5Store);
		ColumnIterator <int> col5Iter (col5);
		col5Iter.swap (col5IterRHS[i]);
		col5RHSIsUsed[i] = 0;
	}

	// these are all of the "backing" or default column values... there is one per column in the system
	// that is somehow involved in a join
	int col0;
	int col1;
	int col2;
	int col3;
	int col4;
	int col5;
	int col6;

	// this is where we put the serialized data we have extracted from the hash table
	SerializedSegmentArray storage;

	// this is the new hash table segment we are building
	HashTableSegment newSegment;
	newSegment.Allocate ();

	// lastSlotAddedTo is the last slot written to
	HT_INDEX_TYPE lastSlotAddedTo = -1;

	// now, loop through the hash table!
	for (HT_INDEX_TYPE i = 0; i < NUM_SLOTS_IN_SEGMENT; i++) {

		HT_INDEX_TYPE curSlot = i;
		while (1) {

			// begin by trying to extract the bitmap	
			int whichWayPoint = -1, LHS, columnID, dummy, done;
			int lastLen = mySegment.Extract (serializeHere, curSlot, i, whichWayPoint, BITMAP, LHS, done);
	
			// see if we didn't find any data in this slot
			if (lastLen == 0) 
				break;

			// we did find data, so get this guy's bitmap
			Bitstring *bitstringPtr = (Bitstring *) serializeHere;

			// determine what is going on with this waypoint
			int state = wayPointInfo[whichWayPoint].isDying;
			int index = wayPointInfo[whichWayPoint].index;
			Bitstring deadQueries = wayPointInfo[whichWayPoint].killThese;
			bitstringPtr->Difference (deadQueries); 
		
			if (state == DYING_AND_SEND && LHS) {

				// first put the bitmap in
				bitmapColumnIterLHS[index].Insert (*bitstringPtr);
				bitmapColumnIterLHS[index].Advance ();
				bitmapColumnLHSIsUsed[index]++;

				// now put the hash in
				hashColumnIterLHS[index].Insert (i);
				hashColumnIterLHS[index].Advance ();

			// if this guy is dying and we got RHS data, put the bitmap (and hash) in a RHS chunk
			} else if (state == DYING_AND_SEND && !LHS) { 

				// first put the bitmap in
				bitmapColumnIterRHS[index].Insert (*bitstringPtr);
				bitmapColumnIterRHS[index].Advance ();
				bitmapColumnRHSIsUsed[index]++;

				// now put the hash in
				hashColumnIterRHS[index].Insert (i);
				hashColumnIterRHS[index].Advance ();

			// if this entry has interesting data, then put it in
			} else if (!bitstringPtr->IsEmpty () && state == ALIVE) {

				storage.StartNew (i, whichWayPoint, !LHS, serializeHere, lastLen);
			}
			
			// if we finished the tuple, stop serializing
			if (done)
				goto end;

			// NOW DO NOW DO COLUMN 0
			columnID = 0;
			lastLen = mySegment.Extract (serializeHere, curSlot, i, whichWayPoint, columnID, dummy, done);
		
			// see if we got something... in the first two cases, we are extracting data for a disk-based join
			if (lastLen > 0 && state == DYING_AND_SEND && LHS) {

				// first, make sure that we are far enough along
				for (; col0LHSIsUsed[index] < bitmapColumnLHSIsUsed[index] - 1; col0LHSIsUsed[index]++) {
					col0IterLHS[index].Insert (col0);
					col0IterLHS[index].Advance ();
				}

				// now put the data in
				int *col0Ptr = ((int *) (serializeHere));
				col0IterLHS[index].Insert (*col0Ptr);
				col0IterLHS[index].Advance ();
				col0LHSIsUsed[index]++;

			} else if (lastLen > 0 && state == DYING_AND_SEND && !LHS) {

				FATAL ("Att 0 is only used by LHS... how did I find it in a RHS tuple?\n");

			} else if (lastLen > 0 && !bitstringPtr->IsEmpty () && state == ALIVE) {

				storage.Append (columnID, serializeHere, lastLen);
			}

			// if we finished the tuple, stop serializing
			if (done)
				goto end;

			// NOW DO COLUMN 1
			columnID = 1;
			lastLen = mySegment.Extract (serializeHere, curSlot, i, whichWayPoint, columnID, dummy, done);
		
			// see if we got something... in the first two cases, we are extracting data for a disk-based join
			if (lastLen > 0 && state == DYING_AND_SEND && LHS) {

				// first, make sure that we are far enough along
				for (; col1LHSIsUsed[index] < bitmapColumnLHSIsUsed[index] - 1; col1LHSIsUsed[index]++) {
					col1IterLHS[index].Insert (col1);
					col1IterLHS[index].Advance ();
				}

				// now put the data in
				int *col1Ptr = ((int *) (serializeHere));
				col1IterLHS[index].Insert (*col1Ptr);
				col1IterLHS[index].Advance ();
				col1LHSIsUsed[index]++;

			} else if (lastLen > 0 && state == DYING_AND_SEND && !LHS) {

				FATAL ("Att 1 is only used by LHS... how did I find it in a RHS tuple?\n");

			// in the last case, the data will go back into the hash table
			} else if (lastLen > 0 && !bitstringPtr->IsEmpty () && state == ALIVE) {

				storage.Append (columnID, serializeHere, lastLen);
			}

			// if we finished the tuple, stop serializing
			if (done)
				goto end;

			// NOW DO COLUMN 2
			columnID = 2;
			lastLen = mySegment.Extract (serializeHere, curSlot, i, whichWayPoint, columnID, dummy, done);
		
			// see if we got something... in the first two cases, we are extracting data for a disk-based join
			if (lastLen > 0 && state == DYING_AND_SEND && LHS) {

				// first, make sure that we are far enough along
				for (; col2LHSIsUsed[index] < bitmapColumnLHSIsUsed[index] - 1; col2LHSIsUsed[index]++) {
					col2IterLHS[index].Insert (col2);
					col2IterLHS[index].Advance ();
				}

				// now put the data in
				int *col2Ptr = ((int *) (serializeHere));
				col2IterLHS[index].Insert (*col2Ptr);
				col2IterLHS[index].Advance ();
				col2LHSIsUsed[index]++;

			} else if (lastLen > 0 && state == DYING_AND_SEND && !LHS) {

				FATAL ("Att 2 is only used by LHS... how did I find it in a RHS tuple?\n");

			// in the last case, the data will go back into the hash table
			} else if (lastLen > 0 && !bitstringPtr->IsEmpty () && state == ALIVE) {

				storage.Append (columnID, serializeHere, lastLen);
			}

			// if we finished the tuple, stop serializing
			if (done)
				goto end;

			// NOW DO COLUMN 3
			columnID = 3;
			lastLen = mySegment.Extract (serializeHere, curSlot, i, whichWayPoint, columnID, dummy, done);
		
			// see if we got something... in the first two cases, we are extracting data for a disk-based join
			if (lastLen > 0 && state == DYING_AND_SEND && LHS) {

				// first, make sure that we are far enough along
				for (; col3LHSIsUsed[index] < bitmapColumnLHSIsUsed[index] - 1; col3LHSIsUsed[index]++) {
					col3IterLHS[index].Insert (col3);
					col3IterLHS[index].Advance ();
				}

				// now put the data in
				int *col3Ptr = ((int *) (serializeHere));
				col3IterLHS[index].Insert (*col3Ptr);
				col3IterLHS[index].Advance ();
				col3LHSIsUsed[index]++;

			} else if (lastLen > 0 && state == DYING_AND_SEND && !LHS) {

				FATAL ("Att 3 is only used by LHS... how did I find it in a RHS tuple?\n");

			// in the last case, the data will go back into the hash table
			} else if (lastLen > 0 && !bitstringPtr->IsEmpty () && state == ALIVE) {

				storage.Append (columnID, serializeHere, lastLen);
			}

			// if we finished the tuple, stop serializing
			if (done)
				goto end;

			// NOW DO COLUMN 4
			columnID = 4;
			lastLen = mySegment.Extract (serializeHere, curSlot, i, whichWayPoint, columnID, dummy, done);
		
			// see if we got something... in the first two cases, we are extracting data for a disk-based join
			if (lastLen > 0 && state == DYING_AND_SEND && LHS) {

				FATAL ("Att 4 is only used by RHS... how did I find it in a LHS tuple?\n");

			} else if (lastLen > 0 && state == DYING_AND_SEND && !LHS) {

				// first, make sure that we are far enough along
				for (; col4RHSIsUsed[index] < bitmapColumnRHSIsUsed[index] - 1; col4RHSIsUsed[index]++) {
					col4IterRHS[index].Insert (col4);
					col4IterRHS[index].Advance ();
				}

				// now put the data in
				int *col4Ptr = ((int *) (serializeHere));
				col4IterRHS[index].Insert (*col4Ptr);
				col4IterRHS[index].Advance ();
				col4RHSIsUsed[index]++;

			// in the last case, the data will go back into the hash table
			} else if (lastLen > 0 && !bitstringPtr->IsEmpty () && state == ALIVE) {

				storage.Append (columnID, serializeHere, lastLen);
			}

			// if we finished the tuple, stop serializing
			if (done)
				goto end;

			// NOW DO COLUMN 5
			columnID = 5;
			lastLen = mySegment.Extract (serializeHere, curSlot, i, whichWayPoint, columnID, dummy, done);
		
			// see if we got something... in the first two cases, we are extracting data for a disk-based join
			if (lastLen > 0 && state == DYING_AND_SEND && LHS) {

				FATAL ("Att 5 is only used by RHS... how did I find it in a LHS tuple?\n");

			} else if (lastLen > 0 && state == DYING_AND_SEND && !LHS) {

				// first, make sure that we are far enough along
				for (; col5RHSIsUsed[index] < bitmapColumnRHSIsUsed[index] - 1; col5RHSIsUsed[index]++) {
					col5IterRHS[index].Insert (col5);
					col5IterRHS[index].Advance ();
				}

				// now put the data in
				int *col5Ptr = ((int *) (serializeHere));
				col5IterRHS[index].Insert (*col5Ptr);
				col5IterRHS[index].Advance ();
				col5RHSIsUsed[index]++;

			// in the last case, the data will go back into the hash table
			} else if (lastLen > 0 && !bitstringPtr->IsEmpty () && state == ALIVE) {

				storage.Append (columnID, serializeHere, lastLen);
			}

			// if we finished the tuple, stop serializing
			if (done)
				goto end;

			// NOW DO COLUMN 6
			columnID = 6;
			lastLen = mySegment.Extract (serializeHere, curSlot, i, whichWayPoint, columnID, dummy, done);
		
			// see if we got something... in the first two cases, we are extracting data for a disk-based join
			if (lastLen > 0 && state == DYING_AND_SEND && LHS) {

				// first, make sure that we are far enough along
				for (; col6LHSIsUsed[index] < bitmapColumnLHSIsUsed[index] - 1; col6LHSIsUsed[index]++) {
					col6IterLHS[index].Insert (col6);
					col6IterLHS[index].Advance ();
				}

				// now put the data in
				int *col6Ptr = ((int *) (serializeHere));
				col6IterLHS[index].Insert (*col6Ptr);
				col6IterLHS[index].Advance ();
				col6LHSIsUsed[index]++;

			} else if (lastLen > 0 && state == DYING_AND_SEND && !LHS) {

				FATAL ("Att 6 is only used by LHS... how did I find it in a RHS tuple?\n");

			// in the last case, the data will go back into the hash table
			} else if (lastLen > 0 && !bitstringPtr->IsEmpty () && state == ALIVE) {

				storage.Append (columnID, serializeHere, lastLen);
			}

end:			// AT THIS POINT, DONE WITH ALL OF THE COLUMNS!!

			// in this case, we have some data to put back into the new hash table
			if (!bitstringPtr->IsEmpty ()) {

				newSegment.Insert (storage, lastSlotAddedTo);
			}
		}
	}

	newSegment.ZeroOut (lastSlotAddedTo + 1, ABSOLUTE_HARD_CAP);
	
	// now we are at the final cleanup, where we build our output chunks... there could potentially be one
	// LHS chunk and one RHS chunk for each and every join waypoint	

	// this will hold all of the chunks we produce
	ExtractionList extractionResult;

	// first we see if there are any LHS chunks to build
	for (int i = 0; i < numDyingWaypoints; i++) {

		// declare one column for each LHS attribute
		Column hash;
		//Column bitmap; not needed anymore as we swap bitstring iterator itself
		Column col0;
		Column col1;
		Column col2;
		Column col3;
		Column col6;

		// kill the iterators for the hash and bitmap
		hashColumnIterLHS[i].Done (hash);
		bitmapColumnIterLHS[i].Done ();
		
		// this is the chunk we're building
		Chunk myChunk;

		// and see if we need to build a chunk
		if (bitmapColumnLHSIsUsed[i]) {


			// put the bitmap and the hash column in
			myChunk.SwapBitmap (bitmapColumnIterLHS[i]);
			myChunk.SwapHash (hash);

			// now add the atts, one-at-a-time, if valid
			if (col0LHSIsUsed[i]) {

				int col0DummyVal;

				// first, make sure that we are far enough along
				for (; col0LHSIsUsed[i] < bitmapColumnLHSIsUsed[i]; col0LHSIsUsed[i]++) {
					col0IterLHS[i].Insert (col0DummyVal);
					col0IterLHS[i].Advance ();
				}

				col0IterLHS[i].Done (col0);
				myChunk.SwapColumn (col0, 0);
			}

			if (col1LHSIsUsed[i]) {

				int col1DummyVal;

				// first, make sure that we are far enough along
				for (; col1LHSIsUsed[i] < bitmapColumnLHSIsUsed[i]; col1LHSIsUsed[i]++) {
					col1IterLHS[i].Insert (col1DummyVal);
					col1IterLHS[i].Advance ();
				}

				col1IterLHS[i].Done (col1);
				myChunk.SwapColumn (col1, 1);
			}
			
			if (col2LHSIsUsed[i]) {

				int col2DummyVal;

				// first, make sure that we are far enough along
				for (; col2LHSIsUsed[i] < bitmapColumnLHSIsUsed[i]; col2LHSIsUsed[i]++) {
					col2IterLHS[i].Insert (col2DummyVal);
					col2IterLHS[i].Advance ();
				}

				col2IterLHS[i].Done (col2);
				myChunk.SwapColumn (col2, 2);
			}

			if (col3LHSIsUsed[i]) {

				int col3DummyVal;

				// first, make sure that we are far enough along
				for (; col3LHSIsUsed[i] < bitmapColumnLHSIsUsed[i]; col3LHSIsUsed[i]++) {
					col3IterLHS[i].Insert (col3DummyVal);
					col3IterLHS[i].Advance ();
				}

				col3IterLHS[i].Done (col3);
				myChunk.SwapColumn (col3, 3);
			}

			if (col6LHSIsUsed[i]) {

				int col6DummyVal;

				// first, make sure that we are far enough along
				for (; col6LHSIsUsed[i] < bitmapColumnLHSIsUsed[i]; col6LHSIsUsed[i]++) {
					col6IterLHS[i].Insert (col6DummyVal);
					col6IterLHS[i].Advance ();
				}

				col6IterLHS[i].Done (col6);
				myChunk.SwapColumn (col6, 6);
			}

			// at this point, we have totally constructed the LHS chunk, so package it up
			// first, find out which of the join waypoints was put in this slot
			unsigned int whichJoin = 0;
			for (; wayPointInfo[whichJoin].index != i; whichJoin++);

			// now, find the disk waypoint that gets this guy's info
			WayPointID whichWayPoint;
			for (myWork.get_equivalences ().MoveToStart (); 1; myWork.get_equivalences ().Advance ()) {
				if (myWork.get_equivalences ().Current ().joinWayPointID == whichJoin) {
					whichWayPoint = myWork.get_equivalences ().Current ().diskBasedTwinID;
					break; 
				}	
			}

			// and put the info in
			int isLHS = 1;
			int whichSegment = whichSegment;
			ExtractedChunk myResult (isLHS, whichWayPoint, myChunk);
			extractionResult.Insert (myResult);
		}
	}
		

	// now we see if there are any RHS chunks to build
	for (int i = 0; i < numDyingWaypoints; i++) {

		// declare one column for each RHS attribute
		Column hash;
		//Column bitmap; not needed anymore as we swap iterator itself
		Column col4;
		Column col5;

		// kill the iterators
		hashColumnIterRHS[i].Done (hash);
		bitmapColumnIterRHS[i].Done ();
		
		// this is the chunk we're building
		Chunk myChunk;

		// and see if we need to build a chunk
		if (bitmapColumnRHSIsUsed[i]) {

			// put the bitmap and the hash column in
			myChunk.SwapBitmap (bitmapColumnIterRHS[i]);
			myChunk.SwapHash (hash);

			// now add the atts, one-at-a-time, if valid
			if (col4RHSIsUsed[i]) {

				int col4DummyVal;

				// first, make sure that we are far enough along
				for (; col4RHSIsUsed[i] < bitmapColumnRHSIsUsed[i]; col4RHSIsUsed[i]++) {
					col4IterRHS[i].Insert (col4DummyVal);
					col4IterRHS[i].Advance ();
				}

				col4IterRHS[i].Done (col4);
				myChunk.SwapColumn (col4, 4);
			}

			if (col5RHSIsUsed[i]) {

				int col5DummyVal;

				// first, make sure that we are far enough along
				for (; col5RHSIsUsed[i] < bitmapColumnRHSIsUsed[i]; col5RHSIsUsed[i]++) {
					col5IterRHS[i].Insert (col5DummyVal);
					col5IterRHS[i].Advance ();
				}

				col5IterRHS[i].Done (col5);
				myChunk.SwapColumn (col5, 1);
			}
			
			// first, find out which of the join waypoints was put in this slot
			unsigned int whichJoin = 0;
			for (; wayPointInfo[whichJoin].index != i; whichJoin++);

			// now, find the disk waypoint that gets this guy's info
			WayPointID whichWayPoint;
			for (myWork.get_equivalences ().MoveToStart (); 1; myWork.get_equivalences ().Advance ()) {
				if (myWork.get_equivalences ().Current ().joinWayPointID == whichJoin) {
					whichWayPoint = myWork.get_equivalences ().Current ().diskBasedTwinID;
					break; 
				}	
			}

			// at this point, we have totally constructed the RHS chunk, so package it up
			int isLHS = 0;
			int whichSegment = whichSegment;
			ExtractedChunk myResult (isLHS, whichWayPoint, myChunk);
			extractionResult.Insert (myResult);
		}
	}

	// and get outta here!
	ExtractionContainer finalResult (whichSegment, myWork.get_diskTokenQueue (), extractionResult);
	ExtractionResult reallyFinalResult (whichSegment, newSegment, finalResult);
	reallyFinalResult.swap (result);
	
	free (serializeHere);
	delete [] wayPointInfo;

	return 1;
}
