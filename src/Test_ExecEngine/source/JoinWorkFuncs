
#include "WorkDescription.h"
#include "ExecEngineData.h"
#include "Column.h"
#include "ColumnIterator.cc"
#include "MMappedStorage.h"
#include "BString.h"
#include "BStringIterator.h"
#include "IntFuncs.h"
#include "BitstringFuncs.h"

// Note: in this test, there are seven columns in each chunk.  The first
// four have the values that are going to be aggregated (the first is agged
// by query 0, the second by query 1, and so on).  The next (fifth) is hashed by
// query 0 and query 1.  The sixth is hashed (RHS) by query 2 and query 3; it is
// also used by query 1.  The seventh is hashed (LHS) by all queries.


int JoinRHSFunc (WorkDescription &workDescription, ExecEngineData &result) {
	
	// this is the area where all of the intermediate, serialized records are stored
	SerializedSegmentArray serializedSegments [NUM_SEGS];
	
	// this is the area where all of the records are serialized to;
	// 10K bytes are initially used for this
	void *serializeHere = (void *) malloc (10000);
	int storageSize = 10000;
	
	// go to the work description and get the input chunk
	JoinRHSWorkDescription myWork;
	myWork.swap (workDescription);
	Chunk &input = myWork.get_chunkToProcess ();

	// get the waypoint identifier
	unsigned int wayPointID = myWork.get_wayPointID ();

	// get the input bitmap out of the input chunk
	BStringIterator myInBStringIter;
	input.SwapBitmap (myInBStringIter);

	// get all of the queries that are active here
	QueryExitContainer &whichExits = myWork.get_whichQueryExits ();
	Bitstring whichQueries;
	whichQueries.Empty ();
	for (whichExits.MoveToStart (); whichExits.RightLength (); whichExits.Advance ()) {
		whichQueries.Union (whichExits.Current ().query); 
	}

	// extract the relevant input columns and build iterators for them
	Column col4, col5;
	input.SwapColumn (col4, 4);
	ColumnIterator <int> col4Iter (col4);
	input.SwapColumn (col5, 5);
	ColumnIterator <int> col5Iter (col5);

	// now actually hash all of the tuples!
	while (!myInBStringIter.AtUnwrittenByte ()) {
		
		// see which queries match up
		Bitstring curBits = myInBStringIter.GetCurrent ();
		
		// now we go thru all of the different hash possibilities in this tuple...
		// in this example code, each tuple is hashed two ways, depending upon the query

		// the first two queries use attribute four as a hash
		if (curBits.IsMember (0) || curBits.IsMember (1)) {

			// hash attribute 4
			HT_INDEX_TYPE hashValue = Hash (col4Iter.GetCurrent ());

			// figure out which of the hash buckets it goes into
			unsigned int index = WHICH_SEGMENT (hashValue);

			// and serialize the record!  Begin with the bitstring.  
			Bitstring myInBString;
			myInBString.Empty ();
			myInBString.AddMember (0);
			myInBString.AddMember (1);
			myInBString.Intersect (curBits);
			int bytesUsed = GetSerializedSize (myInBString);

			// Make sure we have the storage...
			if (bytesUsed > storageSize) {
				storageSize = bytesUsed;
				free (serializeHere);
				serializeHere = (void *) malloc (storageSize);
			}
				
			// do the serialization...
			void *location = OptimizedBinarySerialize (myInBString, serializeHere);
			
			// remember the serialized value
			serializedSegments[index].StartNew (WHICH_SLOT (hashValue), wayPointID, 1, location, bytesUsed);
			
			// now, go thru all of the attributes that are used by some att4 query

			// attribute 4 is first
			if (curBits.IsMember (0) || curBits.IsMember (1)) {

				// serialize the record
				int col4Val = col4Iter.GetCurrent ();
				bytesUsed = GetSerializedSize (col4Val);
				if (bytesUsed > storageSize) {
					storageSize = bytesUsed;
					free (serializeHere);
					serializeHere = (void *) malloc (storageSize);
				}

				// and record the serialized value
				location = OptimizedBinarySerialize (col4Val, serializeHere);
				serializedSegments[index].Append (4, location, bytesUsed);
			}

			// attribute 5 is second
			if (curBits.IsMember (1)) {

				// serialize the record
				int col5Val = col5Iter.GetCurrent ();
				bytesUsed = GetSerializedSize (col5Val);
				if (bytesUsed > storageSize) {
					storageSize = bytesUsed;
					free (serializeHere);
					serializeHere = (void *) malloc (storageSize);
				}

				// and record the serialized value
				location = OptimizedBinarySerialize (col5Val, serializeHere);
				serializedSegments[index].Append (5, location, bytesUsed);
			}
		}

		// the next two queries use attribute five as a hash
		if (curBits.IsMember (2) || curBits.IsMember (3)) {

			// hash attribute five
			HT_INDEX_TYPE hashValue = Hash (col5Iter.GetCurrent ());

			// figure out which of the hash buckets it goes into
			unsigned int index = WHICH_SEGMENT (hashValue);

			// and serialize the record!  Begin with the bitstring.  
			Bitstring myInBString;
			myInBString.Empty ();
			myInBString.AddMember (2);
			myInBString.AddMember (3);
			myInBString.Intersect (curBits);
			int bytesUsed = GetSerializedSize (myInBString);

			// Make sure we have the storage...
			if (bytesUsed > storageSize) {
				storageSize = bytesUsed;
				free (serializeHere);
				serializeHere = (void *) malloc (storageSize);
			}
				
			// do the serialization...
			void *location = OptimizedBinarySerialize (myInBString, serializeHere);
			
			// remember the serialized value
			serializedSegments[index].StartNew (WHICH_SLOT (hashValue), wayPointID, 1, location, bytesUsed);
			
			// now, go thru all of the attributes that are used by some att5 query
			if (curBits.IsMember (2) || curBits.IsMember (3)) {

				// serialize the record
				int col5Val = col5Iter.GetCurrent ();
				bytesUsed = GetSerializedSize (col5Val);
				if (bytesUsed > storageSize) {
					storageSize = bytesUsed;
					free (serializeHere);
					serializeHere = (void *) malloc (storageSize);
				}
				location = OptimizedBinarySerialize (col5Val, serializeHere);

				// and record the serialized value
				serializedSegments[index].Append (5, location, bytesUsed);
			}
		}

		// and advance everyone... only advance if you have the data!
		if (whichQueries.IsMember (0) || whichQueries.IsMember (1))
			col4Iter.Advance ();
		if (whichQueries.IsMember (1) || whichQueries.IsMember (2) || whichQueries.IsMember (3))
			col5Iter.Advance ();

		// last, advance the bitmap
		myInBStringIter.Advance ();	
	}

	// now we are done serializing the chunk
	free (serializeHere);	

	// so actually do the hashing... first set up the list of the guys we want to hash
	int theseAreOK [NUM_SEGS];
	for (int i = 0; i < NUM_SEGS; i++) {
		theseAreOK[i] = 1;
	}

	// this is the set of sample collisions taken from the over-full segments
	HashSegmentSample mySamples;

	// now go through and, one-at-a-time, add the data to each table segment
	for (int i = 0; i < NUM_SEGS; i++) {

		// first get a segment to add data to
		HashTableSegment checkedOutCopy;
		int whichOne = myWork.get_centralHashTable ().CheckOutOne (theseAreOK, checkedOutCopy);
		theseAreOK[whichOne] = 0;

		// now add the data
		HashSegmentSample mySample;
		if (checkedOutCopy.Insert (serializedSegments[whichOne], mySample)) {

			// if we are in here, it means that the segment was over-full, so note that we will
			// need to empty it out... we record all of the samples
			mySamples.MoveToFinish ();
			mySample.MoveToStart ();
			mySamples.SwapRights (mySample);
		}

		// and then put the segment back in the hash table
		myWork.get_centralHashTable ().CheckIn (whichOne);
	}

	// now we are finally done!
	JoinHashResult myResult (mySamples);
	myResult.swap (result);
	return 0;
}

int JoinLHSFunc (WorkDescription &workDescription, ExecEngineData &result) {
	
	// this is the area where all of the intermediate, serialized records are stored
	SerializedSegmentArray serializedSegments [NUM_SEGS];
	
	// this is the area where all of the records are serialized to;
	// 10K bytes are initially used for this
	void *serializeHere = (void *) malloc (10000);
	
	// this is the output chunk
	Chunk output;

	// go to the work description and get the input chunk
	JoinLHSWorkDescription myWork;
	myWork.swap (workDescription);
	Chunk &input = myWork.get_chunkToProcess ();

	// get the waypoint ID from the chunk
	int wayPointID = myWork.get_wayPointID ();

	// get the input bitmap out of the input chunk
	BStringIterator myInBStringIter;
	input.SwapBitmap (myInBStringIter);

	// get all of the queries that are active here
	QueryExitContainer &whichExits = myWork.get_whichQueryExits ();
	Bitstring whichQueries;
	whichQueries.Empty ();
	for (whichExits.MoveToStart (); whichExits.RightLength (); whichExits.Advance ()) {
		whichQueries.Union (whichExits.Current ().query); 
	}

	// extract the relevant input columns and build iterators for them
        Column col0, col1, col2, col3, col6;
        input.SwapColumn (col0, 0);
        ColumnIterator <int> col0Iter (col0);
        input.SwapColumn (col1, 1);
        ColumnIterator <int> col1Iter (col1);
        input.SwapColumn (col2, 2);
        ColumnIterator <int> col2Iter (col2);
        input.SwapColumn (col3, 3);
        ColumnIterator <int> col3Iter (col3);
        input.SwapColumn (col6, 6);
        ColumnIterator <int> col6Iter (col6);

	// these manage the output columns that come from the LHS; used only if stillShallow = 0
	ColumnIterator <int> col0IterOut;
	ColumnIterator <int> col1IterOut;
	ColumnIterator <int> col2IterOut;
	ColumnIterator <int> col3IterOut;

	// these manage the output columns that come from the RHS (now stored in the hash table)
	MMappedStorage myStore5;
	Column col5 (myStore5);
	ColumnIterator <int> col5IterOut (col5);

	// this is the ouput bitstring
        MMappedStorage myStore;
        Column bitmapOut (myStore);
        BStringIterator myOutBStringIter (bitmapOut, whichQueries);

	// now we extract all of the hash table segments... after this, myEntries will hold them all
	HashTableView myView;
	myWork.get_centralHashTable ().EnterReader (myView);
	HashTableSegment myEntries[NUM_SEGS];
	myView.ExtractAllSegments (myEntries);

	// this tells us that we are "still shallow"---not making a deep copy of the LHS atts to the output
	int stillShallow = 1;

	// these are all of the attribute values that come from the input chunk
	int att0, att1, att2, att3, att6;

	// the bitstring that will be exracted from the hash table
	Bitstring64 *bitstringRHS = 0;

	// these are all of the attribute values that come from the hash table...
	// for each att we need a pointer as well as a dummy value that the pointer will be set to by default
	int att4RHSShadow;
	int *att4RHS; 
	int att5RHSShadow;
	int *att5RHS;

	// now actually try to match up all of the tuples!
	int totalNum = 0;
	while (!myInBStringIter.AtUnwrittenByte ()) {

		// counts how many matches for this query
		int numHits = 0;

		// see which queries match up
		Bitstring curBits = myInBStringIter.GetCurrent ();
		curBits.Intersect (whichQueries);
		
		// now go through the LHS input atts one at a time and extract if it is needed by an active query
		if (curBits.IsMember (0)) 
			att0 = col0Iter.GetCurrent ();
		if (curBits.IsMember (1)) 
			att1 = col1Iter.GetCurrent ();
		if (curBits.IsMember (2)) 
			att2 = col2Iter.GetCurrent ();
		if (curBits.IsMember (3)) 
			att3 = col3Iter.GetCurrent ();
		if (curBits.IsMember (0) || curBits.IsMember (1) || curBits.IsMember (2) || curBits.IsMember (3)) 
			att6 = col6Iter.GetCurrent ();

		// if the input query is not empty
		if (!curBits.IsEmpty ()) {

			// compute the hash
			HT_INDEX_TYPE hashValue = Hash (att6);

			// figure out which of the hash buckets it goes into
			unsigned int index = WHICH_SEGMENT (hashValue);

			// now, go to that index and extract matching tuples!
			HT_INDEX_TYPE curSlot = WHICH_SLOT (hashValue);
			hashValue = curSlot;

			// this loops through all of the possible RHS hits
			while (1) {

				// this is the bitstring that will go in the output
				Bitstring bitstringLHS;
				bitstringLHS.Empty ();

				// for safety (in case we look at a bitstring that spans multiple
				// entries that is not done being written by a concurrent writer)
				// empty out the inital bitstring
				((Bitstring *) serializeHere)->Empty ();

				// give safe "shadow" values to all of the RHS attributes
				att4RHS = &att4RHSShadow; 
				att5RHS = &att5RHSShadow;

				// here we go through and extract the atts one at a time from the hash
				// table.  Note that the atts must be extracted IN ORDER.  That is, the
				// bitstring is first, followed by the att mapped to the lowerest column
				// position, followed by the att mapped to the next lowest, and so on.

				// The Extract function pulls an attribute out of the hash table...
				int lenSoFar = 0, dummy, done;
				int lastLen = myEntries[index].Extract (serializeHere, curSlot, hashValue, 
					wayPointID, BITMAP, dummy, done);

				// if we cannot find a bitstring, there was no tuple here, and we are done
				if (lastLen == 0) {
					break;
				}

				// remember the bitstring
				bitstringRHS = (Bitstring *) serializeHere;
				lenSoFar += lastLen;

				// if we have fully processed the tuple, get outta here
				if (done)
					goto end;

				// next look for attribute 4
				lastLen = myEntries[index].Extract (serializeHere + lenSoFar, curSlot, hashValue, wayPointID, 4, dummy, done);

				// see if we got att 4
				if (lastLen > 0) {
					att4RHS = ((int *) (serializeHere + lenSoFar));
					lenSoFar += lastLen;
				}

				// if we have fully processed the tuple, get outta here
				if (done)
					goto end;

				// next look for attribute 5
				lastLen = myEntries[index].Extract (serializeHere + lenSoFar, curSlot, hashValue, wayPointID, 5, dummy, done);

				// see if we got att 5
				if (lastLen > 0) {
					att5RHS = ((int *) (serializeHere + lenSoFar));
					lenSoFar += lastLen;
				}
				
				// if there were other atts to exract for this waypoint, they would go here!

end:				// see if we have any query matches
				bitstringRHS->Intersect (curBits);

				// see which queries hit; this runs the join predicate for each of the queries
				if (bitstringRHS->IsMember (0) && *att4RHS == att6)
					bitstringLHS.AddMember (0);
				if (bitstringRHS->IsMember (1) && *att4RHS == att6) 
					bitstringLHS.AddMember (1);
				if (bitstringRHS->IsMember (2) && *att5RHS == att6) 
					bitstringLHS.AddMember (2);
				if (bitstringRHS->IsMember (3) && *att5RHS == att6)
					bitstringLHS.AddMember (3);


				// if any of them hit...
				if (!bitstringLHS.IsEmpty ()) {

					numHits++;

 					// see if we need to move from shallow to deep
					if (numHits == 2 && stillShallow) {

						// if so, make the move... this requires changing all of the LHS atts that go
						// to the output from shallow to deep
						if (whichQueries.IsMember (0)) {
							col0IterOut.CreateDeepCopy (col0Iter);
							col0IterOut.Insert (att0);
							col0IterOut.Advance ();
						}
						if (whichQueries.IsMember (1)) {
							col1IterOut.CreateDeepCopy (col1Iter);
							col1IterOut.Insert (att1);
							col1IterOut.Advance ();
						}
						if (whichQueries.IsMember (2)) {
							col2IterOut.CreateDeepCopy (col2Iter);
							col2IterOut.Insert (att2);
							col2IterOut.Advance ();
						}
						if (whichQueries.IsMember (3)) {
							col3IterOut.CreateDeepCopy (col3Iter);
							col3IterOut.Insert (att3);
							col3IterOut.Advance ();
						}
						
						stillShallow = 0;
					}

					// now, add all of the outputs over... first deal with the LHS input atts
					// that get copied into output atts
					if (!stillShallow) {
						if (whichQueries.IsMember (0)) {
							col0IterOut.Insert (att0);
							col0IterOut.Advance ();
						}
						if (whichQueries.IsMember (1)) {
							col1IterOut.Insert (att1);
							col1IterOut.Advance ();
						}
						if (whichQueries.IsMember (2)) {
							col2IterOut.Insert (att2);
							col2IterOut.Advance ();
						}
						if (whichQueries.IsMember (3)) {
							col3IterOut.Insert (att3);
							col3IterOut.Advance ();
						}
					}

					// now, deal with the output atts that come from the hash table
					if (whichQueries.IsMember (1)) {
						col5IterOut.Insert (*att5RHS);
						col5IterOut.Advance ();
					}
					
					// finally, set the bitmap
					myOutBStringIter.Insert (bitstringLHS);
               				myOutBStringIter.Advance ();
					totalNum++;
				}

			}
		}

		// at this point, we are done trying to join this tuple... any join results have been
		// written to the output columns.  Note that we don't have to advance in the output data
		// columns; if we are shallow, we don't touch the output columns.  If we are not shallow,
		// if there were no results, we have nothing to write.  HOWEVER, if we are shallow and
		// we did not get a match, we need to add an empty btstring
		if (stillShallow && numHits == 0) {
			Bitstring bitstringLHS;
			bitstringLHS.Empty ();
			myOutBStringIter.Insert (bitstringLHS);
			myOutBStringIter.Advance ();
			totalNum++;
		}

		// lastly, we need to advance in the INPUT tuples
		if (whichQueries.IsMember (0))
			col0Iter.Advance ();
		if (whichQueries.IsMember (1))
			col1Iter.Advance ();
		if (whichQueries.IsMember (2))
			col2Iter.Advance ();
		if (whichQueries.IsMember (3))
			col3Iter.Advance ();
		if (whichQueries.IsMember (0) || whichQueries.IsMember (1) || whichQueries.IsMember (2) || whichQueries.IsMember (3))
			col6Iter.Advance ();
		
		// advance the input bitstring
		myInBStringIter.Advance ();

	}

	// DONE!  So construct the output tuple

	// if we are still shallow, put the original data into the output
	if (stillShallow) {
	        col0Iter.Done (col0);
        	col1Iter.Done (col1);
       		col2Iter.Done (col2);
        	col3Iter.Done (col3);
	} else {
	        col0IterOut.Done (col0);
        	col1IterOut.Done (col1);
       		col2IterOut.Done (col2);
        	col3IterOut.Done (col3);
	}

	// deal with the column(s) that come from the hash table
	col5IterOut.Done (col5);
	
	// put in the output columns
       	output.SwapColumn (col0, 0);
	output.SwapColumn (col1, 1);
       	output.SwapColumn (col2, 2);
       	output.SwapColumn (col3, 3);
       	output.SwapColumn (col5, 5);

	// put in the output bitmap
	myOutBStringIter.Done ();
	output.SwapBitmap (myOutBStringIter);

        // and give back the result
        ChunkContainer tempResult (output);
        tempResult.swap (result);

	free (serializeHere);	

        return 1;
}


int JoinLHSHashFunc (WorkDescription &workDescription, ExecEngineData &result) {
	
	// this is the area where all of the intermediate, serialized records are stored
	SerializedSegmentArray serializedSegments [NUM_SEGS];
	
	// this is the area where all of the records are serialized to;
	// 10K bytes are initially used for this
	void *serializeHere = (void *) malloc (10000);
	int storageSize = 10000;
	
	// go to the work description and get the input chunk
	JoinLHSWorkDescription myWork;
	myWork.swap (workDescription);
	Chunk &input = myWork.get_chunkToProcess ();

	// get the waypoint identifier
	unsigned int wayPointID = myWork.get_wayPointID ();

	// get the input bitmap out of the input chunk
	BStringIterator myInBStringIter;
	input.SwapBitmap (myInBStringIter);

	// get all of the queries that are active here
	QueryExitContainer &whichExits = myWork.get_whichQueryExits ();
	Bitstring whichQueries;
	whichQueries.Empty ();
	for (whichExits.MoveToStart (); whichExits.RightLength (); whichExits.Advance ()) {
		whichQueries.Union (whichExits.Current ().query); 
	}

	// extract the relevant input columns and build iterators for them
	Column col0, col1, col2, col3, col6;
	input.SwapColumn (col0, 0);
	ColumnIterator <int> col0Iter (col0);
	input.SwapColumn (col1, 1);
	ColumnIterator <int> col1Iter (col1);
	input.SwapColumn (col2, 2);
	ColumnIterator <int> col2Iter (col2);
	input.SwapColumn (col3, 3);
	ColumnIterator <int> col3Iter (col3);
	input.SwapColumn (col6, 6);
	ColumnIterator <int> col6Iter (col6);

	// now actually hash all of the tuples!
	while (!myInBStringIter.AtUnwrittenByte ()) {
		
		// see which queries match up
		Bitstring curBits = myInBStringIter.GetCurrent ();
		curBits.Intersect (whichQueries);
		
		// now we go thru all of the different hash possibilities in this tuple...
		// in this example code, each tuple is hashed on attribute 6 
		if (curBits.IsMember (0) || curBits.IsMember (1) || curBits.IsMember (2) || curBits.IsMember (3)) {

			// hash attribute 6
			HT_INDEX_TYPE hashValue = Hash (col6Iter.GetCurrent ());

			// figure out which of the hash buckets it goes into
			unsigned int index = WHICH_SEGMENT (hashValue);

			// and serialize the record!  Begin with the bitstring.  
			Bitstring myInBString;
			myInBString.Empty ();
			myInBString.AddMember (0);
			myInBString.AddMember (1);
			myInBString.AddMember (2);
			myInBString.AddMember (3);
			myInBString.Intersect (curBits);
			int bytesUsed = GetSerializedSize (myInBString);

			// Make sure we have the storage...
			if (bytesUsed > storageSize) {
				storageSize = bytesUsed;
				free (serializeHere);
				serializeHere = (void *) malloc (storageSize);
			}
				
			// do the serialization...
			void *location = OptimizedBinarySerialize (myInBString, serializeHere);
			
			// remember the serialized value
			serializedSegments[index].StartNew (WHICH_SLOT (hashValue), wayPointID, 0, location, bytesUsed);
			
			// now, go thru all of the attributes that are used by some att4 query

			// attribute 0 is first
			if (curBits.IsMember (0)) {

				// serialize the record
				int col0Val = col0Iter.GetCurrent ();
				bytesUsed = GetSerializedSize (col0Val);
				if (bytesUsed > storageSize) {
					storageSize = bytesUsed;
					free (serializeHere);
					serializeHere = (void *) malloc (storageSize);
				}

				// and record the serialized value
				location = OptimizedBinarySerialize (col0Val, serializeHere);
				serializedSegments[index].Append (0, location, bytesUsed);
			}

			// attribute 1 is second
			if (curBits.IsMember (1)) {

				// serialize the record
				int col1Val = col1Iter.GetCurrent ();
				bytesUsed = GetSerializedSize (col1Val);
				if (bytesUsed > storageSize) {
					storageSize = bytesUsed;
					free (serializeHere);
					serializeHere = (void *) malloc (storageSize);
				}

				// and record the serialized value
				location = OptimizedBinarySerialize (col1Val, serializeHere);
				serializedSegments[index].Append (1, location, bytesUsed);
			}

			// attribute 2 is third
			if (curBits.IsMember (2)) {

				// serialize the record
				int col2Val = col2Iter.GetCurrent ();
				bytesUsed = GetSerializedSize (col2Val);
				if (bytesUsed > storageSize) {
					storageSize = bytesUsed;
					free (serializeHere);
					serializeHere = (void *) malloc (storageSize);
				}

				// and record the serialized value
				location = OptimizedBinarySerialize (col2Val, serializeHere);
				serializedSegments[index].Append (2, location, bytesUsed);
			}

			// attribute 3 is fourth
			if (curBits.IsMember (3)) {

				// serialize the record
				int col3Val = col3Iter.GetCurrent ();
				bytesUsed = GetSerializedSize (col3Val);
				if (bytesUsed > storageSize) {
					storageSize = bytesUsed;
					free (serializeHere);
					serializeHere = (void *) malloc (storageSize);
				}

				// and record the serialized value
				location = OptimizedBinarySerialize (col3Val, serializeHere);
				serializedSegments[index].Append (3, location, bytesUsed);
			}

			// attribute 6 is last
			if (curBits.IsMember (0) || curBits.IsMember (1) || curBits.IsMember (2) || curBits.IsMember (3)) {

				// serialize the record
				int col6Val = col6Iter.GetCurrent ();
				bytesUsed = GetSerializedSize (col6Val);
				if (bytesUsed > storageSize) {
					storageSize = bytesUsed;
					free (serializeHere);
					serializeHere = (void *) malloc (storageSize);
				}

				// and record the serialized value
				location = OptimizedBinarySerialize (col6Val, serializeHere);
				serializedSegments[index].Append (6, location, bytesUsed);
			}
		}

		// advance all of the input iterators
		if (whichQueries.IsMember (0))
			col0Iter.Advance ();
		if (whichQueries.IsMember (1))
			col1Iter.Advance ();
		if (whichQueries.IsMember (2))
			col2Iter.Advance ();
		if (whichQueries.IsMember (3))
			col3Iter.Advance ();
		if (whichQueries.IsMember (0) || whichQueries.IsMember (1) || whichQueries.IsMember (2) || whichQueries.IsMember (3))
			col6Iter.Advance ();
		// last, advance the bitmap
		myInBStringIter.Advance ();	
	}

	// now we are done serializing the chunk
	free (serializeHere);	

	// so actually do the hashing... first set up the list of the guys we want to hash
	int theseAreOK [NUM_SEGS];
	for (int i = 0; i < NUM_SEGS; i++) {
		theseAreOK[i] = 1;
	}

	// these are a set of sampled collisions
	HashSegmentSample mySamples;
	
	// now go through and, one-at-a-time, add the data to each table segment
	for (int i = 0; i < NUM_SEGS; i++) {

		// first get a segment to add data to
		HashTableSegment checkedOutCopy;
		int whichOne = myWork.get_centralHashTable ().CheckOutOne (theseAreOK, checkedOutCopy);
		theseAreOK[whichOne] = 0;

		// now add the data
		HashSegmentSample mySample;
		if (checkedOutCopy.Insert (serializedSegments[whichOne], mySample)) {

			// if we are in here, it means that the segment was over-full, so note that we will
			// need to empty it out... first we record all of the samples
			mySamples.MoveToFinish ();
			mySample.MoveToStart ();
			mySamples.SwapRights (mySample);
		}

		// and then put the segment back in the hash table
		myWork.get_centralHashTable ().CheckIn (whichOne);
	}

	// now we are finally done!
	JoinHashResult myResult (mySamples);
	myResult.swap (result);
	return 0;
}

