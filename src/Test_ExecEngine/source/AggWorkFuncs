
#include "WorkDescription.h"
#include "ExecEngineData.h"
#include "Column.h"
#include "ColumnIterator.cc"
#include "MMappedStorage.h"
#include "BString.h"
#include "BStringIterator.h"

// Note: in this test, there are seven columns in each chunk.  The first
// four have the values that are going to be aggregated (the first is agged
// by query 0, the second by query 1, and so on).  The next (fifth) is hashed by
// query 0 and query 1.  The sixth is hashed (RHS) by query 2 and query 3; it is
// also used by query 1.  The seventh is hashed (LHS) by all queries.


int FinishUpAggWorkFunc (WorkDescription &workDescription, ExecEngineData &result) {

	FinishAggregate myWork;
	myWork.swap (workDescription);

	// set up the output chunk
	Chunk output;

	// this will tell us which queries are present in the output chunk
	Bitstring whichOnes = 0;

	QueryExitContainer &whichQueries = myWork.get_whichQueryExits ();
	for (whichQueries.MoveToStart (); whichQueries.RightLength (); whichQueries.Advance ()) {
		
		// find this guy's agg result
		AggStorageMap &myMap = myWork.get_aggFuncs ();
		myMap.Lock ();
		AggStorage &agg = myMap.Find (whichQueries.Current ().query);
		
		// add this query to the output
		whichOnes.Union (whichQueries.Current ().query);

		// get the final aggregate result
		int myData;
		agg.Pop (&myData);
		myMap.Unlock ();

		// and put him into the output chunk
		MMappedStorage myStore;
		Column myCol (myStore);
		ColumnIterator <int> myIter (myCol);
		myIter.Insert (myData);
		myIter.Advance ();
		myIter.Done (myCol);
		int whichQuery;
		for (whichQuery = 0; !whichQueries.Current ().query.IsMember (whichQuery); whichQuery++);
		output.SwapColumn (myCol, whichQuery);	
	}

	// lastly, put the bitmap in
	MMappedStorage myStore;
	Column myCol (myStore);
	BStringIterator myIter (myCol, whichOnes, 1);
	myIter.Done ();
	output.SwapBitmap (myIter);

	// and get outta here!	
	ChunkContainer tempResult (output);
	tempResult.swap (result);

  // Alin: 1 has to be returned here for the SendAckMsg
	return 1;
}

static int callNum = 0;

int AggWorkFunc (WorkDescription &workDescription, ExecEngineData &result) {

	AggregateOneChunk myWork;
	myWork.swap (workDescription);

	// get the input bitmap out of the input chunk
	Chunk &input = myWork.get_chunkToProcess ();
	//Column bitmapIn;
	BStringIterator myInBStringIter;
	input.SwapBitmap (myInBStringIter);

	// get all of the queries that are active here
	QueryExitContainer &whichExits = myWork.get_whichQueryExits ();
	Bitstring whichQueries;
	whichQueries.Empty ();
	for (whichExits.MoveToStart (); whichExits.RightLength (); whichExits.Advance ()) {
		whichQueries.Union (whichExits.Current ().query); 
	}

	// now, process the chunk... start by initing all of the sums to zero
	int sum[4];
	for (int j = 0; j < 4; j++) {
		sum[j] = 0;
	}

	// extract the relevant columns and build iterators for them
	Column col0, col1, col2, col3;
	input.SwapColumn (col0, 0);
	ColumnIterator <int> col0Iter (col0);
	input.SwapColumn (col1, 1);
	ColumnIterator <int> col1Iter (col1);
	input.SwapColumn (col2, 2);
	ColumnIterator <int> col2Iter (col2);
	input.SwapColumn (col3, 3);
	ColumnIterator <int> col3Iter (col3);

	// now actually run the aggregation!
	while (!myInBStringIter.AtUnwrittenByte ()) {
		
		// see which queries match up
		Bitstring curBits = myInBStringIter.GetCurrent ();
		curBits.Intersect (whichQueries);

		// do the aggregation
		if (curBits.IsMember (0)) 
			sum[0] += col0Iter.GetCurrent ();
		if (curBits.IsMember (1)) 
			sum[1] += col1Iter.GetCurrent ();
		if (curBits.IsMember (2))
			sum[2] += col2Iter.GetCurrent ();
		if (curBits.IsMember (3)) 
			sum[3] += col3Iter.GetCurrent ();
		
		// and advance everyone
		if (whichQueries.IsMember (0))
			col0Iter.Advance ();
		if (whichQueries.IsMember (1))
			col1Iter.Advance ();
		if (whichQueries.IsMember (2))
			col2Iter.Advance ();
		if (whichQueries.IsMember (3))
			col3Iter.Advance ();

		// last, advance the bitmap
		myInBStringIter.Advance ();	
	}

	for (int i = 0; i < 4; i++) {
		if (sum[i] > 0)
		cout << sum[i] << " ";
	}

	/*static int blah = 0;
	if (sum[2] % 5000 != 0) {
		blah++;
		if (blah == 13) {
			col2Iter.Done (col2);
			myInBStringIter.Done (bitmapIn);
			BStringIterator myInBStringIter2 (bitmapIn);
			ColumnIterator <int> col2Iter2 (col2);
			cout << " REALLY BAD!\n";
			int j = 0;
			int tot = 0;
			while (!myInBStringIter2.AtUnwrittenByte ()) {
				Bitstring curBits = myInBStringIter2.GetCurrent ();
				int i = col2Iter2.GetCurrent ();
				if (curBits.IsMember (2)) {
					cout << "(" << curBits.IsMember (2) << ", " << j << ", " << i << ")";
					tot += i;
				}
				j++;
				col2Iter2.Advance ();
				myInBStringIter2.Advance ();
			}
			cout << tot << "\n";
			cout << sum[2] << "\n";
		}
	}*/

	// now update the aggregates
	AggStorageMap &myMap = myWork.get_aggFuncs ();
	
	myMap.Lock ();
	for (whichExits.MoveToStart (); whichExits.RightLength (); whichExits.Advance ()) {

		// find the int associated with this query
		int whichQuery;
		for (whichQuery = 0; !whichExits.Current ().query.IsMember (whichQuery); whichQuery++);
		
		// if the agg is already there, just add it in
		if (myMap.IsThere (whichExits.Current ().query)) {
			AggStorage &agg = myMap.Find (whichExits.Current ().query);
			int myData;
			agg.Pop (&myData);
			myData += sum[whichQuery];
			agg.Push (&myData, sizeof (int));
	
		// add it if the agg is not already there
		} else {
			AggStorage agg;
			agg.Push (&(sum[whichQuery]), sizeof (int));
			QueryID queryCopy = whichExits.Current ().query;
			myMap.Insert (queryCopy, agg);
		}
	}
	myMap.Unlock ();
			
  // Alin: 0 has to be returned here for the SendAckMsg
	return 0;
}

