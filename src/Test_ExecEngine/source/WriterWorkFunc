
#include "WorkDescription.h"
#include "ExecEngineData.h"
#include "Column.h"
#include "ColumnIterator.cc"
#include "MMappedStorage.h"
#include "BString.h"
#include "BStringIterator.h"

int leftTots[4];
int rightTots[4];
pthread_mutex_t *counterMutex;

int WriterFunc (WorkDescription &workDescription, ExecEngineData &result) {
	
	// go to the work description and get the input chunk
	WriterWorkDescription myWork;
	myWork.swap (workDescription);
	
	// get the actual work we need to do
	ExtractionList &myList = myWork.get_extractionList ();

	// this is the identifier of the waypoint we belong to
	WayPointID myID = myWork.get_whichWayPoint ();

	// now, count all of the tuples
	int leftCounts[4];
	int rightCounts[4];
	for (int i = 0; i < 4; i++) {
		leftCounts[i] = rightCounts[i] = 0;
	}

	int counter = 0;
	for (myList.MoveToStart (); myList.RightLength (); myList.Advance ()) {

		// see if this is a different waypoint
		if (!(myList.Current ().get_whichWayPoint () == myID)) 	
			continue;

		Chunk &myChunk = myList.Current ().get_myChunk ();
		//Column bitmapIn;
		BStringIterator myInBStringIter;
		myChunk.SwapBitmap (myInBStringIter);

		// now actually count how many tuples match
		while (!myInBStringIter.AtUnwrittenByte ()) {
		
			// see which queries match up
			Bitstring curBits = myInBStringIter.GetCurrent ();

			// do the actual selection
			int *counters;
			if (myList.Current ().get_isLHS ()) 
				counters = leftCounts;
			else
				counters = rightCounts;

			for (int i = 0; i < 4; i++) {
				if (curBits.IsMember (i)) 
					counters[i]++;
			}

			// and move on
			myInBStringIter.Advance ();
			counter++;
		}
	}


	// and then write out the answer
	pthread_mutex_lock (counterMutex);
	cout << "Writer is writing segment " << myWork.get_whichSegment () << " (" << counter << " tuples).\n";
	cout << "****written tuple counts are:\n";
	for (int i = 0; i < 4; i++) {
		leftTots[i] += leftCounts[i];
		rightTots[i] += rightCounts[i];
		cout << "\tquery " << i << ": (LHS) " << leftTots[i] << " (RHS) ";
		cout << rightTots[i] << "\n";
	}
	pthread_mutex_unlock (counterMutex);

	return 0;
}

