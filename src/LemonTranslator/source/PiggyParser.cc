//
//  Copyright 2012 Alin Dobra and Christopher Jermaine
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//
/** \file
 *  This C source file was generated by $ANTLR version 3.3 Nov 30, 2010 12:50:56
 *
 *     -  From the grammar source file : Piggy.g
 *     -                            On : 2012-06-14 15:15:14
 *     -                for the parser : PiggyParserParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "PiggyParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pPiggyParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pPiggyParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pPiggyParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pPiggyParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER		    
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO		    
#undef		DBG

#define	    PARSER				ctx->pParser  
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger

#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   PiggyParserTokenNames[96+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "FILTER",
        (pANTLR3_UINT8) "JOIN",
        (pANTLR3_UINT8) "GLA",
        (pANTLR3_UINT8) "PRINT",
        (pANTLR3_UINT8) "AGGREGATE",
        (pANTLR3_UINT8) "EQUAL",
        (pANTLR3_UINT8) "SEPARATOR",
        (pANTLR3_UINT8) "ATTRIBUTES",
        (pANTLR3_UINT8) "TEXTLOADER",
        (pANTLR3_UINT8) "FILE",
        (pANTLR3_UINT8) "MATCH_DP",
        (pANTLR3_UINT8) "CASE_DP",
        (pANTLR3_UINT8) "BOOL_T",
        (pANTLR3_UINT8) "ID",
        (pANTLR3_UINT8) "INT",
        (pANTLR3_UINT8) "EXPONENT",
        (pANTLR3_UINT8) "FLOAT",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "ESC_SEQ",
        (pANTLR3_UINT8) "STRING",
        (pANTLR3_UINT8) "SEMICOLON",
        (pANTLR3_UINT8) "COMMA",
        (pANTLR3_UINT8) "COLON",
        (pANTLR3_UINT8) "DOT",
        (pANTLR3_UINT8) "LPAREN",
        (pANTLR3_UINT8) "RPAREN",
        (pANTLR3_UINT8) "LSQ",
        (pANTLR3_UINT8) "RSQ",
        (pANTLR3_UINT8) "QMARK",
        (pANTLR3_UINT8) "LAND",
        (pANTLR3_UINT8) "LOR",
        (pANTLR3_UINT8) "BAND",
        (pANTLR3_UINT8) "BOR",
        (pANTLR3_UINT8) "XOR",
        (pANTLR3_UINT8) "LNOT",
        (pANTLR3_UINT8) "ISEQUAL",
        (pANTLR3_UINT8) "NEQUAL",
        (pANTLR3_UINT8) "LS",
        (pANTLR3_UINT8) "GT",
        (pANTLR3_UINT8) "LE",
        (pANTLR3_UINT8) "GE",
        (pANTLR3_UINT8) "NOT",
        (pANTLR3_UINT8) "SLEFT",
        (pANTLR3_UINT8) "SRIGHT",
        (pANTLR3_UINT8) "PLUS",
        (pANTLR3_UINT8) "MINUS",
        (pANTLR3_UINT8) "TIMES",
        (pANTLR3_UINT8) "DIVIDE",
        (pANTLR3_UINT8) "MOD",
        (pANTLR3_UINT8) "HEX_DIGIT",
        (pANTLR3_UINT8) "UNICODE_ESC",
        (pANTLR3_UINT8) "OCTAL_ESC",
        (pANTLR3_UINT8) "OP",
        (pANTLR3_UINT8) "NEWSTATEMENT",
        (pANTLR3_UINT8) "OLDSTATEMENT",
        (pANTLR3_UINT8) "ATTS",
        (pANTLR3_UINT8) "ATT",
        (pANTLR3_UINT8) "FUNCTION",
        (pANTLR3_UINT8) "OPDEF",
        (pANTLR3_UINT8) "OPERATOR",
        (pANTLR3_UINT8) "UOPERATOR",
        (pANTLR3_UINT8) "DELWAYPOINT",
        (pANTLR3_UINT8) "DELQUERY",
        (pANTLR3_UINT8) "CRDATATYPE",
        (pANTLR3_UINT8) "CRSYNONIM",
        (pANTLR3_UINT8) "FCT",
        (pANTLR3_UINT8) "TPATT",
        (pANTLR3_UINT8) "ATTFROM",
        (pANTLR3_UINT8) "ATTWT",
        (pANTLR3_UINT8) "ATTSWT",
        (pANTLR3_UINT8) "RUN__",
        (pANTLR3_UINT8) "QUERRY__",
        (pANTLR3_UINT8) "WAYPOINT__",
        (pANTLR3_UINT8) "SELECT__",
        (pANTLR3_UINT8) "TERMCONN",
        (pANTLR3_UINT8) "SCANNER__",
        (pANTLR3_UINT8) "WRITER__",
        (pANTLR3_UINT8) "GLATEMPLATE",
        (pANTLR3_UINT8) "LIST",
        (pANTLR3_UINT8) "CRGLA",
        (pANTLR3_UINT8) "CRRELATION",
        (pANTLR3_UINT8) "FLUSHTOKEN",
        (pANTLR3_UINT8) "QUITTOKEN",
        (pANTLR3_UINT8) "FILE__",
        (pANTLR3_UINT8) "TEXTLOADER__",
        (pANTLR3_UINT8) "ATTC",
        (pANTLR3_UINT8) "LOAD",
        (pANTLR3_UINT8) "READ",
        (pANTLR3_UINT8) "USING",
        (pANTLR3_UINT8) "FROM",
        (pANTLR3_UINT8) "BY",
        (pANTLR3_UINT8) "STORE",
        (pANTLR3_UINT8) "AS",
        (pANTLR3_UINT8) "TO",
        (pANTLR3_UINT8) "INTO"
       };

        

// Forward declare the locally static matching functions we have generated.
//
static PiggyParser_parse_return	parse    (pPiggyParser ctx, LemonTranslator* trans);
static PiggyParser_statements_return	statements    (pPiggyParser ctx);
static PiggyParser_statement_return	statement    (pPiggyParser ctx);
static PiggyParser_actionBody_return	actionBody    (pPiggyParser ctx);
static PiggyParser_glaDef_return	glaDef    (pPiggyParser ctx);
static PiggyParser_glaTemplateDef_return	glaTemplateDef    (pPiggyParser ctx);
static PiggyParser_glaTemplArg_return	glaTemplArg    (pPiggyParser ctx);
static PiggyParser_constArgs_return	constArgs    (pPiggyParser ctx);
static PiggyParser_attEListAlt_return	attEListAlt    (pPiggyParser ctx);
static void	PiggyParserFree(pPiggyParser ctx);
static void     PiggyParserReset (pPiggyParser ctx);

// Delegated rules
//
static Piggy_BaseParser_multiplicative_expression_return multiplicative_expression(pPiggyParser ctx);
static Piggy_BaseParser_function_return function(pPiggyParser ctx);
static Piggy_BaseParser_attribute_return attribute(pPiggyParser ctx);
static Piggy_BaseParser_inclusive_or_expression_return inclusive_or_expression(pPiggyParser ctx);
static Piggy_BaseParser_equality_expression_return equality_expression(pPiggyParser ctx);
static Piggy_BaseParser_idList_return idList(pPiggyParser ctx);
static Piggy_BaseParser_conditional_expression_return conditional_expression(pPiggyParser ctx);
static Piggy_BaseParser_attListWTypes_return attListWTypes(pPiggyParser ctx);
static Piggy_BaseParser_shift_expression_return shift_expression(pPiggyParser ctx);
static Piggy_BaseParser_attCList_return attCList(pPiggyParser ctx);
static Piggy_BaseParser_and_expression_return and_expression(pPiggyParser ctx);
static Piggy_BaseParser_expression_return expression(pPiggyParser ctx);
static Piggy_BaseParser_logical_and_expression_return logical_and_expression(pPiggyParser ctx);
static Piggy_BaseParser_attributeList_return attributeList(pPiggyParser ctx);
static Piggy_BaseParser_relational_expression_return relational_expression(pPiggyParser ctx);
static Piggy_BaseParser_attC_return attC(pPiggyParser ctx);
static Piggy_BaseParser_exclusive_or_expression_return exclusive_or_expression(pPiggyParser ctx);
static Piggy_BaseParser_match_expression_return match_expression(pPiggyParser ctx);
static Piggy_BaseParser_ctAttList_return ctAttList(pPiggyParser ctx);
static Piggy_BaseParser_unary_expression_return unary_expression(pPiggyParser ctx);
static Piggy_BaseParser_basic_bool_expression_return basic_bool_expression(pPiggyParser ctx);
static Piggy_BaseParser_logical_or_expression_return logical_or_expression(pPiggyParser ctx);
static Piggy_BaseParser_attCElem_return attCElem(pPiggyParser ctx);
static Piggy_BaseParser_expressionList_return expressionList(pPiggyParser ctx);
static Piggy_BaseParser_additive_expression_return additive_expression(pPiggyParser ctx);
static Piggy_BaseParser_ctAtt_return ctAtt(pPiggyParser ctx);
static Piggy_BaseParser_primary_expression_return primary_expression(pPiggyParser ctx);
static Piggy_BaseParser_attWType_return attWType(pPiggyParser ctx);
static Piggy_BaseParser_synthAttribute_return synthAttribute(pPiggyParser ctx);
static Piggy_BaseParser_attributeEList_return attributeEList(pPiggyParser ctx);
static Piggy_BaseParser_constant_return constant(pPiggyParser ctx);
static Piggy_BaseParser_case_expression_return case_expression(pPiggyParser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "Piggy.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new PiggyParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pPiggyParser
PiggyParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return PiggyParserNewSSD(instream, NULL);
}

/** \brief Create a new PiggyParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pPiggyParser
PiggyParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pPiggyParser ctx;	    /* Context structure we will build and return   */
    
    ctx	= (pPiggyParser) ANTLR3_CALLOC(1, sizeof(PiggyParser));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in PiggyParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our PiggyParser interface
     */
    ctx->parse	= parse;
    ctx->statements	= statements;
    ctx->statement	= statement;
    ctx->actionBody	= actionBody;
    ctx->glaDef	= glaDef;
    ctx->glaTemplateDef	= glaTemplateDef;
    ctx->glaTemplArg	= glaTemplArg;
    ctx->constArgs	= constArgs;
    ctx->attEListAlt	= attEListAlt;
	// Install the delegated methods so that they appear to be a part of this 
	// parser
	//
    ctx->multiplicative_expression	= multiplicative_expression;
    ctx->function	= function;
    ctx->attribute	= attribute;
    ctx->inclusive_or_expression	= inclusive_or_expression;
    ctx->equality_expression	= equality_expression;
    ctx->idList	= idList;
    ctx->conditional_expression	= conditional_expression;
    ctx->attListWTypes	= attListWTypes;
    ctx->shift_expression	= shift_expression;
    ctx->attCList	= attCList;
    ctx->and_expression	= and_expression;
    ctx->expression	= expression;
    ctx->logical_and_expression	= logical_and_expression;
    ctx->attributeList	= attributeList;
    ctx->relational_expression	= relational_expression;
    ctx->attC	= attC;
    ctx->exclusive_or_expression	= exclusive_or_expression;
    ctx->match_expression	= match_expression;
    ctx->ctAttList	= ctAttList;
    ctx->unary_expression	= unary_expression;
    ctx->basic_bool_expression	= basic_bool_expression;
    ctx->logical_or_expression	= logical_or_expression;
    ctx->attCElem	= attCElem;
    ctx->expressionList	= expressionList;
    ctx->additive_expression	= additive_expression;
    ctx->ctAtt	= ctAtt;
    ctx->primary_expression	= primary_expression;
    ctx->attWType	= attWType;
    ctx->synthAttribute	= synthAttribute;
    ctx->attributeEList	= attributeEList;
    ctx->constant	= constant;
    ctx->case_expression	= case_expression;
    ctx->free			= PiggyParserFree;
    ctx->reset			= PiggyParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */
    ADAPTOR	= ANTLR3_TREE_ADAPTORNew(instream->tstream->tokenSource->strFactory);
    ctx->vectors	= antlr3VectorFactoryNew(0);
	// Initialize the parsers that we are going to delegate some
	// functions to.
	//
	ctx->gBaseParser = Piggy_BaseParserNewSSD(instream, PSRSTATE, ctx);    

	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = PiggyParserTokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
PiggyParserReset (pPiggyParser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 PiggyParserFree(pPiggyParser ctx)
 {
    /* Free any scope memory
     */
    
    ctx->vectors->close(ctx->vectors);
    /* We created the adaptor so we must free it
     */
    ADAPTOR->free(ADAPTOR);
	// Free the parsers that we delegated to
	// functions to.NULL the state so we only free it once.
	//
	ctx->gBaseParser->pParser->rec->state = NULL;
	         ctx->gBaseParser->free(ctx->gBaseParser);	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);
    
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return PiggyParserTokenNames; 
}

    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_statements_in_parse196  */
static	ANTLR3_BITWORD FOLLOW_statements_in_parse196_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_statements_in_parse196	= { FOLLOW_statements_in_parse196_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_statements237  */
static	ANTLR3_BITWORD FOLLOW_statement_in_statements237_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_statements237	= { FOLLOW_statement_in_statements237_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMICOLON_in_statements239  */
static	ANTLR3_BITWORD FOLLOW_SEMICOLON_in_statements239_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020082), ANTLR3_UINT64_LIT(0x0000000108000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMICOLON_in_statements239	= { FOLLOW_SEMICOLON_in_statements239_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_statement259  */
static	ANTLR3_BITWORD FOLLOW_ID_in_statement259_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_statement259	= { FOLLOW_ID_in_statement259_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_statement261  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_statement261_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000170), ANTLR3_UINT64_LIT(0x0000000010000000) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_statement261	= { FOLLOW_EQUAL_in_statement261_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_actionBody_in_statement263  */
static	ANTLR3_BITWORD FOLLOW_actionBody_in_statement263_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_actionBody_in_statement263	= { FOLLOW_actionBody_in_statement263_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LOAD_in_statement291  */
static	ANTLR3_BITWORD FOLLOW_LOAD_in_statement291_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_LOAD_in_statement291	= { FOLLOW_LOAD_in_statement291_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_statement295  */
static	ANTLR3_BITWORD FOLLOW_ID_in_statement295_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_statement295	= { FOLLOW_ID_in_statement295_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AS_in_statement298  */
static	ANTLR3_BITWORD FOLLOW_AS_in_statement298_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_AS_in_statement298	= { FOLLOW_AS_in_statement298_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_statement302  */
static	ANTLR3_BITWORD FOLLOW_ID_in_statement302_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_statement302	= { FOLLOW_ID_in_statement302_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PRINT_in_statement327  */
static	ANTLR3_BITWORD FOLLOW_PRINT_in_statement327_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_PRINT_in_statement327	= { FOLLOW_PRINT_in_statement327_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_statement331  */
static	ANTLR3_BITWORD FOLLOW_ID_in_statement331_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_statement331	= { FOLLOW_ID_in_statement331_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_USING_in_statement333  */
static	ANTLR3_BITWORD FOLLOW_USING_in_statement333_bits[]	= { ANTLR3_UINT64_LIT(0x000640802117C000), ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_USING_in_statement333	= { FOLLOW_USING_in_statement333_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expressionList_in_statement337  */
static	ANTLR3_BITWORD FOLLOW_expressionList_in_statement337_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expressionList_in_statement337	= { FOLLOW_expressionList_in_statement337_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AS_in_statement340  */
static	ANTLR3_BITWORD FOLLOW_AS_in_statement340_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000), ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_AS_in_statement340	= { FOLLOW_AS_in_statement340_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attListWTypes_in_statement342  */
static	ANTLR3_BITWORD FOLLOW_attListWTypes_in_statement342_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_attListWTypes_in_statement342	= { FOLLOW_attListWTypes_in_statement342_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTO_in_statement346  */
static	ANTLR3_BITWORD FOLLOW_INTO_in_statement346_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTO_in_statement346	= { FOLLOW_INTO_in_statement346_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_statement350  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_statement350_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_statement350	= { FOLLOW_STRING_in_statement350_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STORE_in_statement418  */
static	ANTLR3_BITWORD FOLLOW_STORE_in_statement418_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_STORE_in_statement418	= { FOLLOW_STORE_in_statement418_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_statement422  */
static	ANTLR3_BITWORD FOLLOW_ID_in_statement422_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_statement422	= { FOLLOW_ID_in_statement422_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTO_in_statement424  */
static	ANTLR3_BITWORD FOLLOW_INTO_in_statement424_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTO_in_statement424	= { FOLLOW_INTO_in_statement424_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_statement428  */
static	ANTLR3_BITWORD FOLLOW_ID_in_statement428_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_statement428	= { FOLLOW_ID_in_statement428_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_JOIN_in_actionBody469  */
static	ANTLR3_BITWORD FOLLOW_JOIN_in_actionBody469_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_JOIN_in_actionBody469	= { FOLLOW_JOIN_in_actionBody469_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_actionBody473  */
static	ANTLR3_BITWORD FOLLOW_ID_in_actionBody473_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_actionBody473	= { FOLLOW_ID_in_actionBody473_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BY_in_actionBody475  */
static	ANTLR3_BITWORD FOLLOW_BY_in_actionBody475_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020020000) };
static  ANTLR3_BITSET_LIST FOLLOW_BY_in_actionBody475	= { FOLLOW_BY_in_actionBody475_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attEListAlt_in_actionBody479  */
static	ANTLR3_BITWORD FOLLOW_attEListAlt_in_actionBody479_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_attEListAlt_in_actionBody479	= { FOLLOW_attEListAlt_in_actionBody479_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_actionBody481  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_actionBody481_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_actionBody481	= { FOLLOW_COMMA_in_actionBody481_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_actionBody485  */
static	ANTLR3_BITWORD FOLLOW_ID_in_actionBody485_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_actionBody485	= { FOLLOW_ID_in_actionBody485_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BY_in_actionBody487  */
static	ANTLR3_BITWORD FOLLOW_BY_in_actionBody487_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020020000) };
static  ANTLR3_BITSET_LIST FOLLOW_BY_in_actionBody487	= { FOLLOW_BY_in_actionBody487_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attEListAlt_in_actionBody491  */
static	ANTLR3_BITWORD FOLLOW_attEListAlt_in_actionBody491_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_attEListAlt_in_actionBody491	= { FOLLOW_attEListAlt_in_actionBody491_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FILTER_in_actionBody541  */
static	ANTLR3_BITWORD FOLLOW_FILTER_in_actionBody541_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_FILTER_in_actionBody541	= { FOLLOW_FILTER_in_actionBody541_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_actionBody545  */
static	ANTLR3_BITWORD FOLLOW_ID_in_actionBody545_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_actionBody545	= { FOLLOW_ID_in_actionBody545_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BY_in_actionBody547  */
static	ANTLR3_BITWORD FOLLOW_BY_in_actionBody547_bits[]	= { ANTLR3_UINT64_LIT(0x000640802117C000) };
static  ANTLR3_BITSET_LIST FOLLOW_BY_in_actionBody547	= { FOLLOW_BY_in_actionBody547_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expressionList_in_actionBody551  */
static	ANTLR3_BITWORD FOLLOW_expressionList_in_actionBody551_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expressionList_in_actionBody551	= { FOLLOW_expressionList_in_actionBody551_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GLA_in_actionBody584  */
static	ANTLR3_BITWORD FOLLOW_GLA_in_actionBody584_bits[]	= { ANTLR3_UINT64_LIT(0x0002000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_GLA_in_actionBody584	= { FOLLOW_GLA_in_actionBody584_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PLUS_in_actionBody587  */
static	ANTLR3_BITWORD FOLLOW_PLUS_in_actionBody587_bits[]	= { ANTLR3_UINT64_LIT(0x0002000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_PLUS_in_actionBody587	= { FOLLOW_PLUS_in_actionBody587_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_glaDef_in_actionBody593  */
static	ANTLR3_BITWORD FOLLOW_glaDef_in_actionBody593_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020020000), ANTLR3_UINT64_LIT(0x0000000040000000) };
static  ANTLR3_BITSET_LIST FOLLOW_glaDef_in_actionBody593	= { FOLLOW_glaDef_in_actionBody593_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constArgs_in_actionBody597  */
static	ANTLR3_BITWORD FOLLOW_constArgs_in_actionBody597_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000), ANTLR3_UINT64_LIT(0x0000000040000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constArgs_in_actionBody597	= { FOLLOW_constArgs_in_actionBody597_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FROM_in_actionBody600  */
static	ANTLR3_BITWORD FOLLOW_FROM_in_actionBody600_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_FROM_in_actionBody600	= { FOLLOW_FROM_in_actionBody600_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_actionBody605  */
static	ANTLR3_BITWORD FOLLOW_ID_in_actionBody605_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_actionBody605	= { FOLLOW_ID_in_actionBody605_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_USING_in_actionBody608  */
static	ANTLR3_BITWORD FOLLOW_USING_in_actionBody608_bits[]	= { ANTLR3_UINT64_LIT(0x000640802117C000), ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_USING_in_actionBody608	= { FOLLOW_USING_in_actionBody608_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expressionList_in_actionBody612  */
static	ANTLR3_BITWORD FOLLOW_expressionList_in_actionBody612_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expressionList_in_actionBody612	= { FOLLOW_expressionList_in_actionBody612_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AS_in_actionBody615  */
static	ANTLR3_BITWORD FOLLOW_AS_in_actionBody615_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_AS_in_actionBody615	= { FOLLOW_AS_in_actionBody615_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attListWTypes_in_actionBody619  */
static	ANTLR3_BITWORD FOLLOW_attListWTypes_in_actionBody619_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_attListWTypes_in_actionBody619	= { FOLLOW_attListWTypes_in_actionBody619_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AGGREGATE_in_actionBody673  */
static	ANTLR3_BITWORD FOLLOW_AGGREGATE_in_actionBody673_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_AGGREGATE_in_actionBody673	= { FOLLOW_AGGREGATE_in_actionBody673_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_actionBody677  */
static	ANTLR3_BITWORD FOLLOW_ID_in_actionBody677_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000), ANTLR3_UINT64_LIT(0x0000000040000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_actionBody677	= { FOLLOW_ID_in_actionBody677_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FROM_in_actionBody680  */
static	ANTLR3_BITWORD FOLLOW_FROM_in_actionBody680_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_FROM_in_actionBody680	= { FOLLOW_FROM_in_actionBody680_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_actionBody685  */
static	ANTLR3_BITWORD FOLLOW_ID_in_actionBody685_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_actionBody685	= { FOLLOW_ID_in_actionBody685_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_USING_in_actionBody688  */
static	ANTLR3_BITWORD FOLLOW_USING_in_actionBody688_bits[]	= { ANTLR3_UINT64_LIT(0x000640802117C000), ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_USING_in_actionBody688	= { FOLLOW_USING_in_actionBody688_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_actionBody692  */
static	ANTLR3_BITWORD FOLLOW_expression_in_actionBody692_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_actionBody692	= { FOLLOW_expression_in_actionBody692_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AS_in_actionBody694  */
static	ANTLR3_BITWORD FOLLOW_AS_in_actionBody694_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_AS_in_actionBody694	= { FOLLOW_AS_in_actionBody694_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_actionBody698  */
static	ANTLR3_BITWORD FOLLOW_ID_in_actionBody698_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_actionBody698	= { FOLLOW_ID_in_actionBody698_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_READ_in_actionBody737  */
static	ANTLR3_BITWORD FOLLOW_READ_in_actionBody737_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001002000) };
static  ANTLR3_BITSET_LIST FOLLOW_READ_in_actionBody737	= { FOLLOW_READ_in_actionBody737_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FILE_in_actionBody739  */
static	ANTLR3_BITWORD FOLLOW_FILE_in_actionBody739_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FILE_in_actionBody739	= { FOLLOW_FILE_in_actionBody739_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_actionBody744  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_actionBody744_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000C00) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_actionBody744	= { FOLLOW_STRING_in_actionBody744_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_actionBody747  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_actionBody747_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_actionBody747	= { FOLLOW_COLON_in_actionBody747_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INT_in_actionBody751  */
static	ANTLR3_BITWORD FOLLOW_INT_in_actionBody751_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000C00) };
static  ANTLR3_BITSET_LIST FOLLOW_INT_in_actionBody751	= { FOLLOW_INT_in_actionBody751_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEPARATOR_in_actionBody756  */
static	ANTLR3_BITWORD FOLLOW_SEPARATOR_in_actionBody756_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SEPARATOR_in_actionBody756	= { FOLLOW_SEPARATOR_in_actionBody756_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_actionBody760  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_actionBody760_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_actionBody760	= { FOLLOW_STRING_in_actionBody760_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTRIBUTES_in_actionBody764  */
static	ANTLR3_BITWORD FOLLOW_ATTRIBUTES_in_actionBody764_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000040000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTRIBUTES_in_actionBody764	= { FOLLOW_ATTRIBUTES_in_actionBody764_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FROM_in_actionBody766  */
static	ANTLR3_BITWORD FOLLOW_FROM_in_actionBody766_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_FROM_in_actionBody766	= { FOLLOW_FROM_in_actionBody766_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_actionBody770  */
static	ANTLR3_BITWORD FOLLOW_ID_in_actionBody770_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_actionBody770	= { FOLLOW_ID_in_actionBody770_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_glaDef824  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_glaDef824_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_glaDef824	= { FOLLOW_COLON_in_glaDef824_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_glaDef826  */
static	ANTLR3_BITWORD FOLLOW_ID_in_glaDef826_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_glaDef826	= { FOLLOW_ID_in_glaDef826_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_glaTemplateDef_in_glaDef830  */
static	ANTLR3_BITWORD FOLLOW_glaTemplateDef_in_glaDef830_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_glaTemplateDef_in_glaDef830	= { FOLLOW_glaTemplateDef_in_glaDef830_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LS_in_glaTemplateDef857  */
static	ANTLR3_BITWORD FOLLOW_LS_in_glaTemplateDef857_bits[]	= { ANTLR3_UINT64_LIT(0x0000000081160040) };
static  ANTLR3_BITSET_LIST FOLLOW_LS_in_glaTemplateDef857	= { FOLLOW_LS_in_glaTemplateDef857_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_glaTemplArg_in_glaTemplateDef860  */
static	ANTLR3_BITWORD FOLLOW_glaTemplArg_in_glaTemplateDef860_bits[]	= { ANTLR3_UINT64_LIT(0x0000080004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_glaTemplArg_in_glaTemplateDef860	= { FOLLOW_glaTemplArg_in_glaTemplateDef860_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_glaTemplateDef863  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_glaTemplateDef863_bits[]	= { ANTLR3_UINT64_LIT(0x0000000081160040) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_glaTemplateDef863	= { FOLLOW_COMMA_in_glaTemplateDef863_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_glaTemplArg_in_glaTemplateDef866  */
static	ANTLR3_BITWORD FOLLOW_glaTemplArg_in_glaTemplateDef866_bits[]	= { ANTLR3_UINT64_LIT(0x0000080004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_glaTemplArg_in_glaTemplateDef866	= { FOLLOW_glaTemplArg_in_glaTemplateDef866_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GT_in_glaTemplateDef870  */
static	ANTLR3_BITWORD FOLLOW_GT_in_glaTemplateDef870_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GT_in_glaTemplateDef870	= { FOLLOW_GT_in_glaTemplateDef870_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LSQ_in_glaTemplArg884  */
static	ANTLR3_BITWORD FOLLOW_LSQ_in_glaTemplArg884_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100020000) };
static  ANTLR3_BITSET_LIST FOLLOW_LSQ_in_glaTemplArg884	= { FOLLOW_LSQ_in_glaTemplArg884_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attCList_in_glaTemplArg886  */
static	ANTLR3_BITWORD FOLLOW_attCList_in_glaTemplArg886_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_attCList_in_glaTemplArg886	= { FOLLOW_attCList_in_glaTemplArg886_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RSQ_in_glaTemplArg888  */
static	ANTLR3_BITWORD FOLLOW_RSQ_in_glaTemplArg888_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RSQ_in_glaTemplArg888	= { FOLLOW_RSQ_in_glaTemplArg888_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attWType_in_glaTemplArg902  */
static	ANTLR3_BITWORD FOLLOW_attWType_in_glaTemplArg902_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_attWType_in_glaTemplArg902	= { FOLLOW_attWType_in_glaTemplArg902_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ctAtt_in_glaTemplArg910  */
static	ANTLR3_BITWORD FOLLOW_ctAtt_in_glaTemplArg910_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ctAtt_in_glaTemplArg910	= { FOLLOW_ctAtt_in_glaTemplArg910_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GLA_in_glaTemplArg916  */
static	ANTLR3_BITWORD FOLLOW_GLA_in_glaTemplArg916_bits[]	= { ANTLR3_UINT64_LIT(0x0002000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_GLA_in_glaTemplArg916	= { FOLLOW_GLA_in_glaTemplArg916_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_glaDef_in_glaTemplArg918  */
static	ANTLR3_BITWORD FOLLOW_glaDef_in_glaTemplArg918_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_glaDef_in_glaTemplArg918	= { FOLLOW_glaDef_in_glaTemplArg918_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_constArgs940  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_constArgs940_bits[]	= { ANTLR3_UINT64_LIT(0x0000000041140000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_constArgs940	= { FOLLOW_LPAREN_in_constArgs940_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ctAttList_in_constArgs943  */
static	ANTLR3_BITWORD FOLLOW_ctAttList_in_constArgs943_bits[]	= { ANTLR3_UINT64_LIT(0x0000000040000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ctAttList_in_constArgs943	= { FOLLOW_ctAttList_in_constArgs943_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_constArgs945  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_constArgs945_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_constArgs945	= { FOLLOW_RPAREN_in_constArgs945_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attribute_in_attEListAlt960  */
static	ANTLR3_BITWORD FOLLOW_attribute_in_attEListAlt960_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_attribute_in_attEListAlt960	= { FOLLOW_attribute_in_attEListAlt960_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_synthAttribute_in_attEListAlt962  */
static	ANTLR3_BITWORD FOLLOW_synthAttribute_in_attEListAlt962_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_synthAttribute_in_attEListAlt962	= { FOLLOW_synthAttribute_in_attEListAlt962_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_attEListAlt969  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_attEListAlt969_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_attEListAlt969	= { FOLLOW_LPAREN_in_attEListAlt969_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attributeEList_in_attEListAlt972  */
static	ANTLR3_BITWORD FOLLOW_attributeEList_in_attEListAlt972_bits[]	= { ANTLR3_UINT64_LIT(0x0000000040000000) };
static  ANTLR3_BITSET_LIST FOLLOW_attributeEList_in_attEListAlt972	= { FOLLOW_attributeEList_in_attEListAlt972_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_attEListAlt974  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_attEListAlt974_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_attEListAlt974	= { FOLLOW_RPAREN_in_attEListAlt974_bits, 1	};
     

 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start parse
 * Piggy.g:23:1: parse[LemonTranslator* trans] : s= statements -> ^( NEWSTATEMENT ^( QUERRY__ ID[qry.c_str()] ) ) $s ^( RUN__ ID[qry.c_str()] ) ;
 */
static PiggyParser_parse_return
parse(pPiggyParser ctx, LemonTranslator* trans)
{   
    PiggyParser_parse_return retval;

    pANTLR3_BASE_TREE root_0;

    PiggyParser_statements_return s;
    #undef	RETURN_TYPE_s
    #define	RETURN_TYPE_s PiggyParser_statements_return

    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_statements;
    /* Initialize rule variables
     */


    root_0 = NULL;

    s.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    stream_statements   = NULL;
    #define CREATE_stream_statements  if (stream_statements == NULL) {stream_statements = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule statements"); }

    retval.tree  = NULL;
    {
        // Piggy.g:23:31: (s= statements -> ^( NEWSTATEMENT ^( QUERRY__ ID[qry.c_str()] ) ) $s ^( RUN__ ID[qry.c_str()] ) )
        // Piggy.g:23:33: s= statements
        {
            {

                      // create new query
                      qry = GenerateTemp("Q%d");
                      DP_CheckQuery(true, qry);;
                    
            }
            FOLLOWPUSH(FOLLOW_statements_in_parse196);
            s=statements(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparseEx;
            }

            CREATE_stream_statements; stream_statements->add(stream_statements, s.tree, NULL);

             
            /* AST REWRITE
             * elements          : s
             * token labels      : 
             * rule labels       : retval, s
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_s;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
            	stream_s=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token s", s.tree != NULL ? s.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 28:5: -> ^( NEWSTATEMENT ^( QUERRY__ ID[qry.c_str()] ) ) $s ^( RUN__ ID[qry.c_str()] )
            	{
            	    // Piggy.g:28:8: ^( NEWSTATEMENT ^( QUERRY__ ID[qry.c_str()] ) )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, NEWSTATEMENT, (pANTLR3_UINT8)"NEWSTATEMENT"), root_1));

            	        // Piggy.g:28:23: ^( QUERRY__ ID[qry.c_str()] )
            	        {
            	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUERRY__, (pANTLR3_UINT8)"QUERRY__"), root_2));

            	            ADAPTOR->addChild(ADAPTOR, root_2, 
            	            #if 1 == 2
            	            	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, ID, TOKTEXT(qry.c_str()))
            	            #else
            	            	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ID, (pANTLR3_UINT8)qry.c_str())
            	            #endif
            	            );

            	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }
            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_s == NULL ? NULL : stream_s->nextTree(stream_s));
            	    // Piggy.g:28:56: ^( RUN__ ID[qry.c_str()] )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, RUN__, (pANTLR3_UINT8)"RUN__"), root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, 
            	        #if 1 == 2
            	        	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, ID, TOKTEXT(qry.c_str()))
            	        #else
            	        	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ID, (pANTLR3_UINT8)qry.c_str())
            	        #endif
            	        );

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);
            	if (stream_s != NULL) stream_s->free(stream_s);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleparseEx; /* Prevent compiler warnings */
    ruleparseEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_statements != NULL) stream_statements->free(stream_statements);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end parse */

/** 
 * $ANTLR start statements
 * Piggy.g:31:1: statements : ( statement SEMICOLON )+ ;
 */
static PiggyParser_statements_return
statements(pPiggyParser ctx)
{   
    PiggyParser_statements_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    SEMICOLON2;
    PiggyParser_statement_return statement1;
    #undef	RETURN_TYPE_statement1
    #define	RETURN_TYPE_statement1 PiggyParser_statement_return

    pANTLR3_BASE_TREE SEMICOLON2_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    SEMICOLON2       = NULL;
    statement1.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    SEMICOLON2_tree   = NULL;


    retval.tree  = NULL;
    {
        // Piggy.g:32:5: ( ( statement SEMICOLON )+ )
        // Piggy.g:32:6: ( statement SEMICOLON )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            // Piggy.g:32:6: ( statement SEMICOLON )+
            {
                int cnt1=0;

                for (;;)
                {
                    int alt1=2;
            	switch ( LA(1) ) 
            	{
            	case PRINT:
            	case ID:
            	case LOAD:
            	case STORE:
            		{
            			alt1=1;
            		}
            	    break;

            	}

            	switch (alt1) 
            	{
            	    case 1:
            	        // Piggy.g:32:7: statement SEMICOLON
            	        {
            	            FOLLOWPUSH(FOLLOW_statement_in_statements237);
            	            statement1=statement(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulestatementsEx;
            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_0, statement1.tree);
            	            SEMICOLON2 = (pANTLR3_COMMON_TOKEN) MATCHT(SEMICOLON, &FOLLOW_SEMICOLON_in_statements239); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulestatementsEx;
            	            }


            	        }
            	        break;

            	    default:
            	    
            		if ( cnt1 >= 1 )
            		{
            		    goto loop1;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulestatementsEx;
            	}
            	cnt1++;
                }
                loop1: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestatementsEx; /* Prevent compiler warnings */
    rulestatementsEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end statements */

/** 
 * $ANTLR start statement
 * Piggy.g:35:1: statement : (a= ID EQUAL actionBody -> ^( NEWSTATEMENT ^( WAYPOINT__ $a actionBody ) ) | LOAD a= ID ( AS b= ID )? -> ^( NEWSTATEMENT ^( SCANNER__ $a $b) ) | PRINT a= ID USING exp= expressionList ( AS attListWTypes ) ( INTO file= STRING )? -> ^( NEWSTATEMENT ^( WAYPOINT__ ID[$a, \"print\"] ^( PRINT TERMCONN $a) ^( QUERRY__ ID[$a,qry.c_str()] ^( PRINT $exp attListWTypes ( ^( LIST $file) )? ) ) ) ) | STORE a= ID INTO b= ID -> ^( NEWSTATEMENT ^( WRITER__ $b ID[$a, qry.c_str()] TERMCONN $a) ) );
 */
static PiggyParser_statement_return
statement(pPiggyParser ctx)
{   
    PiggyParser_statement_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    a;
    pANTLR3_COMMON_TOKEN    b;
    pANTLR3_COMMON_TOKEN    file;
    pANTLR3_COMMON_TOKEN    EQUAL3;
    pANTLR3_COMMON_TOKEN    LOAD5;
    pANTLR3_COMMON_TOKEN    AS6;
    pANTLR3_COMMON_TOKEN    PRINT7;
    pANTLR3_COMMON_TOKEN    USING8;
    pANTLR3_COMMON_TOKEN    AS9;
    pANTLR3_COMMON_TOKEN    INTO11;
    pANTLR3_COMMON_TOKEN    STORE12;
    pANTLR3_COMMON_TOKEN    INTO13;
    Piggy_BaseParser_expressionList_return exp;
    #undef	RETURN_TYPE_exp
    #define	RETURN_TYPE_exp Piggy_BaseParser_expressionList_return

    PiggyParser_actionBody_return actionBody4;
    #undef	RETURN_TYPE_actionBody4
    #define	RETURN_TYPE_actionBody4 PiggyParser_actionBody_return

    Piggy_BaseParser_attListWTypes_return attListWTypes10;
    #undef	RETURN_TYPE_attListWTypes10
    #define	RETURN_TYPE_attListWTypes10 Piggy_BaseParser_attListWTypes_return

    pANTLR3_BASE_TREE a_tree;
    pANTLR3_BASE_TREE b_tree;
    pANTLR3_BASE_TREE file_tree;
    pANTLR3_BASE_TREE EQUAL3_tree;
    pANTLR3_BASE_TREE LOAD5_tree;
    pANTLR3_BASE_TREE AS6_tree;
    pANTLR3_BASE_TREE PRINT7_tree;
    pANTLR3_BASE_TREE USING8_tree;
    pANTLR3_BASE_TREE AS9_tree;
    pANTLR3_BASE_TREE INTO11_tree;
    pANTLR3_BASE_TREE STORE12_tree;
    pANTLR3_BASE_TREE INTO13_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_AS;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_USING;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ID;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_PRINT;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_INTO;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_STORE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_EQUAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_STRING;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_LOAD;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_actionBody;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_attListWTypes;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_expressionList;
    /* Initialize rule variables
     */


    root_0 = NULL;

    a       = NULL;
    b       = NULL;
    file       = NULL;
    EQUAL3       = NULL;
    LOAD5       = NULL;
    AS6       = NULL;
    PRINT7       = NULL;
    USING8       = NULL;
    AS9       = NULL;
    INTO11       = NULL;
    STORE12       = NULL;
    INTO13       = NULL;
    exp.tree = NULL;
    actionBody4.tree = NULL;
    attListWTypes10.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    a_tree   = NULL;
    b_tree   = NULL;
    file_tree   = NULL;
    EQUAL3_tree   = NULL;
    LOAD5_tree   = NULL;
    AS6_tree   = NULL;
    PRINT7_tree   = NULL;
    USING8_tree   = NULL;
    AS9_tree   = NULL;
    INTO11_tree   = NULL;
    STORE12_tree   = NULL;
    INTO13_tree   = NULL;

    stream_AS   = NULL;
    #define CREATE_stream_AS  if (stream_AS == NULL) {stream_AS = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token AS"); } 
    stream_USING   = NULL;
    #define CREATE_stream_USING  if (stream_USING == NULL) {stream_USING = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token USING"); } 
    stream_ID   = NULL;
    #define CREATE_stream_ID  if (stream_ID == NULL) {stream_ID = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ID"); } 
    stream_PRINT   = NULL;
    #define CREATE_stream_PRINT  if (stream_PRINT == NULL) {stream_PRINT = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token PRINT"); } 
    stream_INTO   = NULL;
    #define CREATE_stream_INTO  if (stream_INTO == NULL) {stream_INTO = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token INTO"); } 
    stream_STORE   = NULL;
    #define CREATE_stream_STORE  if (stream_STORE == NULL) {stream_STORE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token STORE"); } 
    stream_EQUAL   = NULL;
    #define CREATE_stream_EQUAL  if (stream_EQUAL == NULL) {stream_EQUAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token EQUAL"); } 
    stream_STRING   = NULL;
    #define CREATE_stream_STRING  if (stream_STRING == NULL) {stream_STRING = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token STRING"); } 
    stream_LOAD   = NULL;
    #define CREATE_stream_LOAD  if (stream_LOAD == NULL) {stream_LOAD = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token LOAD"); } 
    stream_actionBody   = NULL;
    #define CREATE_stream_actionBody  if (stream_actionBody == NULL) {stream_actionBody = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule actionBody"); }
    stream_attListWTypes   = NULL;
    #define CREATE_stream_attListWTypes  if (stream_attListWTypes == NULL) {stream_attListWTypes = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule attListWTypes"); }
    stream_expressionList   = NULL;
    #define CREATE_stream_expressionList  if (stream_expressionList == NULL) {stream_expressionList = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule expressionList"); }

    retval.tree  = NULL;
    {
        {
            //  Piggy.g:36:3: (a= ID EQUAL actionBody -> ^( NEWSTATEMENT ^( WAYPOINT__ $a actionBody ) ) | LOAD a= ID ( AS b= ID )? -> ^( NEWSTATEMENT ^( SCANNER__ $a $b) ) | PRINT a= ID USING exp= expressionList ( AS attListWTypes ) ( INTO file= STRING )? -> ^( NEWSTATEMENT ^( WAYPOINT__ ID[$a, \"print\"] ^( PRINT TERMCONN $a) ^( QUERRY__ ID[$a,qry.c_str()] ^( PRINT $exp attListWTypes ( ^( LIST $file) )? ) ) ) ) | STORE a= ID INTO b= ID -> ^( NEWSTATEMENT ^( WRITER__ $b ID[$a, qry.c_str()] TERMCONN $a) ) )
            
            ANTLR3_UINT32 alt4;

            alt4=4;

            switch ( LA(1) ) 
            {
            case ID:
            	{
            		alt4=1;
            	}
                break;
            case LOAD:
            	{
            		alt4=2;
            	}
                break;
            case PRINT:
            	{
            		alt4=3;
            	}
                break;
            case STORE:
            	{
            		alt4=4;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 4;
                EXCEPTION->state        = 0;


                goto rulestatementEx;
            }

            switch (alt4) 
            {
        	case 1:
        	    // Piggy.g:36:5: a= ID EQUAL actionBody
        	    {
        	        a = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_statement259); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	         
        	        CREATE_stream_ID; stream_ID->add(stream_ID, a, NULL);

        	        EQUAL3 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUAL, &FOLLOW_EQUAL_in_statement261); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	         
        	        CREATE_stream_EQUAL; stream_EQUAL->add(stream_EQUAL, EQUAL3, NULL);

        	        FOLLOWPUSH(FOLLOW_actionBody_in_statement263);
        	        actionBody4=actionBody(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }

        	        CREATE_stream_actionBody; stream_actionBody->add(stream_actionBody, actionBody4.tree, NULL);

        	         
        	        /* AST REWRITE
        	         * elements          : actionBody, a
        	         * token labels      : a
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_a;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_a=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token a", a);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 36:27: -> ^( NEWSTATEMENT ^( WAYPOINT__ $a actionBody ) )
        	        	{
        	        	    // Piggy.g:36:30: ^( NEWSTATEMENT ^( WAYPOINT__ $a actionBody ) )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, NEWSTATEMENT, (pANTLR3_UINT8)"NEWSTATEMENT"), root_1));

        	        	        // Piggy.g:36:45: ^( WAYPOINT__ $a actionBody )
        	        	        {
        	        	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WAYPOINT__, (pANTLR3_UINT8)"WAYPOINT__"), root_2));

        	        	            ADAPTOR->addChild(ADAPTOR, root_2, stream_a == NULL ? NULL : stream_a->nextNode(stream_a));
        	        	            ADAPTOR->addChild(ADAPTOR, root_2, stream_actionBody == NULL ? NULL : stream_actionBody->nextTree(stream_actionBody));

        	        	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}

        	        	retval.tree = root_0; // set result root
        	        	if (stream_a != NULL) stream_a->free(stream_a); 
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 2:
        	    // Piggy.g:38:5: LOAD a= ID ( AS b= ID )?
        	    {
        	        LOAD5 = (pANTLR3_COMMON_TOKEN) MATCHT(LOAD, &FOLLOW_LOAD_in_statement291); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	         
        	        CREATE_stream_LOAD; stream_LOAD->add(stream_LOAD, LOAD5, NULL);

        	        a = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_statement295); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	         
        	        CREATE_stream_ID; stream_ID->add(stream_ID, a, NULL);


        	        // Piggy.g:38:15: ( AS b= ID )?
        	        {
        	            int alt2=2;
        	            switch ( LA(1) ) 
        	            {
        	                case AS:
        	                	{
        	                		alt2=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt2) 
        	            {
        	        	case 1:
        	        	    // Piggy.g:38:16: AS b= ID
        	        	    {
        	        	        AS6 = (pANTLR3_COMMON_TOKEN) MATCHT(AS, &FOLLOW_AS_in_statement298); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulestatementEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_AS; stream_AS->add(stream_AS, AS6, NULL);

        	        	        b = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_statement302); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulestatementEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_ID; stream_ID->add(stream_ID, b, NULL);


        	        	    }
        	        	    break;

        	            }
        	        }

        	         
        	        /* AST REWRITE
        	         * elements          : b, a
        	         * token labels      : b, a
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_b;
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_a;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_b=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token b", b);
        	        	stream_a=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token a", a);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 38:26: -> ^( NEWSTATEMENT ^( SCANNER__ $a $b) )
        	        	{
        	        	    // Piggy.g:38:29: ^( NEWSTATEMENT ^( SCANNER__ $a $b) )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, NEWSTATEMENT, (pANTLR3_UINT8)"NEWSTATEMENT"), root_1));

        	        	        // Piggy.g:38:44: ^( SCANNER__ $a $b)
        	        	        {
        	        	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, SCANNER__, (pANTLR3_UINT8)"SCANNER__"), root_2));

        	        	            ADAPTOR->addChild(ADAPTOR, root_2, stream_a == NULL ? NULL : stream_a->nextNode(stream_a));
        	        	            ADAPTOR->addChild(ADAPTOR, root_2, stream_b == NULL ? NULL : stream_b->nextNode(stream_b));

        	        	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}

        	        	retval.tree = root_0; // set result root
        	        	if (stream_b != NULL) stream_b->free(stream_b); 
        	        	if (stream_a != NULL) stream_a->free(stream_a); 
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 3:
        	    // Piggy.g:39:5: PRINT a= ID USING exp= expressionList ( AS attListWTypes ) ( INTO file= STRING )?
        	    {
        	        PRINT7 = (pANTLR3_COMMON_TOKEN) MATCHT(PRINT, &FOLLOW_PRINT_in_statement327); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	         
        	        CREATE_stream_PRINT; stream_PRINT->add(stream_PRINT, PRINT7, NULL);

        	        a = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_statement331); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	         
        	        CREATE_stream_ID; stream_ID->add(stream_ID, a, NULL);

        	        USING8 = (pANTLR3_COMMON_TOKEN) MATCHT(USING, &FOLLOW_USING_in_statement333); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	         
        	        CREATE_stream_USING; stream_USING->add(stream_USING, USING8, NULL);

        	        FOLLOWPUSH(FOLLOW_expressionList_in_statement337);
        	        exp=expressionList(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }

        	        CREATE_stream_expressionList; stream_expressionList->add(stream_expressionList, exp.tree, NULL);
        	        // Piggy.g:39:41: ( AS attListWTypes )
        	        // Piggy.g:39:42: AS attListWTypes
        	        {
        	            AS9 = (pANTLR3_COMMON_TOKEN) MATCHT(AS, &FOLLOW_AS_in_statement340); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulestatementEx;
        	            }
        	             
        	            CREATE_stream_AS; stream_AS->add(stream_AS, AS9, NULL);

        	            FOLLOWPUSH(FOLLOW_attListWTypes_in_statement342);
        	            attListWTypes10=attListWTypes(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulestatementEx;
        	            }

        	            CREATE_stream_attListWTypes; stream_attListWTypes->add(stream_attListWTypes, attListWTypes10.tree, NULL);

        	        }


        	        // Piggy.g:39:60: ( INTO file= STRING )?
        	        {
        	            int alt3=2;
        	            switch ( LA(1) ) 
        	            {
        	                case INTO:
        	                	{
        	                		alt3=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt3) 
        	            {
        	        	case 1:
        	        	    // Piggy.g:39:61: INTO file= STRING
        	        	    {
        	        	        INTO11 = (pANTLR3_COMMON_TOKEN) MATCHT(INTO, &FOLLOW_INTO_in_statement346); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulestatementEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_INTO; stream_INTO->add(stream_INTO, INTO11, NULL);

        	        	        file = (pANTLR3_COMMON_TOKEN) MATCHT(STRING, &FOLLOW_STRING_in_statement350); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulestatementEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_STRING; stream_STRING->add(stream_STRING, file, NULL);


        	        	    }
        	        	    break;

        	            }
        	        }

        	         
        	        /* AST REWRITE
        	         * elements          : ID, ID, a, exp, file, PRINT, PRINT, attListWTypes
        	         * token labels      : file, a
        	         * rule labels       : exp, retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_file;
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_a;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_exp;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_file=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token file", file);
        	        	stream_a=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token a", a);
        	        	stream_exp=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token exp", exp.tree != NULL ? exp.tree : NULL);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 40:5: -> ^( NEWSTATEMENT ^( WAYPOINT__ ID[$a, \"print\"] ^( PRINT TERMCONN $a) ^( QUERRY__ ID[$a,qry.c_str()] ^( PRINT $exp attListWTypes ( ^( LIST $file) )? ) ) ) )
        	        	{
        	        	    // Piggy.g:40:8: ^( NEWSTATEMENT ^( WAYPOINT__ ID[$a, \"print\"] ^( PRINT TERMCONN $a) ^( QUERRY__ ID[$a,qry.c_str()] ^( PRINT $exp attListWTypes ( ^( LIST $file) )? ) ) ) )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, NEWSTATEMENT, (pANTLR3_UINT8)"NEWSTATEMENT"), root_1));

        	        	        // Piggy.g:40:23: ^( WAYPOINT__ ID[$a, \"print\"] ^( PRINT TERMCONN $a) ^( QUERRY__ ID[$a,qry.c_str()] ^( PRINT $exp attListWTypes ( ^( LIST $file) )? ) ) )
        	        	        {
        	        	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WAYPOINT__, (pANTLR3_UINT8)"WAYPOINT__"), root_2));

        	        	            ADAPTOR->addChild(ADAPTOR, root_2, 
        	        	            #if 2 == 2
        	        	            	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, ID, TOKTEXT(a, "print"))
        	        	            #else
        	        	            	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ID, (pANTLR3_UINT8)a, "print")
        	        	            #endif
        	        	            );
        	        	            // Piggy.g:40:52: ^( PRINT TERMCONN $a)
        	        	            {
        	        	                pANTLR3_BASE_TREE root_3 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	                root_3 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_PRINT == NULL ? NULL : stream_PRINT->nextNode(stream_PRINT), root_3));

        	        	                ADAPTOR->addChild(ADAPTOR, root_3, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TERMCONN, (pANTLR3_UINT8)"TERMCONN"));
        	        	                ADAPTOR->addChild(ADAPTOR, root_3, stream_a == NULL ? NULL : stream_a->nextNode(stream_a));

        	        	                ADAPTOR->addChild(ADAPTOR, root_2, root_3);
        	        	            }
        	        	            // Piggy.g:41:9: ^( QUERRY__ ID[$a,qry.c_str()] ^( PRINT $exp attListWTypes ( ^( LIST $file) )? ) )
        	        	            {
        	        	                pANTLR3_BASE_TREE root_3 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	                root_3 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUERRY__, (pANTLR3_UINT8)"QUERRY__"), root_3));

        	        	                ADAPTOR->addChild(ADAPTOR, root_3, 
        	        	                #if 2 == 2
        	        	                	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, ID, TOKTEXT(a, qry.c_str()))
        	        	                #else
        	        	                	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ID, (pANTLR3_UINT8)a, qry.c_str())
        	        	                #endif
        	        	                );
        	        	                // Piggy.g:41:39: ^( PRINT $exp attListWTypes ( ^( LIST $file) )? )
        	        	                {
        	        	                    pANTLR3_BASE_TREE root_4 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	                    root_4 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_PRINT == NULL ? NULL : stream_PRINT->nextNode(stream_PRINT), root_4));

        	        	                    ADAPTOR->addChild(ADAPTOR, root_4, stream_exp == NULL ? NULL : stream_exp->nextTree(stream_exp));
        	        	                    ADAPTOR->addChild(ADAPTOR, root_4, stream_attListWTypes == NULL ? NULL : stream_attListWTypes->nextTree(stream_attListWTypes));
        	        	                    // Piggy.g:41:66: ( ^( LIST $file) )?
        	        	                    {
        	        	                    	if ( (stream_file != NULL && stream_file->hasNext(stream_file))  )
        	        	                    	{
        	        	                    		// Piggy.g:41:66: ^( LIST $file)
        	        	                    		{
        	        	                    		    pANTLR3_BASE_TREE root_5 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	                    		    root_5 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, LIST, (pANTLR3_UINT8)"LIST"), root_5));

        	        	                    		    ADAPTOR->addChild(ADAPTOR, root_5, stream_file == NULL ? NULL : stream_file->nextNode(stream_file));

        	        	                    		    ADAPTOR->addChild(ADAPTOR, root_4, root_5);
        	        	                    		}

        	        	                    	}
        	        	                    	if ( stream_file != NULL) stream_file->reset(stream_file);

        	        	                    }

        	        	                    ADAPTOR->addChild(ADAPTOR, root_3, root_4);
        	        	                }

        	        	                ADAPTOR->addChild(ADAPTOR, root_2, root_3);
        	        	            }

        	        	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}

        	        	retval.tree = root_0; // set result root
        	        	if (stream_file != NULL) stream_file->free(stream_file); 
        	        	if (stream_a != NULL) stream_a->free(stream_a); 
        	        	if (stream_exp != NULL) stream_exp->free(stream_exp);
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 4:
        	    // Piggy.g:42:5: STORE a= ID INTO b= ID
        	    {
        	        STORE12 = (pANTLR3_COMMON_TOKEN) MATCHT(STORE, &FOLLOW_STORE_in_statement418); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	         
        	        CREATE_stream_STORE; stream_STORE->add(stream_STORE, STORE12, NULL);

        	        a = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_statement422); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	         
        	        CREATE_stream_ID; stream_ID->add(stream_ID, a, NULL);

        	        INTO13 = (pANTLR3_COMMON_TOKEN) MATCHT(INTO, &FOLLOW_INTO_in_statement424); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	         
        	        CREATE_stream_INTO; stream_INTO->add(stream_INTO, INTO13, NULL);

        	        b = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_statement428); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	         
        	        CREATE_stream_ID; stream_ID->add(stream_ID, b, NULL);


        	         
        	        /* AST REWRITE
        	         * elements          : ID, a, b
        	         * token labels      : b, a
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_b;
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_a;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_b=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token b", b);
        	        	stream_a=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token a", a);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 43:5: -> ^( NEWSTATEMENT ^( WRITER__ $b ID[$a, qry.c_str()] TERMCONN $a) )
        	        	{
        	        	    // Piggy.g:43:8: ^( NEWSTATEMENT ^( WRITER__ $b ID[$a, qry.c_str()] TERMCONN $a) )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, NEWSTATEMENT, (pANTLR3_UINT8)"NEWSTATEMENT"), root_1));

        	        	        // Piggy.g:43:23: ^( WRITER__ $b ID[$a, qry.c_str()] TERMCONN $a)
        	        	        {
        	        	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WRITER__, (pANTLR3_UINT8)"WRITER__"), root_2));

        	        	            ADAPTOR->addChild(ADAPTOR, root_2, stream_b == NULL ? NULL : stream_b->nextNode(stream_b));
        	        	            ADAPTOR->addChild(ADAPTOR, root_2, 
        	        	            #if 2 == 2
        	        	            	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, ID, TOKTEXT(a, qry.c_str()))
        	        	            #else
        	        	            	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ID, (pANTLR3_UINT8)a, qry.c_str())
        	        	            #endif
        	        	            );
        	        	            ADAPTOR->addChild(ADAPTOR, root_2, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TERMCONN, (pANTLR3_UINT8)"TERMCONN"));
        	        	            ADAPTOR->addChild(ADAPTOR, root_2, stream_a == NULL ? NULL : stream_a->nextNode(stream_a));

        	        	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}

        	        	retval.tree = root_0; // set result root
        	        	if (stream_b != NULL) stream_b->free(stream_b); 
        	        	if (stream_a != NULL) stream_a->free(stream_a); 
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_AS != NULL) stream_AS->free(stream_AS);
        if (stream_USING != NULL) stream_USING->free(stream_USING);
        if (stream_ID != NULL) stream_ID->free(stream_ID);
        if (stream_PRINT != NULL) stream_PRINT->free(stream_PRINT);
        if (stream_INTO != NULL) stream_INTO->free(stream_INTO);
        if (stream_STORE != NULL) stream_STORE->free(stream_STORE);
        if (stream_EQUAL != NULL) stream_EQUAL->free(stream_EQUAL);
        if (stream_STRING != NULL) stream_STRING->free(stream_STRING);
        if (stream_LOAD != NULL) stream_LOAD->free(stream_LOAD);
        if (stream_actionBody != NULL) stream_actionBody->free(stream_actionBody);
        if (stream_attListWTypes != NULL) stream_attListWTypes->free(stream_attListWTypes);
        if (stream_expressionList != NULL) stream_expressionList->free(stream_expressionList);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end statement */

/** 
 * $ANTLR start actionBody
 * Piggy.g:48:1: actionBody : ( JOIN r1= ID BY l1= attEListAlt COMMA r2= ID BY l2= attEListAlt -> ^( JOIN ^( ATTS $l1) $r1 TERMCONN $r2) ^( QUERRY__ ID[$r1,qry.c_str()] ^( JOIN ^( ATTS $l2) ) ) | FILTER a= ID BY exp= expressionList -> ^( SELECT__ $a) ^( QUERRY__ ID[$a,qry.c_str()] ^( FILTER $exp) ) | GLA ( PLUS )? gla= glaDef ct= constArgs ( ( FROM )? inp= ID ) USING exp= expressionList ( AS rez= attListWTypes )? -> ^( GLA ( PLUS )? $inp) ^( QUERRY__ ID[$inp,qry.c_str()] ^( GLA ( PLUS )? $ct $gla $rez $exp) ) | AGGREGATE type= ID ( ( FROM )? inp= ID ) USING expr= expression AS name= ID -> ^( AGGREGATE $inp) ^( QUERRY__ ID[$inp,qry.c_str()] ^( AGGREGATE $name $type $expr) ) | READ ( FILE )? f= STRING ( COLON b= INT )? ( SEPARATOR s= STRING )? ATTRIBUTES FROM c= ID -> ^( TEXTLOADER__ ^( ATTFROM $c) ( ^( SEPARATOR $s) )? ^( FILE__ $f $b) ) );
 */
static PiggyParser_actionBody_return
actionBody(pPiggyParser ctx)
{   
    PiggyParser_actionBody_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    r1;
    pANTLR3_COMMON_TOKEN    r2;
    pANTLR3_COMMON_TOKEN    a;
    pANTLR3_COMMON_TOKEN    inp;
    pANTLR3_COMMON_TOKEN    type;
    pANTLR3_COMMON_TOKEN    name;
    pANTLR3_COMMON_TOKEN    f;
    pANTLR3_COMMON_TOKEN    b;
    pANTLR3_COMMON_TOKEN    s;
    pANTLR3_COMMON_TOKEN    c;
    pANTLR3_COMMON_TOKEN    JOIN14;
    pANTLR3_COMMON_TOKEN    BY15;
    pANTLR3_COMMON_TOKEN    COMMA16;
    pANTLR3_COMMON_TOKEN    BY17;
    pANTLR3_COMMON_TOKEN    FILTER18;
    pANTLR3_COMMON_TOKEN    BY19;
    pANTLR3_COMMON_TOKEN    GLA20;
    pANTLR3_COMMON_TOKEN    PLUS21;
    pANTLR3_COMMON_TOKEN    FROM22;
    pANTLR3_COMMON_TOKEN    USING23;
    pANTLR3_COMMON_TOKEN    AS24;
    pANTLR3_COMMON_TOKEN    AGGREGATE25;
    pANTLR3_COMMON_TOKEN    FROM26;
    pANTLR3_COMMON_TOKEN    USING27;
    pANTLR3_COMMON_TOKEN    AS28;
    pANTLR3_COMMON_TOKEN    READ29;
    pANTLR3_COMMON_TOKEN    FILE30;
    pANTLR3_COMMON_TOKEN    COLON31;
    pANTLR3_COMMON_TOKEN    SEPARATOR32;
    pANTLR3_COMMON_TOKEN    ATTRIBUTES33;
    pANTLR3_COMMON_TOKEN    FROM34;
    PiggyParser_attEListAlt_return l1;
    #undef	RETURN_TYPE_l1
    #define	RETURN_TYPE_l1 PiggyParser_attEListAlt_return

    PiggyParser_attEListAlt_return l2;
    #undef	RETURN_TYPE_l2
    #define	RETURN_TYPE_l2 PiggyParser_attEListAlt_return

    Piggy_BaseParser_expressionList_return exp;
    #undef	RETURN_TYPE_exp
    #define	RETURN_TYPE_exp Piggy_BaseParser_expressionList_return

    PiggyParser_glaDef_return gla;
    #undef	RETURN_TYPE_gla
    #define	RETURN_TYPE_gla PiggyParser_glaDef_return

    PiggyParser_constArgs_return ct;
    #undef	RETURN_TYPE_ct
    #define	RETURN_TYPE_ct PiggyParser_constArgs_return

    Piggy_BaseParser_attListWTypes_return rez;
    #undef	RETURN_TYPE_rez
    #define	RETURN_TYPE_rez Piggy_BaseParser_attListWTypes_return

    Piggy_BaseParser_expression_return expr;
    #undef	RETURN_TYPE_expr
    #define	RETURN_TYPE_expr Piggy_BaseParser_expression_return

    pANTLR3_BASE_TREE r1_tree;
    pANTLR3_BASE_TREE r2_tree;
    pANTLR3_BASE_TREE a_tree;
    pANTLR3_BASE_TREE inp_tree;
    pANTLR3_BASE_TREE type_tree;
    pANTLR3_BASE_TREE name_tree;
    pANTLR3_BASE_TREE f_tree;
    pANTLR3_BASE_TREE b_tree;
    pANTLR3_BASE_TREE s_tree;
    pANTLR3_BASE_TREE c_tree;
    pANTLR3_BASE_TREE JOIN14_tree;
    pANTLR3_BASE_TREE BY15_tree;
    pANTLR3_BASE_TREE COMMA16_tree;
    pANTLR3_BASE_TREE BY17_tree;
    pANTLR3_BASE_TREE FILTER18_tree;
    pANTLR3_BASE_TREE BY19_tree;
    pANTLR3_BASE_TREE GLA20_tree;
    pANTLR3_BASE_TREE PLUS21_tree;
    pANTLR3_BASE_TREE FROM22_tree;
    pANTLR3_BASE_TREE USING23_tree;
    pANTLR3_BASE_TREE AS24_tree;
    pANTLR3_BASE_TREE AGGREGATE25_tree;
    pANTLR3_BASE_TREE FROM26_tree;
    pANTLR3_BASE_TREE USING27_tree;
    pANTLR3_BASE_TREE AS28_tree;
    pANTLR3_BASE_TREE READ29_tree;
    pANTLR3_BASE_TREE FILE30_tree;
    pANTLR3_BASE_TREE COLON31_tree;
    pANTLR3_BASE_TREE SEPARATOR32_tree;
    pANTLR3_BASE_TREE ATTRIBUTES33_tree;
    pANTLR3_BASE_TREE FROM34_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_COLON;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_AS;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_BY;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ATTRIBUTES;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_USING;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_READ;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_COMMA;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_FILTER;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_PLUS;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_GLA;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_INT;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_SEPARATOR;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ID;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_FROM;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_FILE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_JOIN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_AGGREGATE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_STRING;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_expression;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_attEListAlt;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_glaDef;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_constArgs;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_attListWTypes;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_expressionList;
    /* Initialize rule variables
     */


    root_0 = NULL;

    r1       = NULL;
    r2       = NULL;
    a       = NULL;
    inp       = NULL;
    type       = NULL;
    name       = NULL;
    f       = NULL;
    b       = NULL;
    s       = NULL;
    c       = NULL;
    JOIN14       = NULL;
    BY15       = NULL;
    COMMA16       = NULL;
    BY17       = NULL;
    FILTER18       = NULL;
    BY19       = NULL;
    GLA20       = NULL;
    PLUS21       = NULL;
    FROM22       = NULL;
    USING23       = NULL;
    AS24       = NULL;
    AGGREGATE25       = NULL;
    FROM26       = NULL;
    USING27       = NULL;
    AS28       = NULL;
    READ29       = NULL;
    FILE30       = NULL;
    COLON31       = NULL;
    SEPARATOR32       = NULL;
    ATTRIBUTES33       = NULL;
    FROM34       = NULL;
    l1.tree = NULL;
    l2.tree = NULL;
    exp.tree = NULL;
    gla.tree = NULL;
    ct.tree = NULL;
    rez.tree = NULL;
    expr.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    r1_tree   = NULL;
    r2_tree   = NULL;
    a_tree   = NULL;
    inp_tree   = NULL;
    type_tree   = NULL;
    name_tree   = NULL;
    f_tree   = NULL;
    b_tree   = NULL;
    s_tree   = NULL;
    c_tree   = NULL;
    JOIN14_tree   = NULL;
    BY15_tree   = NULL;
    COMMA16_tree   = NULL;
    BY17_tree   = NULL;
    FILTER18_tree   = NULL;
    BY19_tree   = NULL;
    GLA20_tree   = NULL;
    PLUS21_tree   = NULL;
    FROM22_tree   = NULL;
    USING23_tree   = NULL;
    AS24_tree   = NULL;
    AGGREGATE25_tree   = NULL;
    FROM26_tree   = NULL;
    USING27_tree   = NULL;
    AS28_tree   = NULL;
    READ29_tree   = NULL;
    FILE30_tree   = NULL;
    COLON31_tree   = NULL;
    SEPARATOR32_tree   = NULL;
    ATTRIBUTES33_tree   = NULL;
    FROM34_tree   = NULL;

    stream_COLON   = NULL;
    #define CREATE_stream_COLON  if (stream_COLON == NULL) {stream_COLON = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token COLON"); } 
    stream_AS   = NULL;
    #define CREATE_stream_AS  if (stream_AS == NULL) {stream_AS = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token AS"); } 
    stream_BY   = NULL;
    #define CREATE_stream_BY  if (stream_BY == NULL) {stream_BY = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token BY"); } 
    stream_ATTRIBUTES   = NULL;
    #define CREATE_stream_ATTRIBUTES  if (stream_ATTRIBUTES == NULL) {stream_ATTRIBUTES = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ATTRIBUTES"); } 
    stream_USING   = NULL;
    #define CREATE_stream_USING  if (stream_USING == NULL) {stream_USING = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token USING"); } 
    stream_READ   = NULL;
    #define CREATE_stream_READ  if (stream_READ == NULL) {stream_READ = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token READ"); } 
    stream_COMMA   = NULL;
    #define CREATE_stream_COMMA  if (stream_COMMA == NULL) {stream_COMMA = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token COMMA"); } 
    stream_FILTER   = NULL;
    #define CREATE_stream_FILTER  if (stream_FILTER == NULL) {stream_FILTER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token FILTER"); } 
    stream_PLUS   = NULL;
    #define CREATE_stream_PLUS  if (stream_PLUS == NULL) {stream_PLUS = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token PLUS"); } 
    stream_GLA   = NULL;
    #define CREATE_stream_GLA  if (stream_GLA == NULL) {stream_GLA = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token GLA"); } 
    stream_INT   = NULL;
    #define CREATE_stream_INT  if (stream_INT == NULL) {stream_INT = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token INT"); } 
    stream_SEPARATOR   = NULL;
    #define CREATE_stream_SEPARATOR  if (stream_SEPARATOR == NULL) {stream_SEPARATOR = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token SEPARATOR"); } 
    stream_ID   = NULL;
    #define CREATE_stream_ID  if (stream_ID == NULL) {stream_ID = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ID"); } 
    stream_FROM   = NULL;
    #define CREATE_stream_FROM  if (stream_FROM == NULL) {stream_FROM = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token FROM"); } 
    stream_FILE   = NULL;
    #define CREATE_stream_FILE  if (stream_FILE == NULL) {stream_FILE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token FILE"); } 
    stream_JOIN   = NULL;
    #define CREATE_stream_JOIN  if (stream_JOIN == NULL) {stream_JOIN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token JOIN"); } 
    stream_AGGREGATE   = NULL;
    #define CREATE_stream_AGGREGATE  if (stream_AGGREGATE == NULL) {stream_AGGREGATE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token AGGREGATE"); } 
    stream_STRING   = NULL;
    #define CREATE_stream_STRING  if (stream_STRING == NULL) {stream_STRING = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token STRING"); } 
    stream_expression   = NULL;
    #define CREATE_stream_expression  if (stream_expression == NULL) {stream_expression = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule expression"); }
    stream_attEListAlt   = NULL;
    #define CREATE_stream_attEListAlt  if (stream_attEListAlt == NULL) {stream_attEListAlt = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule attEListAlt"); }
    stream_glaDef   = NULL;
    #define CREATE_stream_glaDef  if (stream_glaDef == NULL) {stream_glaDef = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule glaDef"); }
    stream_constArgs   = NULL;
    #define CREATE_stream_constArgs  if (stream_constArgs == NULL) {stream_constArgs = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule constArgs"); }
    stream_attListWTypes   = NULL;
    #define CREATE_stream_attListWTypes  if (stream_attListWTypes == NULL) {stream_attListWTypes = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule attListWTypes"); }
    stream_expressionList   = NULL;
    #define CREATE_stream_expressionList  if (stream_expressionList == NULL) {stream_expressionList = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule expressionList"); }

    retval.tree  = NULL;
    {
        {
            //  Piggy.g:49:3: ( JOIN r1= ID BY l1= attEListAlt COMMA r2= ID BY l2= attEListAlt -> ^( JOIN ^( ATTS $l1) $r1 TERMCONN $r2) ^( QUERRY__ ID[$r1,qry.c_str()] ^( JOIN ^( ATTS $l2) ) ) | FILTER a= ID BY exp= expressionList -> ^( SELECT__ $a) ^( QUERRY__ ID[$a,qry.c_str()] ^( FILTER $exp) ) | GLA ( PLUS )? gla= glaDef ct= constArgs ( ( FROM )? inp= ID ) USING exp= expressionList ( AS rez= attListWTypes )? -> ^( GLA ( PLUS )? $inp) ^( QUERRY__ ID[$inp,qry.c_str()] ^( GLA ( PLUS )? $ct $gla $rez $exp) ) | AGGREGATE type= ID ( ( FROM )? inp= ID ) USING expr= expression AS name= ID -> ^( AGGREGATE $inp) ^( QUERRY__ ID[$inp,qry.c_str()] ^( AGGREGATE $name $type $expr) ) | READ ( FILE )? f= STRING ( COLON b= INT )? ( SEPARATOR s= STRING )? ATTRIBUTES FROM c= ID -> ^( TEXTLOADER__ ^( ATTFROM $c) ( ^( SEPARATOR $s) )? ^( FILE__ $f $b) ) )
            
            ANTLR3_UINT32 alt12;

            alt12=5;

            switch ( LA(1) ) 
            {
            case JOIN:
            	{
            		alt12=1;
            	}
                break;
            case FILTER:
            	{
            		alt12=2;
            	}
                break;
            case GLA:
            	{
            		alt12=3;
            	}
                break;
            case AGGREGATE:
            	{
            		alt12=4;
            	}
                break;
            case READ:
            	{
            		alt12=5;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 12;
                EXCEPTION->state        = 0;


                goto ruleactionBodyEx;
            }

            switch (alt12) 
            {
        	case 1:
        	    // Piggy.g:49:5: JOIN r1= ID BY l1= attEListAlt COMMA r2= ID BY l2= attEListAlt
        	    {
        	        JOIN14 = (pANTLR3_COMMON_TOKEN) MATCHT(JOIN, &FOLLOW_JOIN_in_actionBody469); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }
        	         
        	        CREATE_stream_JOIN; stream_JOIN->add(stream_JOIN, JOIN14, NULL);

        	        r1 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_actionBody473); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }
        	         
        	        CREATE_stream_ID; stream_ID->add(stream_ID, r1, NULL);

        	        BY15 = (pANTLR3_COMMON_TOKEN) MATCHT(BY, &FOLLOW_BY_in_actionBody475); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }
        	         
        	        CREATE_stream_BY; stream_BY->add(stream_BY, BY15, NULL);

        	        FOLLOWPUSH(FOLLOW_attEListAlt_in_actionBody479);
        	        l1=attEListAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }

        	        CREATE_stream_attEListAlt; stream_attEListAlt->add(stream_attEListAlt, l1.tree, NULL);
        	        COMMA16 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_actionBody481); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }
        	         
        	        CREATE_stream_COMMA; stream_COMMA->add(stream_COMMA, COMMA16, NULL);

        	        r2 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_actionBody485); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }
        	         
        	        CREATE_stream_ID; stream_ID->add(stream_ID, r2, NULL);

        	        BY17 = (pANTLR3_COMMON_TOKEN) MATCHT(BY, &FOLLOW_BY_in_actionBody487); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }
        	         
        	        CREATE_stream_BY; stream_BY->add(stream_BY, BY17, NULL);

        	        FOLLOWPUSH(FOLLOW_attEListAlt_in_actionBody491);
        	        l2=attEListAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }

        	        CREATE_stream_attEListAlt; stream_attEListAlt->add(stream_attEListAlt, l2.tree, NULL);

        	         
        	        /* AST REWRITE
        	         * elements          : r1, ID, l2, l1, JOIN, JOIN, r2
        	         * token labels      : r1, r2
        	         * rule labels       : retval, l2, l1
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_r1;
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_r2;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_l2;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_l1;

        	        	stream_r1=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token r1", r1);
        	        	stream_r2=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token r2", r2);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
        	        	stream_l2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token l2", l2.tree != NULL ? l2.tree : NULL);
        	        	stream_l1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token l1", l1.tree != NULL ? l1.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 50:5: -> ^( JOIN ^( ATTS $l1) $r1 TERMCONN $r2) ^( QUERRY__ ID[$r1,qry.c_str()] ^( JOIN ^( ATTS $l2) ) )
        	        	{
        	        	    // Piggy.g:50:9: ^( JOIN ^( ATTS $l1) $r1 TERMCONN $r2)
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_JOIN == NULL ? NULL : stream_JOIN->nextNode(stream_JOIN), root_1));

        	        	        // Piggy.g:50:16: ^( ATTS $l1)
        	        	        {
        	        	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ATTS, (pANTLR3_UINT8)"ATTS"), root_2));

        	        	            ADAPTOR->addChild(ADAPTOR, root_2, stream_l1 == NULL ? NULL : stream_l1->nextTree(stream_l1));

        	        	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
        	        	        }
        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_r1 == NULL ? NULL : stream_r1->nextNode(stream_r1));
        	        	        ADAPTOR->addChild(ADAPTOR, root_1, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TERMCONN, (pANTLR3_UINT8)"TERMCONN"));
        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_r2 == NULL ? NULL : stream_r2->nextNode(stream_r2));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }
        	        	    // Piggy.g:50:46: ^( QUERRY__ ID[$r1,qry.c_str()] ^( JOIN ^( ATTS $l2) ) )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUERRY__, (pANTLR3_UINT8)"QUERRY__"), root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, 
        	        	        #if 2 == 2
        	        	        	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, ID, TOKTEXT(r1, qry.c_str()))
        	        	        #else
        	        	        	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ID, (pANTLR3_UINT8)r1, qry.c_str())
        	        	        #endif
        	        	        );
        	        	        // Piggy.g:50:77: ^( JOIN ^( ATTS $l2) )
        	        	        {
        	        	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_JOIN == NULL ? NULL : stream_JOIN->nextNode(stream_JOIN), root_2));

        	        	            // Piggy.g:50:84: ^( ATTS $l2)
        	        	            {
        	        	                pANTLR3_BASE_TREE root_3 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	                root_3 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ATTS, (pANTLR3_UINT8)"ATTS"), root_3));

        	        	                ADAPTOR->addChild(ADAPTOR, root_3, stream_l2 == NULL ? NULL : stream_l2->nextTree(stream_l2));

        	        	                ADAPTOR->addChild(ADAPTOR, root_2, root_3);
        	        	            }

        	        	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}

        	        	retval.tree = root_0; // set result root
        	        	if (stream_r1 != NULL) stream_r1->free(stream_r1); 
        	        	if (stream_r2 != NULL) stream_r2->free(stream_r2); 
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);
        	        	if (stream_l2 != NULL) stream_l2->free(stream_l2);
        	        	if (stream_l1 != NULL) stream_l1->free(stream_l1);


        	        }
        	    }
        	    break;
        	case 2:
        	    // Piggy.g:51:5: FILTER a= ID BY exp= expressionList
        	    {
        	        FILTER18 = (pANTLR3_COMMON_TOKEN) MATCHT(FILTER, &FOLLOW_FILTER_in_actionBody541); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }
        	         
        	        CREATE_stream_FILTER; stream_FILTER->add(stream_FILTER, FILTER18, NULL);

        	        a = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_actionBody545); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }
        	         
        	        CREATE_stream_ID; stream_ID->add(stream_ID, a, NULL);

        	        BY19 = (pANTLR3_COMMON_TOKEN) MATCHT(BY, &FOLLOW_BY_in_actionBody547); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }
        	         
        	        CREATE_stream_BY; stream_BY->add(stream_BY, BY19, NULL);

        	        FOLLOWPUSH(FOLLOW_expressionList_in_actionBody551);
        	        exp=expressionList(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }

        	        CREATE_stream_expressionList; stream_expressionList->add(stream_expressionList, exp.tree, NULL);

        	         
        	        /* AST REWRITE
        	         * elements          : exp, ID, FILTER, a
        	         * token labels      : a
        	         * rule labels       : exp, retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_a;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_exp;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_a=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token a", a);
        	        	stream_exp=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token exp", exp.tree != NULL ? exp.tree : NULL);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 52:5: -> ^( SELECT__ $a) ^( QUERRY__ ID[$a,qry.c_str()] ^( FILTER $exp) )
        	        	{
        	        	    // Piggy.g:52:8: ^( SELECT__ $a)
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, SELECT__, (pANTLR3_UINT8)"SELECT__"), root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_a == NULL ? NULL : stream_a->nextNode(stream_a));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }
        	        	    // Piggy.g:52:23: ^( QUERRY__ ID[$a,qry.c_str()] ^( FILTER $exp) )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUERRY__, (pANTLR3_UINT8)"QUERRY__"), root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, 
        	        	        #if 2 == 2
        	        	        	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, ID, TOKTEXT(a, qry.c_str()))
        	        	        #else
        	        	        	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ID, (pANTLR3_UINT8)a, qry.c_str())
        	        	        #endif
        	        	        );
        	        	        // Piggy.g:52:53: ^( FILTER $exp)
        	        	        {
        	        	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_FILTER == NULL ? NULL : stream_FILTER->nextNode(stream_FILTER), root_2));

        	        	            ADAPTOR->addChild(ADAPTOR, root_2, stream_exp == NULL ? NULL : stream_exp->nextTree(stream_exp));

        	        	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}

        	        	retval.tree = root_0; // set result root
        	        	if (stream_a != NULL) stream_a->free(stream_a); 
        	        	if (stream_exp != NULL) stream_exp->free(stream_exp);
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 3:
        	    // Piggy.g:53:5: GLA ( PLUS )? gla= glaDef ct= constArgs ( ( FROM )? inp= ID ) USING exp= expressionList ( AS rez= attListWTypes )?
        	    {
        	        GLA20 = (pANTLR3_COMMON_TOKEN) MATCHT(GLA, &FOLLOW_GLA_in_actionBody584); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }
        	         
        	        CREATE_stream_GLA; stream_GLA->add(stream_GLA, GLA20, NULL);


        	        // Piggy.g:53:9: ( PLUS )?
        	        {
        	            int alt5=2;
        	            switch ( LA(1) ) 
        	            {
        	                case PLUS:
        	                	{
        	                		alt5=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt5) 
        	            {
        	        	case 1:
        	        	    // Piggy.g:53:10: PLUS
        	        	    {
        	        	        PLUS21 = (pANTLR3_COMMON_TOKEN) MATCHT(PLUS, &FOLLOW_PLUS_in_actionBody587); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleactionBodyEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_PLUS; stream_PLUS->add(stream_PLUS, PLUS21, NULL);


        	        	    }
        	        	    break;

        	            }
        	        }
        	        FOLLOWPUSH(FOLLOW_glaDef_in_actionBody593);
        	        gla=glaDef(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }

        	        CREATE_stream_glaDef; stream_glaDef->add(stream_glaDef, gla.tree, NULL);
        	        FOLLOWPUSH(FOLLOW_constArgs_in_actionBody597);
        	        ct=constArgs(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }

        	        CREATE_stream_constArgs; stream_constArgs->add(stream_constArgs, ct.tree, NULL);
        	        // Piggy.g:53:41: ( ( FROM )? inp= ID )
        	        // Piggy.g:53:42: ( FROM )? inp= ID
        	        {

        	            // Piggy.g:53:42: ( FROM )?
        	            {
        	                int alt6=2;
        	                switch ( LA(1) ) 
        	                {
        	                    case FROM:
        	                    	{
        	                    		alt6=1;
        	                    	}
        	                        break;
        	                }

        	                switch (alt6) 
        	                {
        	            	case 1:
        	            	    // Piggy.g:53:42: FROM
        	            	    {
        	            	        FROM22 = (pANTLR3_COMMON_TOKEN) MATCHT(FROM, &FOLLOW_FROM_in_actionBody600); 
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto ruleactionBodyEx;
        	            	        }
        	            	         
        	            	        CREATE_stream_FROM; stream_FROM->add(stream_FROM, FROM22, NULL);


        	            	    }
        	            	    break;

        	                }
        	            }
        	            inp = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_actionBody605); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleactionBodyEx;
        	            }
        	             
        	            CREATE_stream_ID; stream_ID->add(stream_ID, inp, NULL);


        	        }

        	        USING23 = (pANTLR3_COMMON_TOKEN) MATCHT(USING, &FOLLOW_USING_in_actionBody608); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }
        	         
        	        CREATE_stream_USING; stream_USING->add(stream_USING, USING23, NULL);

        	        FOLLOWPUSH(FOLLOW_expressionList_in_actionBody612);
        	        exp=expressionList(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }

        	        CREATE_stream_expressionList; stream_expressionList->add(stream_expressionList, exp.tree, NULL);

        	        // Piggy.g:53:81: ( AS rez= attListWTypes )?
        	        {
        	            int alt7=2;
        	            switch ( LA(1) ) 
        	            {
        	                case AS:
        	                	{
        	                		alt7=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt7) 
        	            {
        	        	case 1:
        	        	    // Piggy.g:53:82: AS rez= attListWTypes
        	        	    {
        	        	        AS24 = (pANTLR3_COMMON_TOKEN) MATCHT(AS, &FOLLOW_AS_in_actionBody615); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleactionBodyEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_AS; stream_AS->add(stream_AS, AS24, NULL);

        	        	        FOLLOWPUSH(FOLLOW_attListWTypes_in_actionBody619);
        	        	        rez=attListWTypes(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleactionBodyEx;
        	        	        }

        	        	        CREATE_stream_attListWTypes; stream_attListWTypes->add(stream_attListWTypes, rez.tree, NULL);

        	        	    }
        	        	    break;

        	            }
        	        }

        	         
        	        /* AST REWRITE
        	         * elements          : inp, ID, exp, gla, rez, PLUS, PLUS, ct, GLA, GLA
        	         * token labels      : inp
        	         * rule labels       : exp, retval, gla, rez, ct
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_inp;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_exp;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_gla;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_rez;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_ct;

        	        	stream_inp=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token inp", inp);
        	        	stream_exp=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token exp", exp.tree != NULL ? exp.tree : NULL);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
        	        	stream_gla=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token gla", gla.tree != NULL ? gla.tree : NULL);
        	        	stream_rez=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token rez", rez.tree != NULL ? rez.tree : NULL);
        	        	stream_ct=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token ct", ct.tree != NULL ? ct.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 54:5: -> ^( GLA ( PLUS )? $inp) ^( QUERRY__ ID[$inp,qry.c_str()] ^( GLA ( PLUS )? $ct $gla $rez $exp) )
        	        	{
        	        	    // Piggy.g:54:8: ^( GLA ( PLUS )? $inp)
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_GLA == NULL ? NULL : stream_GLA->nextNode(stream_GLA), root_1));

        	        	        // Piggy.g:54:14: ( PLUS )?
        	        	        {
        	        	        	if ( (stream_PLUS != NULL && stream_PLUS->hasNext(stream_PLUS))  )
        	        	        	{
        	        	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_PLUS == NULL ? NULL : stream_PLUS->nextNode(stream_PLUS));

        	        	        	}
        	        	        	if ( stream_PLUS != NULL) stream_PLUS->reset(stream_PLUS);

        	        	        }
        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_inp == NULL ? NULL : stream_inp->nextNode(stream_inp));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }
        	        	    // Piggy.g:54:28: ^( QUERRY__ ID[$inp,qry.c_str()] ^( GLA ( PLUS )? $ct $gla $rez $exp) )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUERRY__, (pANTLR3_UINT8)"QUERRY__"), root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, 
        	        	        #if 2 == 2
        	        	        	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, ID, TOKTEXT(inp, qry.c_str()))
        	        	        #else
        	        	        	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ID, (pANTLR3_UINT8)inp, qry.c_str())
        	        	        #endif
        	        	        );
        	        	        // Piggy.g:54:60: ^( GLA ( PLUS )? $ct $gla $rez $exp)
        	        	        {
        	        	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_GLA == NULL ? NULL : stream_GLA->nextNode(stream_GLA), root_2));

        	        	            // Piggy.g:54:66: ( PLUS )?
        	        	            {
        	        	            	if ( (stream_PLUS != NULL && stream_PLUS->hasNext(stream_PLUS))  )
        	        	            	{
        	        	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_PLUS == NULL ? NULL : stream_PLUS->nextNode(stream_PLUS));

        	        	            	}
        	        	            	if ( stream_PLUS != NULL) stream_PLUS->reset(stream_PLUS);

        	        	            }
        	        	            ADAPTOR->addChild(ADAPTOR, root_2, stream_ct == NULL ? NULL : stream_ct->nextTree(stream_ct));
        	        	            ADAPTOR->addChild(ADAPTOR, root_2, stream_gla == NULL ? NULL : stream_gla->nextTree(stream_gla));
        	        	            ADAPTOR->addChild(ADAPTOR, root_2, stream_rez == NULL ? NULL : stream_rez->nextTree(stream_rez));
        	        	            ADAPTOR->addChild(ADAPTOR, root_2, stream_exp == NULL ? NULL : stream_exp->nextTree(stream_exp));

        	        	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}

        	        	retval.tree = root_0; // set result root
        	        	if (stream_inp != NULL) stream_inp->free(stream_inp); 
        	        	if (stream_exp != NULL) stream_exp->free(stream_exp);
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);
        	        	if (stream_gla != NULL) stream_gla->free(stream_gla);
        	        	if (stream_rez != NULL) stream_rez->free(stream_rez);
        	        	if (stream_ct != NULL) stream_ct->free(stream_ct);


        	        }
        	    }
        	    break;
        	case 4:
        	    // Piggy.g:55:5: AGGREGATE type= ID ( ( FROM )? inp= ID ) USING expr= expression AS name= ID
        	    {
        	        AGGREGATE25 = (pANTLR3_COMMON_TOKEN) MATCHT(AGGREGATE, &FOLLOW_AGGREGATE_in_actionBody673); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }
        	         
        	        CREATE_stream_AGGREGATE; stream_AGGREGATE->add(stream_AGGREGATE, AGGREGATE25, NULL);

        	        type = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_actionBody677); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }
        	         
        	        CREATE_stream_ID; stream_ID->add(stream_ID, type, NULL);

        	        // Piggy.g:55:23: ( ( FROM )? inp= ID )
        	        // Piggy.g:55:24: ( FROM )? inp= ID
        	        {

        	            // Piggy.g:55:24: ( FROM )?
        	            {
        	                int alt8=2;
        	                switch ( LA(1) ) 
        	                {
        	                    case FROM:
        	                    	{
        	                    		alt8=1;
        	                    	}
        	                        break;
        	                }

        	                switch (alt8) 
        	                {
        	            	case 1:
        	            	    // Piggy.g:55:24: FROM
        	            	    {
        	            	        FROM26 = (pANTLR3_COMMON_TOKEN) MATCHT(FROM, &FOLLOW_FROM_in_actionBody680); 
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto ruleactionBodyEx;
        	            	        }
        	            	         
        	            	        CREATE_stream_FROM; stream_FROM->add(stream_FROM, FROM26, NULL);


        	            	    }
        	            	    break;

        	                }
        	            }
        	            inp = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_actionBody685); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleactionBodyEx;
        	            }
        	             
        	            CREATE_stream_ID; stream_ID->add(stream_ID, inp, NULL);


        	        }

        	        USING27 = (pANTLR3_COMMON_TOKEN) MATCHT(USING, &FOLLOW_USING_in_actionBody688); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }
        	         
        	        CREATE_stream_USING; stream_USING->add(stream_USING, USING27, NULL);

        	        FOLLOWPUSH(FOLLOW_expression_in_actionBody692);
        	        expr=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }

        	        CREATE_stream_expression; stream_expression->add(stream_expression, expr.tree, NULL);
        	        AS28 = (pANTLR3_COMMON_TOKEN) MATCHT(AS, &FOLLOW_AS_in_actionBody694); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }
        	         
        	        CREATE_stream_AS; stream_AS->add(stream_AS, AS28, NULL);

        	        name = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_actionBody698); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }
        	         
        	        CREATE_stream_ID; stream_ID->add(stream_ID, name, NULL);


        	         
        	        /* AST REWRITE
        	         * elements          : AGGREGATE, type, name, inp, expr, ID, AGGREGATE
        	         * token labels      : inp, name, type
        	         * rule labels       : retval, expr
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_inp;
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_name;
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_type;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_expr;

        	        	stream_inp=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token inp", inp);
        	        	stream_name=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token name", name);
        	        	stream_type=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token type", type);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
        	        	stream_expr=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token expr", expr.tree != NULL ? expr.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 56:5: -> ^( AGGREGATE $inp) ^( QUERRY__ ID[$inp,qry.c_str()] ^( AGGREGATE $name $type $expr) )
        	        	{
        	        	    // Piggy.g:56:8: ^( AGGREGATE $inp)
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_AGGREGATE == NULL ? NULL : stream_AGGREGATE->nextNode(stream_AGGREGATE), root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_inp == NULL ? NULL : stream_inp->nextNode(stream_inp));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }
        	        	    // Piggy.g:56:26: ^( QUERRY__ ID[$inp,qry.c_str()] ^( AGGREGATE $name $type $expr) )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUERRY__, (pANTLR3_UINT8)"QUERRY__"), root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, 
        	        	        #if 2 == 2
        	        	        	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, ID, TOKTEXT(inp, qry.c_str()))
        	        	        #else
        	        	        	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ID, (pANTLR3_UINT8)inp, qry.c_str())
        	        	        #endif
        	        	        );
        	        	        // Piggy.g:56:58: ^( AGGREGATE $name $type $expr)
        	        	        {
        	        	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_AGGREGATE == NULL ? NULL : stream_AGGREGATE->nextNode(stream_AGGREGATE), root_2));

        	        	            ADAPTOR->addChild(ADAPTOR, root_2, stream_name == NULL ? NULL : stream_name->nextNode(stream_name));
        	        	            ADAPTOR->addChild(ADAPTOR, root_2, stream_type == NULL ? NULL : stream_type->nextNode(stream_type));
        	        	            ADAPTOR->addChild(ADAPTOR, root_2, stream_expr == NULL ? NULL : stream_expr->nextTree(stream_expr));

        	        	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}

        	        	retval.tree = root_0; // set result root
        	        	if (stream_inp != NULL) stream_inp->free(stream_inp); 
        	        	if (stream_name != NULL) stream_name->free(stream_name); 
        	        	if (stream_type != NULL) stream_type->free(stream_type); 
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);
        	        	if (stream_expr != NULL) stream_expr->free(stream_expr);


        	        }
        	    }
        	    break;
        	case 5:
        	    // Piggy.g:57:5: READ ( FILE )? f= STRING ( COLON b= INT )? ( SEPARATOR s= STRING )? ATTRIBUTES FROM c= ID
        	    {
        	        READ29 = (pANTLR3_COMMON_TOKEN) MATCHT(READ, &FOLLOW_READ_in_actionBody737); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }
        	         
        	        CREATE_stream_READ; stream_READ->add(stream_READ, READ29, NULL);


        	        // Piggy.g:57:10: ( FILE )?
        	        {
        	            int alt9=2;
        	            switch ( LA(1) ) 
        	            {
        	                case FILE:
        	                	{
        	                		alt9=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt9) 
        	            {
        	        	case 1:
        	        	    // Piggy.g:57:10: FILE
        	        	    {
        	        	        FILE30 = (pANTLR3_COMMON_TOKEN) MATCHT(FILE, &FOLLOW_FILE_in_actionBody739); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleactionBodyEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_FILE; stream_FILE->add(stream_FILE, FILE30, NULL);


        	        	    }
        	        	    break;

        	            }
        	        }
        	        f = (pANTLR3_COMMON_TOKEN) MATCHT(STRING, &FOLLOW_STRING_in_actionBody744); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }
        	         
        	        CREATE_stream_STRING; stream_STRING->add(stream_STRING, f, NULL);


        	        // Piggy.g:57:25: ( COLON b= INT )?
        	        {
        	            int alt10=2;
        	            switch ( LA(1) ) 
        	            {
        	                case COLON:
        	                	{
        	                		alt10=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt10) 
        	            {
        	        	case 1:
        	        	    // Piggy.g:57:26: COLON b= INT
        	        	    {
        	        	        COLON31 = (pANTLR3_COMMON_TOKEN) MATCHT(COLON, &FOLLOW_COLON_in_actionBody747); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleactionBodyEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_COLON; stream_COLON->add(stream_COLON, COLON31, NULL);

        	        	        b = (pANTLR3_COMMON_TOKEN) MATCHT(INT, &FOLLOW_INT_in_actionBody751); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleactionBodyEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_INT; stream_INT->add(stream_INT, b, NULL);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // Piggy.g:57:40: ( SEPARATOR s= STRING )?
        	        {
        	            int alt11=2;
        	            switch ( LA(1) ) 
        	            {
        	                case SEPARATOR:
        	                	{
        	                		alt11=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt11) 
        	            {
        	        	case 1:
        	        	    // Piggy.g:57:41: SEPARATOR s= STRING
        	        	    {
        	        	        SEPARATOR32 = (pANTLR3_COMMON_TOKEN) MATCHT(SEPARATOR, &FOLLOW_SEPARATOR_in_actionBody756); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleactionBodyEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_SEPARATOR; stream_SEPARATOR->add(stream_SEPARATOR, SEPARATOR32, NULL);

        	        	        s = (pANTLR3_COMMON_TOKEN) MATCHT(STRING, &FOLLOW_STRING_in_actionBody760); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleactionBodyEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_STRING; stream_STRING->add(stream_STRING, s, NULL);


        	        	    }
        	        	    break;

        	            }
        	        }
        	        ATTRIBUTES33 = (pANTLR3_COMMON_TOKEN) MATCHT(ATTRIBUTES, &FOLLOW_ATTRIBUTES_in_actionBody764); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }
        	         
        	        CREATE_stream_ATTRIBUTES; stream_ATTRIBUTES->add(stream_ATTRIBUTES, ATTRIBUTES33, NULL);

        	        FROM34 = (pANTLR3_COMMON_TOKEN) MATCHT(FROM, &FOLLOW_FROM_in_actionBody766); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }
        	         
        	        CREATE_stream_FROM; stream_FROM->add(stream_FROM, FROM34, NULL);

        	        c = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_actionBody770); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactionBodyEx;
        	        }
        	         
        	        CREATE_stream_ID; stream_ID->add(stream_ID, c, NULL);


        	         
        	        /* AST REWRITE
        	         * elements          : SEPARATOR, f, c, s, b
        	         * token labels      : f, b, s, c
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_f;
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_b;
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_s;
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_c;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_f=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token f", f);
        	        	stream_b=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token b", b);
        	        	stream_s=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token s", s);
        	        	stream_c=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token c", c);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 58:9: -> ^( TEXTLOADER__ ^( ATTFROM $c) ( ^( SEPARATOR $s) )? ^( FILE__ $f $b) )
        	        	{
        	        	    // Piggy.g:58:12: ^( TEXTLOADER__ ^( ATTFROM $c) ( ^( SEPARATOR $s) )? ^( FILE__ $f $b) )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TEXTLOADER__, (pANTLR3_UINT8)"TEXTLOADER__"), root_1));

        	        	        // Piggy.g:58:27: ^( ATTFROM $c)
        	        	        {
        	        	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ATTFROM, (pANTLR3_UINT8)"ATTFROM"), root_2));

        	        	            ADAPTOR->addChild(ADAPTOR, root_2, stream_c == NULL ? NULL : stream_c->nextNode(stream_c));

        	        	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
        	        	        }
        	        	        // Piggy.g:58:41: ( ^( SEPARATOR $s) )?
        	        	        {
        	        	        	if ( (stream_SEPARATOR != NULL && stream_SEPARATOR->hasNext(stream_SEPARATOR)) || (stream_s != NULL && stream_s->hasNext(stream_s))  )
        	        	        	{
        	        	        		// Piggy.g:58:41: ^( SEPARATOR $s)
        	        	        		{
        	        	        		    pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        		    root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_SEPARATOR == NULL ? NULL : stream_SEPARATOR->nextNode(stream_SEPARATOR), root_2));

        	        	        		    ADAPTOR->addChild(ADAPTOR, root_2, stream_s == NULL ? NULL : stream_s->nextNode(stream_s));

        	        	        		    ADAPTOR->addChild(ADAPTOR, root_1, root_2);
        	        	        		}

        	        	        	}
        	        	        	if ( stream_SEPARATOR != NULL) stream_SEPARATOR->reset(stream_SEPARATOR);
        	        	        	if ( stream_s != NULL) stream_s->reset(stream_s);

        	        	        }
        	        	        // Piggy.g:58:59: ^( FILE__ $f $b)
        	        	        {
        	        	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, FILE__, (pANTLR3_UINT8)"FILE__"), root_2));

        	        	            ADAPTOR->addChild(ADAPTOR, root_2, stream_f == NULL ? NULL : stream_f->nextNode(stream_f));
        	        	            ADAPTOR->addChild(ADAPTOR, root_2, stream_b == NULL ? NULL : stream_b->nextNode(stream_b));

        	        	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}

        	        	retval.tree = root_0; // set result root
        	        	if (stream_f != NULL) stream_f->free(stream_f); 
        	        	if (stream_b != NULL) stream_b->free(stream_b); 
        	        	if (stream_s != NULL) stream_s->free(stream_s); 
        	        	if (stream_c != NULL) stream_c->free(stream_c); 
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleactionBodyEx; /* Prevent compiler warnings */
    ruleactionBodyEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_COLON != NULL) stream_COLON->free(stream_COLON);
        if (stream_AS != NULL) stream_AS->free(stream_AS);
        if (stream_BY != NULL) stream_BY->free(stream_BY);
        if (stream_ATTRIBUTES != NULL) stream_ATTRIBUTES->free(stream_ATTRIBUTES);
        if (stream_USING != NULL) stream_USING->free(stream_USING);
        if (stream_READ != NULL) stream_READ->free(stream_READ);
        if (stream_COMMA != NULL) stream_COMMA->free(stream_COMMA);
        if (stream_FILTER != NULL) stream_FILTER->free(stream_FILTER);
        if (stream_PLUS != NULL) stream_PLUS->free(stream_PLUS);
        if (stream_GLA != NULL) stream_GLA->free(stream_GLA);
        if (stream_INT != NULL) stream_INT->free(stream_INT);
        if (stream_SEPARATOR != NULL) stream_SEPARATOR->free(stream_SEPARATOR);
        if (stream_ID != NULL) stream_ID->free(stream_ID);
        if (stream_FROM != NULL) stream_FROM->free(stream_FROM);
        if (stream_FILE != NULL) stream_FILE->free(stream_FILE);
        if (stream_JOIN != NULL) stream_JOIN->free(stream_JOIN);
        if (stream_AGGREGATE != NULL) stream_AGGREGATE->free(stream_AGGREGATE);
        if (stream_STRING != NULL) stream_STRING->free(stream_STRING);
        if (stream_expression != NULL) stream_expression->free(stream_expression);
        if (stream_attEListAlt != NULL) stream_attEListAlt->free(stream_attEListAlt);
        if (stream_glaDef != NULL) stream_glaDef->free(stream_glaDef);
        if (stream_constArgs != NULL) stream_constArgs->free(stream_constArgs);
        if (stream_attListWTypes != NULL) stream_attListWTypes->free(stream_attListWTypes);
        if (stream_expressionList != NULL) stream_expressionList->free(stream_expressionList);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end actionBody */

/** 
 * $ANTLR start glaDef
 * Piggy.g:61:1: glaDef : COLON ID (def= glaTemplateDef )? -> ID ( ^( GLATEMPLATE $def) )? ;
 */
static PiggyParser_glaDef_return
glaDef(pPiggyParser ctx)
{   
    PiggyParser_glaDef_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COLON35;
    pANTLR3_COMMON_TOKEN    ID36;
    PiggyParser_glaTemplateDef_return def;
    #undef	RETURN_TYPE_def
    #define	RETURN_TYPE_def PiggyParser_glaTemplateDef_return

    pANTLR3_BASE_TREE COLON35_tree;
    pANTLR3_BASE_TREE ID36_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_COLON;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ID;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_glaTemplateDef;
    /* Initialize rule variables
     */


    root_0 = NULL;

    COLON35       = NULL;
    ID36       = NULL;
    def.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    COLON35_tree   = NULL;
    ID36_tree   = NULL;

    stream_COLON   = NULL;
    #define CREATE_stream_COLON  if (stream_COLON == NULL) {stream_COLON = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token COLON"); } 
    stream_ID   = NULL;
    #define CREATE_stream_ID  if (stream_ID == NULL) {stream_ID = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ID"); } 
    stream_glaTemplateDef   = NULL;
    #define CREATE_stream_glaTemplateDef  if (stream_glaTemplateDef == NULL) {stream_glaTemplateDef = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule glaTemplateDef"); }

    retval.tree  = NULL;
    {
        // Piggy.g:62:3: ( COLON ID (def= glaTemplateDef )? -> ID ( ^( GLATEMPLATE $def) )? )
        // Piggy.g:62:5: COLON ID (def= glaTemplateDef )?
        {
            COLON35 = (pANTLR3_COMMON_TOKEN) MATCHT(COLON, &FOLLOW_COLON_in_glaDef824); 
            if  (HASEXCEPTION())
            {
                goto ruleglaDefEx;
            }
             
            CREATE_stream_COLON; stream_COLON->add(stream_COLON, COLON35, NULL);

            ID36 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_glaDef826); 
            if  (HASEXCEPTION())
            {
                goto ruleglaDefEx;
            }
             
            CREATE_stream_ID; stream_ID->add(stream_ID, ID36, NULL);


            // Piggy.g:62:17: (def= glaTemplateDef )?
            {
                int alt13=2;
                switch ( LA(1) ) 
                {
                    case LS:
                    	{
                    		alt13=1;
                    	}
                        break;
                }

                switch (alt13) 
                {
            	case 1:
            	    // Piggy.g:62:17: def= glaTemplateDef
            	    {
            	        FOLLOWPUSH(FOLLOW_glaTemplateDef_in_glaDef830);
            	        def=glaTemplateDef(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleglaDefEx;
            	        }

            	        CREATE_stream_glaTemplateDef; stream_glaTemplateDef->add(stream_glaTemplateDef, def.tree, NULL);

            	    }
            	    break;

                }
            }

             
            /* AST REWRITE
             * elements          : def, ID
             * token labels      : 
             * rule labels       : retval, def
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_def;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
            	stream_def=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token def", def.tree != NULL ? def.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 62:35: -> ID ( ^( GLATEMPLATE $def) )?
            	{
            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_ID == NULL ? NULL : stream_ID->nextNode(stream_ID));
            	    // Piggy.g:62:41: ( ^( GLATEMPLATE $def) )?
            	    {
            	    	if ( (stream_def != NULL && stream_def->hasNext(stream_def))  )
            	    	{
            	    		// Piggy.g:62:41: ^( GLATEMPLATE $def)
            	    		{
            	    		    pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	    		    root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, GLATEMPLATE, (pANTLR3_UINT8)"GLATEMPLATE"), root_1));

            	    		    ADAPTOR->addChild(ADAPTOR, root_1, stream_def == NULL ? NULL : stream_def->nextTree(stream_def));

            	    		    ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    		}

            	    	}
            	    	if ( stream_def != NULL) stream_def->reset(stream_def);

            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);
            	if (stream_def != NULL) stream_def->free(stream_def);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleglaDefEx; /* Prevent compiler warnings */
    ruleglaDefEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_COLON != NULL) stream_COLON->free(stream_COLON);
        if (stream_ID != NULL) stream_ID->free(stream_ID);
        if (stream_glaTemplateDef != NULL) stream_glaTemplateDef->free(stream_glaTemplateDef);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end glaDef */

/** 
 * $ANTLR start glaTemplateDef
 * Piggy.g:65:1: glaTemplateDef : '<' glaTemplArg ( COMMA glaTemplArg )* '>' ;
 */
static PiggyParser_glaTemplateDef_return
glaTemplateDef(pPiggyParser ctx)
{   
    PiggyParser_glaTemplateDef_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal37;
    pANTLR3_COMMON_TOKEN    COMMA39;
    pANTLR3_COMMON_TOKEN    char_literal41;
    PiggyParser_glaTemplArg_return glaTemplArg38;
    #undef	RETURN_TYPE_glaTemplArg38
    #define	RETURN_TYPE_glaTemplArg38 PiggyParser_glaTemplArg_return

    PiggyParser_glaTemplArg_return glaTemplArg40;
    #undef	RETURN_TYPE_glaTemplArg40
    #define	RETURN_TYPE_glaTemplArg40 PiggyParser_glaTemplArg_return

    pANTLR3_BASE_TREE char_literal37_tree;
    pANTLR3_BASE_TREE COMMA39_tree;
    pANTLR3_BASE_TREE char_literal41_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    char_literal37       = NULL;
    COMMA39       = NULL;
    char_literal41       = NULL;
    glaTemplArg38.tree = NULL;
    glaTemplArg40.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    char_literal37_tree   = NULL;
    COMMA39_tree   = NULL;
    char_literal41_tree   = NULL;


    retval.tree  = NULL;
    {
        // Piggy.g:66:3: ( '<' glaTemplArg ( COMMA glaTemplArg )* '>' )
        // Piggy.g:66:5: '<' glaTemplArg ( COMMA glaTemplArg )* '>'
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            char_literal37 = (pANTLR3_COMMON_TOKEN) MATCHT(LS, &FOLLOW_LS_in_glaTemplateDef857); 
            if  (HASEXCEPTION())
            {
                goto ruleglaTemplateDefEx;
            }

            FOLLOWPUSH(FOLLOW_glaTemplArg_in_glaTemplateDef860);
            glaTemplArg38=glaTemplArg(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleglaTemplateDefEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, glaTemplArg38.tree);

            // Piggy.g:66:22: ( COMMA glaTemplArg )*

            for (;;)
            {
                int alt14=2;
                switch ( LA(1) ) 
                {
                case COMMA:
                	{
                		alt14=1;
                	}
                    break;

                }

                switch (alt14) 
                {
            	case 1:
            	    // Piggy.g:66:23: COMMA glaTemplArg
            	    {
            	        COMMA39 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_glaTemplateDef863); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleglaTemplateDefEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_glaTemplArg_in_glaTemplateDef866);
            	        glaTemplArg40=glaTemplArg(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleglaTemplateDefEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, glaTemplArg40.tree);

            	    }
            	    break;

            	default:
            	    goto loop14;	/* break out of the loop */
            	    break;
                }
            }
            loop14: ; /* Jump out to here if this rule does not match */

            char_literal41 = (pANTLR3_COMMON_TOKEN) MATCHT(GT, &FOLLOW_GT_in_glaTemplateDef870); 
            if  (HASEXCEPTION())
            {
                goto ruleglaTemplateDefEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleglaTemplateDefEx; /* Prevent compiler warnings */
    ruleglaTemplateDefEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end glaTemplateDef */

/** 
 * $ANTLR start glaTemplArg
 * Piggy.g:69:1: glaTemplArg : ( LSQ attCList RSQ -> ^( LIST attCList ) | attWType | ctAtt | GLA glaDef );
 */
static PiggyParser_glaTemplArg_return
glaTemplArg(pPiggyParser ctx)
{   
    PiggyParser_glaTemplArg_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    LSQ42;
    pANTLR3_COMMON_TOKEN    RSQ44;
    pANTLR3_COMMON_TOKEN    GLA47;
    Piggy_BaseParser_attCList_return attCList43;
    #undef	RETURN_TYPE_attCList43
    #define	RETURN_TYPE_attCList43 Piggy_BaseParser_attCList_return

    Piggy_BaseParser_attWType_return attWType45;
    #undef	RETURN_TYPE_attWType45
    #define	RETURN_TYPE_attWType45 Piggy_BaseParser_attWType_return

    Piggy_BaseParser_ctAtt_return ctAtt46;
    #undef	RETURN_TYPE_ctAtt46
    #define	RETURN_TYPE_ctAtt46 Piggy_BaseParser_ctAtt_return

    PiggyParser_glaDef_return glaDef48;
    #undef	RETURN_TYPE_glaDef48
    #define	RETURN_TYPE_glaDef48 PiggyParser_glaDef_return

    pANTLR3_BASE_TREE LSQ42_tree;
    pANTLR3_BASE_TREE RSQ44_tree;
    pANTLR3_BASE_TREE GLA47_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_LSQ;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_RSQ;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_attCList;
    /* Initialize rule variables
     */


    root_0 = NULL;

    LSQ42       = NULL;
    RSQ44       = NULL;
    GLA47       = NULL;
    attCList43.tree = NULL;
    attWType45.tree = NULL;
    ctAtt46.tree = NULL;
    glaDef48.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    LSQ42_tree   = NULL;
    RSQ44_tree   = NULL;
    GLA47_tree   = NULL;

    stream_LSQ   = NULL;
    #define CREATE_stream_LSQ  if (stream_LSQ == NULL) {stream_LSQ = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token LSQ"); } 
    stream_RSQ   = NULL;
    #define CREATE_stream_RSQ  if (stream_RSQ == NULL) {stream_RSQ = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token RSQ"); } 
    stream_attCList   = NULL;
    #define CREATE_stream_attCList  if (stream_attCList == NULL) {stream_attCList = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule attCList"); }

    retval.tree  = NULL;
    {
        {
            //  Piggy.g:70:3: ( LSQ attCList RSQ -> ^( LIST attCList ) | attWType | ctAtt | GLA glaDef )
            
            ANTLR3_UINT32 alt15;

            alt15=4;

            switch ( LA(1) ) 
            {
            case LSQ:
            	{
            		alt15=1;
            	}
                break;
            case ID:
            	{
            		alt15=2;
            	}
                break;
            case INT:
            case FLOAT:
            case STRING:
            	{
            		alt15=3;
            	}
                break;
            case GLA:
            	{
            		alt15=4;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 15;
                EXCEPTION->state        = 0;


                goto ruleglaTemplArgEx;
            }

            switch (alt15) 
            {
        	case 1:
        	    // Piggy.g:70:5: LSQ attCList RSQ
        	    {
        	        LSQ42 = (pANTLR3_COMMON_TOKEN) MATCHT(LSQ, &FOLLOW_LSQ_in_glaTemplArg884); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglaTemplArgEx;
        	        }
        	         
        	        CREATE_stream_LSQ; stream_LSQ->add(stream_LSQ, LSQ42, NULL);

        	        FOLLOWPUSH(FOLLOW_attCList_in_glaTemplArg886);
        	        attCList43=attCList(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglaTemplArgEx;
        	        }

        	        CREATE_stream_attCList; stream_attCList->add(stream_attCList, attCList43.tree, NULL);
        	        RSQ44 = (pANTLR3_COMMON_TOKEN) MATCHT(RSQ, &FOLLOW_RSQ_in_glaTemplArg888); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglaTemplArgEx;
        	        }
        	         
        	        CREATE_stream_RSQ; stream_RSQ->add(stream_RSQ, RSQ44, NULL);


        	         
        	        /* AST REWRITE
        	         * elements          : attCList
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 70:22: -> ^( LIST attCList )
        	        	{
        	        	    // Piggy.g:70:25: ^( LIST attCList )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, LIST, (pANTLR3_UINT8)"LIST"), root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_attCList == NULL ? NULL : stream_attCList->nextTree(stream_attCList));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}

        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 2:
        	    // Piggy.g:71:5: attWType
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_attWType_in_glaTemplArg902);
        	        attWType45=attWType(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglaTemplArgEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, attWType45.tree);

        	    }
        	    break;
        	case 3:
        	    // Piggy.g:72:5: ctAtt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_ctAtt_in_glaTemplArg910);
        	        ctAtt46=ctAtt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglaTemplArgEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, ctAtt46.tree);

        	    }
        	    break;
        	case 4:
        	    // Piggy.g:73:5: GLA glaDef
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        GLA47 = (pANTLR3_COMMON_TOKEN) MATCHT(GLA, &FOLLOW_GLA_in_glaTemplArg916); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglaTemplArgEx;
        	        }

        	        GLA47_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, GLA47));
        	        ADAPTOR->addChild(ADAPTOR, root_0, GLA47_tree);

        	        FOLLOWPUSH(FOLLOW_glaDef_in_glaTemplArg918);
        	        glaDef48=glaDef(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglaTemplArgEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, glaDef48.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleglaTemplArgEx; /* Prevent compiler warnings */
    ruleglaTemplArgEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_LSQ != NULL) stream_LSQ->free(stream_LSQ);
        if (stream_RSQ != NULL) stream_RSQ->free(stream_RSQ);
        if (stream_attCList != NULL) stream_attCList->free(stream_attCList);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end glaTemplArg */

/** 
 * $ANTLR start constArgs
 * Piggy.g:78:1: constArgs : ( | LPAREN ctAttList RPAREN );
 */
static PiggyParser_constArgs_return
constArgs(pPiggyParser ctx)
{   
    PiggyParser_constArgs_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    LPAREN49;
    pANTLR3_COMMON_TOKEN    RPAREN51;
    Piggy_BaseParser_ctAttList_return ctAttList50;
    #undef	RETURN_TYPE_ctAttList50
    #define	RETURN_TYPE_ctAttList50 Piggy_BaseParser_ctAttList_return

    pANTLR3_BASE_TREE LPAREN49_tree;
    pANTLR3_BASE_TREE RPAREN51_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    LPAREN49       = NULL;
    RPAREN51       = NULL;
    ctAttList50.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    LPAREN49_tree   = NULL;
    RPAREN51_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  Piggy.g:79:3: ( | LPAREN ctAttList RPAREN )
            
            ANTLR3_UINT32 alt16;

            alt16=2;

            switch ( LA(1) ) 
            {
            case ID:
            case FROM:
            	{
            		alt16=1;
            	}
                break;
            case LPAREN:
            	{
            		alt16=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 16;
                EXCEPTION->state        = 0;


                goto ruleconstArgsEx;
            }

            switch (alt16) 
            {
        	case 1:
        	    // Piggy.g:80:3: 
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	    }
        	    break;
        	case 2:
        	    // Piggy.g:80:5: LPAREN ctAttList RPAREN
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        LPAREN49 = (pANTLR3_COMMON_TOKEN) MATCHT(LPAREN, &FOLLOW_LPAREN_in_constArgs940); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconstArgsEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_ctAttList_in_constArgs943);
        	        ctAttList50=ctAttList(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconstArgsEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, ctAttList50.tree);
        	        RPAREN51 = (pANTLR3_COMMON_TOKEN) MATCHT(RPAREN, &FOLLOW_RPAREN_in_constArgs945); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconstArgsEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleconstArgsEx; /* Prevent compiler warnings */
    ruleconstArgsEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end constArgs */

/** 
 * $ANTLR start attEListAlt
 * Piggy.g:83:1: attEListAlt : ( ( attribute | synthAttribute ) | LPAREN attributeEList RPAREN );
 */
static PiggyParser_attEListAlt_return
attEListAlt(pPiggyParser ctx)
{   
    PiggyParser_attEListAlt_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    LPAREN54;
    pANTLR3_COMMON_TOKEN    RPAREN56;
    Piggy_BaseParser_attribute_return attribute52;
    #undef	RETURN_TYPE_attribute52
    #define	RETURN_TYPE_attribute52 Piggy_BaseParser_attribute_return

    Piggy_BaseParser_synthAttribute_return synthAttribute53;
    #undef	RETURN_TYPE_synthAttribute53
    #define	RETURN_TYPE_synthAttribute53 Piggy_BaseParser_synthAttribute_return

    Piggy_BaseParser_attributeEList_return attributeEList55;
    #undef	RETURN_TYPE_attributeEList55
    #define	RETURN_TYPE_attributeEList55 Piggy_BaseParser_attributeEList_return

    pANTLR3_BASE_TREE LPAREN54_tree;
    pANTLR3_BASE_TREE RPAREN56_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    LPAREN54       = NULL;
    RPAREN56       = NULL;
    attribute52.tree = NULL;
    synthAttribute53.tree = NULL;
    attributeEList55.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    LPAREN54_tree   = NULL;
    RPAREN56_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  Piggy.g:84:3: ( ( attribute | synthAttribute ) | LPAREN attributeEList RPAREN )
            
            ANTLR3_UINT32 alt18;

            alt18=2;

            switch ( LA(1) ) 
            {
            case ID:
            	{
            		alt18=1;
            	}
                break;
            case LPAREN:
            	{
            		alt18=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 18;
                EXCEPTION->state        = 0;


                goto ruleattEListAltEx;
            }

            switch (alt18) 
            {
        	case 1:
        	    // Piggy.g:84:5: ( attribute | synthAttribute )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        // Piggy.g:84:5: ( attribute | synthAttribute )
        	        {
        	            int alt17=2;
        	            switch ( LA(1) ) 
        	            {
        	            case ID:
        	            	{
        	            		switch ( LA(2) ) 
        	            		{
        	            		case DOT:
        	            			{
        	            				alt17=1;
        	            			}
        	            		    break;
        	            		case SEMICOLON:
        	            		case COMMA:
        	            			{
        	            				alt17=2;
        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 17;
        	            		    EXCEPTION->state        = 1;


        	            		    goto ruleattEListAltEx;
        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 17;
        	                EXCEPTION->state        = 0;


        	                goto ruleattEListAltEx;
        	            }

        	            switch (alt17) 
        	            {
        	        	case 1:
        	        	    // Piggy.g:84:6: attribute
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_attribute_in_attEListAlt960);
        	        	        attribute52=attribute(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleattEListAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, attribute52.tree);

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Piggy.g:84:16: synthAttribute
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_synthAttribute_in_attEListAlt962);
        	        	        synthAttribute53=synthAttribute(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleattEListAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, synthAttribute53.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // Piggy.g:85:5: LPAREN attributeEList RPAREN
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        LPAREN54 = (pANTLR3_COMMON_TOKEN) MATCHT(LPAREN, &FOLLOW_LPAREN_in_attEListAlt969); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleattEListAltEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_attributeEList_in_attEListAlt972);
        	        attributeEList55=attributeEList(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleattEListAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, attributeEList55.tree);
        	        RPAREN56 = (pANTLR3_COMMON_TOKEN) MATCHT(RPAREN, &FOLLOW_RPAREN_in_attEListAlt974); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleattEListAltEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleattEListAltEx; /* Prevent compiler warnings */
    ruleattEListAltEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end attEListAlt */
	// Delegated methods that appear to be a part of this 
	// parser
	//
    Piggy_BaseParser_multiplicative_expression_return multiplicative_expression(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->multiplicative_expression(ctx->gBaseParser); 
	}
    Piggy_BaseParser_function_return function(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->function(ctx->gBaseParser); 
	}
    Piggy_BaseParser_attribute_return attribute(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->attribute(ctx->gBaseParser); 
	}
    Piggy_BaseParser_inclusive_or_expression_return inclusive_or_expression(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->inclusive_or_expression(ctx->gBaseParser); 
	}
    Piggy_BaseParser_equality_expression_return equality_expression(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->equality_expression(ctx->gBaseParser); 
	}
    Piggy_BaseParser_idList_return idList(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->idList(ctx->gBaseParser); 
	}
    Piggy_BaseParser_conditional_expression_return conditional_expression(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->conditional_expression(ctx->gBaseParser); 
	}
    Piggy_BaseParser_attListWTypes_return attListWTypes(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->attListWTypes(ctx->gBaseParser); 
	}
    Piggy_BaseParser_shift_expression_return shift_expression(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->shift_expression(ctx->gBaseParser); 
	}
    Piggy_BaseParser_attCList_return attCList(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->attCList(ctx->gBaseParser); 
	}
    Piggy_BaseParser_and_expression_return and_expression(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->and_expression(ctx->gBaseParser); 
	}
    Piggy_BaseParser_expression_return expression(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->expression(ctx->gBaseParser); 
	}
    Piggy_BaseParser_logical_and_expression_return logical_and_expression(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->logical_and_expression(ctx->gBaseParser); 
	}
    Piggy_BaseParser_attributeList_return attributeList(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->attributeList(ctx->gBaseParser); 
	}
    Piggy_BaseParser_relational_expression_return relational_expression(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->relational_expression(ctx->gBaseParser); 
	}
    Piggy_BaseParser_attC_return attC(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->attC(ctx->gBaseParser); 
	}
    Piggy_BaseParser_exclusive_or_expression_return exclusive_or_expression(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->exclusive_or_expression(ctx->gBaseParser); 
	}
    Piggy_BaseParser_match_expression_return match_expression(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->match_expression(ctx->gBaseParser); 
	}
    Piggy_BaseParser_ctAttList_return ctAttList(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->ctAttList(ctx->gBaseParser); 
	}
    Piggy_BaseParser_unary_expression_return unary_expression(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->unary_expression(ctx->gBaseParser); 
	}
    Piggy_BaseParser_basic_bool_expression_return basic_bool_expression(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->basic_bool_expression(ctx->gBaseParser); 
	}
    Piggy_BaseParser_logical_or_expression_return logical_or_expression(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->logical_or_expression(ctx->gBaseParser); 
	}
    Piggy_BaseParser_attCElem_return attCElem(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->attCElem(ctx->gBaseParser); 
	}
    Piggy_BaseParser_expressionList_return expressionList(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->expressionList(ctx->gBaseParser); 
	}
    Piggy_BaseParser_additive_expression_return additive_expression(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->additive_expression(ctx->gBaseParser); 
	}
    Piggy_BaseParser_ctAtt_return ctAtt(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->ctAtt(ctx->gBaseParser); 
	}
    Piggy_BaseParser_primary_expression_return primary_expression(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->primary_expression(ctx->gBaseParser); 
	}
    Piggy_BaseParser_attWType_return attWType(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->attWType(ctx->gBaseParser); 
	}
    Piggy_BaseParser_synthAttribute_return synthAttribute(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->synthAttribute(ctx->gBaseParser); 
	}
    Piggy_BaseParser_attributeEList_return attributeEList(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->attributeEList(ctx->gBaseParser); 
	}
    Piggy_BaseParser_constant_return constant(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->constant(ctx->gBaseParser); 
	}
    Piggy_BaseParser_case_expression_return case_expression(pPiggyParser ctx) 
    { 
return ctx->gBaseParser->case_expression(ctx->gBaseParser); 
	}
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
