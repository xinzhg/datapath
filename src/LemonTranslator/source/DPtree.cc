//
//  Copyright 2012 Alin Dobra and Christopher Jermaine
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//
/** \file
 *  This C source file was generated by $ANTLR version 3.3 Nov 30, 2010 12:50:56
 *
 *     -  From the grammar source file : DPtree.g
 *     -                            On : 2012-06-14 15:15:17
 *     -           for the tree parser : DPtreeTreeParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

 #include "SymbolicWaypointConfig.h"
 #include "LemonTranslator.h"
 #include "AttributeManager.h"
 #include "QueryManager.h"
 #include "DataTypeManager.h"
 #include "ExprListInfo.h"
 #include "Catalog.h"
 #include <iostream>
 #include <map>
 #include <vector>

/* Debugging */
#undef PREPORTERROR
#define PREPORTERROR assert(1=2)

// uncomment this to enforce types
#define ENFORCE_TYPES
//#define ENFORCE_GLA_TYPES

#ifndef TXT
#define TXT(x) ((const char*)(x->getText(x))->chars)
#endif
#ifndef TXTN
#define TXTN(x) ((NormalizeQuotes((const char*)(x->getText(x))->chars)).c_str())
#endif
#ifndef TXTS
#define TXTS(x) ((StripQuotes((const char*)(x->getText(x))->chars)).c_str())
#endif
#ifndef STR
#define STR(X) ( string(TXT(X)) )
#endif
#ifndef STRN
#define STRN(X) ( string(TXTN(X)) )
#endif
#ifndef STRS
#define STRS(X) ( string(TXTS(X)) )
#endif

/* End of Header action.
 * =============================================================================
 */
/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "DPtree.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pDPtree_##scope##_SCOPE
#define SCOPE_STACK(scope)  pDPtree_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pDPtree_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pDPtree_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef	    BACKTRACKING
#undef      ADAPTOR
#undef	    RULEMEMO		
#undef		SEEK    
#undef		INDEX
#undef		DBG

#define	    PARSER							ctx->pTreeParser  
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    INPUT							PARSER->ctnstream
#define		ISTREAM							INPUT->tnstream->istream
#define	    STRSTREAM						INPUT->tnstream
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							ISTREAM->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->tnstream->_LT(INPUT->tnstream, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         INPUT->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define		INDEX()							ISTREAM->index(ISTREAM)
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   DPtreeTokenNames[100+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "FILTER",
        (pANTLR3_UINT8) "JOIN",
        (pANTLR3_UINT8) "GLA",
        (pANTLR3_UINT8) "PRINT",
        (pANTLR3_UINT8) "AGGREGATE",
        (pANTLR3_UINT8) "EQUAL",
        (pANTLR3_UINT8) "SEPARATOR",
        (pANTLR3_UINT8) "ATTRIBUTES",
        (pANTLR3_UINT8) "TEXTLOADER",
        (pANTLR3_UINT8) "FILE",
        (pANTLR3_UINT8) "MATCH_DP",
        (pANTLR3_UINT8) "CASE_DP",
        (pANTLR3_UINT8) "BOOL_T",
        (pANTLR3_UINT8) "ID",
        (pANTLR3_UINT8) "INT",
        (pANTLR3_UINT8) "EXPONENT",
        (pANTLR3_UINT8) "FLOAT",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "ESC_SEQ",
        (pANTLR3_UINT8) "STRING",
        (pANTLR3_UINT8) "SEMICOLON",
        (pANTLR3_UINT8) "COMMA",
        (pANTLR3_UINT8) "COLON",
        (pANTLR3_UINT8) "DOT",
        (pANTLR3_UINT8) "LPAREN",
        (pANTLR3_UINT8) "RPAREN",
        (pANTLR3_UINT8) "LSQ",
        (pANTLR3_UINT8) "RSQ",
        (pANTLR3_UINT8) "QMARK",
        (pANTLR3_UINT8) "LAND",
        (pANTLR3_UINT8) "LOR",
        (pANTLR3_UINT8) "BAND",
        (pANTLR3_UINT8) "BOR",
        (pANTLR3_UINT8) "XOR",
        (pANTLR3_UINT8) "LNOT",
        (pANTLR3_UINT8) "ISEQUAL",
        (pANTLR3_UINT8) "NEQUAL",
        (pANTLR3_UINT8) "LS",
        (pANTLR3_UINT8) "GT",
        (pANTLR3_UINT8) "LE",
        (pANTLR3_UINT8) "GE",
        (pANTLR3_UINT8) "NOT",
        (pANTLR3_UINT8) "SLEFT",
        (pANTLR3_UINT8) "SRIGHT",
        (pANTLR3_UINT8) "PLUS",
        (pANTLR3_UINT8) "MINUS",
        (pANTLR3_UINT8) "TIMES",
        (pANTLR3_UINT8) "DIVIDE",
        (pANTLR3_UINT8) "MOD",
        (pANTLR3_UINT8) "HEX_DIGIT",
        (pANTLR3_UINT8) "UNICODE_ESC",
        (pANTLR3_UINT8) "OCTAL_ESC",
        (pANTLR3_UINT8) "OP",
        (pANTLR3_UINT8) "NEWSTATEMENT",
        (pANTLR3_UINT8) "OLDSTATEMENT",
        (pANTLR3_UINT8) "ATTS",
        (pANTLR3_UINT8) "ATT",
        (pANTLR3_UINT8) "FUNCTION",
        (pANTLR3_UINT8) "OPDEF",
        (pANTLR3_UINT8) "OPERATOR",
        (pANTLR3_UINT8) "UOPERATOR",
        (pANTLR3_UINT8) "DELWAYPOINT",
        (pANTLR3_UINT8) "DELQUERY",
        (pANTLR3_UINT8) "CRDATATYPE",
        (pANTLR3_UINT8) "CRSYNONIM",
        (pANTLR3_UINT8) "FCT",
        (pANTLR3_UINT8) "TPATT",
        (pANTLR3_UINT8) "ATTFROM",
        (pANTLR3_UINT8) "ATTWT",
        (pANTLR3_UINT8) "ATTSWT",
        (pANTLR3_UINT8) "RUN__",
        (pANTLR3_UINT8) "QUERRY__",
        (pANTLR3_UINT8) "WAYPOINT__",
        (pANTLR3_UINT8) "SELECT__",
        (pANTLR3_UINT8) "TERMCONN",
        (pANTLR3_UINT8) "SCANNER__",
        (pANTLR3_UINT8) "WRITER__",
        (pANTLR3_UINT8) "GLATEMPLATE",
        (pANTLR3_UINT8) "LIST",
        (pANTLR3_UINT8) "CRGLA",
        (pANTLR3_UINT8) "CRRELATION",
        (pANTLR3_UINT8) "FLUSHTOKEN",
        (pANTLR3_UINT8) "QUITTOKEN",
        (pANTLR3_UINT8) "FILE__",
        (pANTLR3_UINT8) "TEXTLOADER__",
        (pANTLR3_UINT8) "ATTC",
        (pANTLR3_UINT8) "LOAD",
        (pANTLR3_UINT8) "READ",
        (pANTLR3_UINT8) "USING",
        (pANTLR3_UINT8) "FROM",
        (pANTLR3_UINT8) "BY",
        (pANTLR3_UINT8) "STORE",
        (pANTLR3_UINT8) "AS",
        (pANTLR3_UINT8) "TO",
        (pANTLR3_UINT8) "INTO",
        (pANTLR3_UINT8) "Tokens",
        (pANTLR3_UINT8) "SYNTHESIZE",
        (pANTLR3_UINT8) "BYPASS",
        (pANTLR3_UINT8) "'?'"
       };

        

// Forward declare the locally static matching functions we have generated.
//
static void	parse    (pDPtree ctx, LemonTranslator* trans);
static void	complexStatement    (pDPtree ctx);
static void	runStmt    (pDPtree ctx);
static void	relationCR    (pDPtree ctx);
static vector<string>	lstArgsFc    (pDPtree ctx);
static vector<string>	lstArgsGLA    (pDPtree ctx);
static string	dType    (pDPtree ctx);
static void	statement    (pDPtree ctx, bool isNew);
static void	writer    (pDPtree ctx);
static void	scanner    (pDPtree ctx);
static void	waypoint    (pDPtree ctx, bool isNew);
static void	query    (pDPtree ctx);
static void	qBodyStatement    (pDPtree ctx);
static void	wpbodyStatement    (pDPtree ctx);
static void	bodyStatement    (pDPtree ctx);
static void	rules    (pDPtree ctx);
static void	filterRule    (pDPtree ctx);
static void	synthRule    (pDPtree ctx);
static void	aggregateRule    (pDPtree ctx);
static void	printRule    (pDPtree ctx);
static void	printAtts    (pDPtree ctx, string& names, string& types);
static void	ctAttList    (pDPtree ctx, string& ctArgs);
static string	ctAtt    (pDPtree ctx);
static void	printFile    (pDPtree ctx, string& s);
static DPtree_glaDef_return	glaDef    (pDPtree ctx);
static void	glaTemplate    (pDPtree ctx, string& name, string& defs);
static void	glaTemplArg    (pDPtree ctx, string& args, string& defs);
static void	attWT    (pDPtree ctx, string& args);
static void	attC    (pDPtree ctx, string& args);
static void	glaRule    (pDPtree ctx);
static void	attLWT    (pDPtree ctx, SlotContainer& outAtts, vector<string> &outTypes);
static void	bypassRule    (pDPtree ctx);
static void	joinRule    (pDPtree ctx);
static SlotID	attribute    (pDPtree ctx);
static void	selectWP    (pDPtree ctx);
static void	joinWP    (pDPtree ctx);
static void	attributeList    (pDPtree ctx, SlotContainer& atts);
static void	aggregateWP    (pDPtree ctx);
static void	glaWP    (pDPtree ctx);
static void	printWP    (pDPtree ctx);
static void	connList    (pDPtree ctx);
static void	wayPointCN    (pDPtree ctx);
static void	textloaderWP    (pDPtree ctx);
static void	wpDefinition    (pDPtree ctx);
static string	expr    (pDPtree ctx, SlotContainer& atts, string& cstStr);
static DPtree_expression_return	expression    (pDPtree ctx, SlotContainer& atts, string& cstStr);
static void	DPtreeFree(pDPtree ctx);
static void     DPtreeReset (pDPtree ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "DPtree.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new DPtree parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pDPtree
DPtreeNew   (pANTLR3_COMMON_TREE_NODE_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return DPtreeNewSSD(instream, NULL);
}

/** \brief Create a new DPtree parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pDPtree
DPtreeNewSSD   (pANTLR3_COMMON_TREE_NODE_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pDPtree ctx;	    /* Context structure we will build and return   */
    
    ctx	= (pDPtree) ANTLR3_CALLOC(1, sizeof(DPtree));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in DPtree.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base Tree parser/recognizer, using the supplied tree node stream
     */
    ctx->pTreeParser		= antlr3TreeParserNewStream(ANTLR3_SIZE_HINT, instream, state);
    /* Install the implementation of our DPtree interface
     */
    ctx->parse	= parse;
    ctx->complexStatement	= complexStatement;
    ctx->runStmt	= runStmt;
    ctx->relationCR	= relationCR;
    ctx->lstArgsFc	= lstArgsFc;
    ctx->lstArgsGLA	= lstArgsGLA;
    ctx->dType	= dType;
    ctx->statement	= statement;
    ctx->writer	= writer;
    ctx->scanner	= scanner;
    ctx->waypoint	= waypoint;
    ctx->query	= query;
    ctx->qBodyStatement	= qBodyStatement;
    ctx->wpbodyStatement	= wpbodyStatement;
    ctx->bodyStatement	= bodyStatement;
    ctx->rules	= rules;
    ctx->filterRule	= filterRule;
    ctx->synthRule	= synthRule;
    ctx->aggregateRule	= aggregateRule;
    ctx->printRule	= printRule;
    ctx->printAtts	= printAtts;
    ctx->ctAttList	= ctAttList;
    ctx->ctAtt	= ctAtt;
    ctx->printFile	= printFile;
    ctx->glaDef	= glaDef;
    ctx->glaTemplate	= glaTemplate;
    ctx->glaTemplArg	= glaTemplArg;
    ctx->attWT	= attWT;
    ctx->attC	= attC;
    ctx->glaRule	= glaRule;
    ctx->attLWT	= attLWT;
    ctx->bypassRule	= bypassRule;
    ctx->joinRule	= joinRule;
    ctx->attribute	= attribute;
    ctx->selectWP	= selectWP;
    ctx->joinWP	= joinWP;
    ctx->attributeList	= attributeList;
    ctx->aggregateWP	= aggregateWP;
    ctx->glaWP	= glaWP;
    ctx->printWP	= printWP;
    ctx->connList	= connList;
    ctx->wayPointCN	= wayPointCN;
    ctx->textloaderWP	= textloaderWP;
    ctx->wpDefinition	= wpDefinition;
    ctx->expr	= expr;
    ctx->expression	= expression;
    ctx->free			= DPtreeFree;
    ctx->reset			= DPtreeReset;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */

        
    

	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = DPtreeTokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
DPtreeReset (pDPtree ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 DPtreeFree(pDPtree ctx)
 {
    /* Free any scope memory
     */
    
        
	// Free this parser
	//
    ctx->pTreeParser->free(ctx->pTreeParser);
    
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this tree parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return DPtreeTokenNames; 
}


    static LemonTranslator* lT = NULL; // this is a pointe to the lemon translator used
     //set by parse to be used by all
    static WayPointID wp; // this is the currect waypoint. If null, illegal to have a waypoint
     // related statement
    static WaypointType wpType = InvalidWaypoint; //type of above waypoint
    static QueryID qry; // current query. Empty means illegal ...

    static bool isNew = false; // is this a new anything.

     // attribute manager that does the translation from attributes to SlotID
     // when it starts it will define the attributes of all relations
    static AttributeManager& am = AttributeManager::GetAttributeManager();

     // get it ready for adding queries
    static QueryManager& qm = QueryManager::GetQueryManager();

     // get the datatype manager
    static DataTypeManager& dTM = DataTypeManager::GetDataTypeManager();

    // the catalog
    static Catalog& catalog = Catalog::GetCatalog();

    extern int tempCounter; // id for temporary variables}
    string StripQuotes(string str);
    string NormalizeQuotes(string str);
    string GenerateTemp(const char* pattern);


    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_complexStatement_in_parse63  */
static	ANTLR3_BITWORD FOLLOW_complexStatement_in_parse63_bits[]	= { ANTLR3_UINT64_LIT(0xCC00000000000002), ANTLR3_UINT64_LIT(0x0000000000F0083C) };
static  ANTLR3_BITSET_LIST FOLLOW_complexStatement_in_parse63	= { FOLLOW_complexStatement_in_parse63_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NEWSTATEMENT_in_complexStatement76  */
static	ANTLR3_BITWORD FOLLOW_NEWSTATEMENT_in_complexStatement76_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NEWSTATEMENT_in_complexStatement76	= { FOLLOW_NEWSTATEMENT_in_complexStatement76_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_complexStatement78  */
static	ANTLR3_BITWORD FOLLOW_statement_in_complexStatement78_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_complexStatement78	= { FOLLOW_statement_in_complexStatement78_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OLDSTATEMENT_in_complexStatement87  */
static	ANTLR3_BITWORD FOLLOW_OLDSTATEMENT_in_complexStatement87_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OLDSTATEMENT_in_complexStatement87	= { FOLLOW_OLDSTATEMENT_in_complexStatement87_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_complexStatement89  */
static	ANTLR3_BITWORD FOLLOW_statement_in_complexStatement89_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_complexStatement89	= { FOLLOW_statement_in_complexStatement89_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DELWAYPOINT_in_complexStatement98  */
static	ANTLR3_BITWORD FOLLOW_DELWAYPOINT_in_complexStatement98_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DELWAYPOINT_in_complexStatement98	= { FOLLOW_DELWAYPOINT_in_complexStatement98_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_complexStatement100  */
static	ANTLR3_BITWORD FOLLOW_ID_in_complexStatement100_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_complexStatement100	= { FOLLOW_ID_in_complexStatement100_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DELQUERY_in_complexStatement110  */
static	ANTLR3_BITWORD FOLLOW_DELQUERY_in_complexStatement110_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DELQUERY_in_complexStatement110	= { FOLLOW_DELQUERY_in_complexStatement110_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_complexStatement112  */
static	ANTLR3_BITWORD FOLLOW_ID_in_complexStatement112_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_complexStatement112	= { FOLLOW_ID_in_complexStatement112_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CRDATATYPE_in_complexStatement122  */
static	ANTLR3_BITWORD FOLLOW_CRDATATYPE_in_complexStatement122_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_CRDATATYPE_in_complexStatement122	= { FOLLOW_CRDATATYPE_in_complexStatement122_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_complexStatement124  */
static	ANTLR3_BITWORD FOLLOW_ID_in_complexStatement124_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_complexStatement124	= { FOLLOW_ID_in_complexStatement124_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_complexStatement128  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_complexStatement128_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_complexStatement128	= { FOLLOW_STRING_in_complexStatement128_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CRSYNONIM_in_complexStatement138  */
static	ANTLR3_BITWORD FOLLOW_CRSYNONIM_in_complexStatement138_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_CRSYNONIM_in_complexStatement138	= { FOLLOW_CRSYNONIM_in_complexStatement138_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_complexStatement142  */
static	ANTLR3_BITWORD FOLLOW_ID_in_complexStatement142_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_complexStatement142	= { FOLLOW_ID_in_complexStatement142_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_complexStatement146  */
static	ANTLR3_BITWORD FOLLOW_ID_in_complexStatement146_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_complexStatement146	= { FOLLOW_ID_in_complexStatement146_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FUNCTION_in_complexStatement156  */
static	ANTLR3_BITWORD FOLLOW_FUNCTION_in_complexStatement156_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_FUNCTION_in_complexStatement156	= { FOLLOW_FUNCTION_in_complexStatement156_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_complexStatement158  */
static	ANTLR3_BITWORD FOLLOW_ID_in_complexStatement158_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001020000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_complexStatement158	= { FOLLOW_ID_in_complexStatement158_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_complexStatement163  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_complexStatement163_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001020000) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_complexStatement163	= { FOLLOW_STRING_in_complexStatement163_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dType_in_complexStatement167  */
static	ANTLR3_BITWORD FOLLOW_dType_in_complexStatement167_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001020008) };
static  ANTLR3_BITSET_LIST FOLLOW_dType_in_complexStatement167	= { FOLLOW_dType_in_complexStatement167_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lstArgsFc_in_complexStatement169  */
static	ANTLR3_BITWORD FOLLOW_lstArgsFc_in_complexStatement169_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_lstArgsFc_in_complexStatement169	= { FOLLOW_lstArgsFc_in_complexStatement169_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPDEF_in_complexStatement178  */
static	ANTLR3_BITWORD FOLLOW_OPDEF_in_complexStatement178_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPDEF_in_complexStatement178	= { FOLLOW_OPDEF_in_complexStatement178_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_complexStatement182  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_complexStatement182_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001020000) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_complexStatement182	= { FOLLOW_STRING_in_complexStatement182_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_complexStatement187  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_complexStatement187_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001020000) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_complexStatement187	= { FOLLOW_STRING_in_complexStatement187_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dType_in_complexStatement191  */
static	ANTLR3_BITWORD FOLLOW_dType_in_complexStatement191_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001020008) };
static  ANTLR3_BITSET_LIST FOLLOW_dType_in_complexStatement191	= { FOLLOW_dType_in_complexStatement191_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lstArgsFc_in_complexStatement193  */
static	ANTLR3_BITWORD FOLLOW_lstArgsFc_in_complexStatement193_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_lstArgsFc_in_complexStatement193	= { FOLLOW_lstArgsFc_in_complexStatement193_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CRGLA_in_complexStatement202  */
static	ANTLR3_BITWORD FOLLOW_CRGLA_in_complexStatement202_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_CRGLA_in_complexStatement202	= { FOLLOW_CRGLA_in_complexStatement202_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_complexStatement204  */
static	ANTLR3_BITWORD FOLLOW_ID_in_complexStatement204_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000), ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_complexStatement204	= { FOLLOW_ID_in_complexStatement204_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_complexStatement209  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_complexStatement209_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_complexStatement209	= { FOLLOW_STRING_in_complexStatement209_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TPATT_in_complexStatement214  */
static	ANTLR3_BITWORD FOLLOW_TPATT_in_complexStatement214_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_TPATT_in_complexStatement214	= { FOLLOW_TPATT_in_complexStatement214_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lstArgsGLA_in_complexStatement219  */
static	ANTLR3_BITWORD FOLLOW_lstArgsGLA_in_complexStatement219_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_lstArgsGLA_in_complexStatement219	= { FOLLOW_lstArgsGLA_in_complexStatement219_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TPATT_in_complexStatement224  */
static	ANTLR3_BITWORD FOLLOW_TPATT_in_complexStatement224_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_TPATT_in_complexStatement224	= { FOLLOW_TPATT_in_complexStatement224_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lstArgsGLA_in_complexStatement229  */
static	ANTLR3_BITWORD FOLLOW_lstArgsGLA_in_complexStatement229_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_lstArgsGLA_in_complexStatement229	= { FOLLOW_lstArgsGLA_in_complexStatement229_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_relationCR_in_complexStatement240  */
static	ANTLR3_BITWORD FOLLOW_relationCR_in_complexStatement240_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_relationCR_in_complexStatement240	= { FOLLOW_relationCR_in_complexStatement240_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FLUSHTOKEN_in_complexStatement246  */
static	ANTLR3_BITWORD FOLLOW_FLUSHTOKEN_in_complexStatement246_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FLUSHTOKEN_in_complexStatement246	= { FOLLOW_FLUSHTOKEN_in_complexStatement246_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_runStmt_in_complexStatement254  */
static	ANTLR3_BITWORD FOLLOW_runStmt_in_complexStatement254_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_runStmt_in_complexStatement254	= { FOLLOW_runStmt_in_complexStatement254_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QUITTOKEN_in_complexStatement260  */
static	ANTLR3_BITWORD FOLLOW_QUITTOKEN_in_complexStatement260_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_QUITTOKEN_in_complexStatement260	= { FOLLOW_QUITTOKEN_in_complexStatement260_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RUN___in_runStmt284  */
static	ANTLR3_BITWORD FOLLOW_RUN___in_runStmt284_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_RUN___in_runStmt284	= { FOLLOW_RUN___in_runStmt284_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_runStmt287  */
static	ANTLR3_BITWORD FOLLOW_ID_in_runStmt287_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020008) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_runStmt287	= { FOLLOW_ID_in_runStmt287_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CRRELATION_in_relationCR315  */
static	ANTLR3_BITWORD FOLLOW_CRRELATION_in_relationCR315_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_CRRELATION_in_relationCR315	= { FOLLOW_CRRELATION_in_relationCR315_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_relationCR319  */
static	ANTLR3_BITWORD FOLLOW_ID_in_relationCR319_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_relationCR319	= { FOLLOW_ID_in_relationCR319_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TPATT_in_relationCR332  */
static	ANTLR3_BITWORD FOLLOW_TPATT_in_relationCR332_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_TPATT_in_relationCR332	= { FOLLOW_TPATT_in_relationCR332_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_relationCR336  */
static	ANTLR3_BITWORD FOLLOW_ID_in_relationCR336_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_relationCR336	= { FOLLOW_ID_in_relationCR336_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_relationCR340  */
static	ANTLR3_BITWORD FOLLOW_ID_in_relationCR340_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_relationCR340	= { FOLLOW_ID_in_relationCR340_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dType_in_lstArgsFc380  */
static	ANTLR3_BITWORD FOLLOW_dType_in_lstArgsFc380_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001020002) };
static  ANTLR3_BITSET_LIST FOLLOW_dType_in_lstArgsFc380	= { FOLLOW_dType_in_lstArgsFc380_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dType_in_lstArgsGLA406  */
static	ANTLR3_BITWORD FOLLOW_dType_in_lstArgsGLA406_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001020002) };
static  ANTLR3_BITSET_LIST FOLLOW_dType_in_lstArgsGLA406	= { FOLLOW_dType_in_lstArgsGLA406_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dType_in_lstArgsGLA414  */
static	ANTLR3_BITWORD FOLLOW_dType_in_lstArgsGLA414_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001020002) };
static  ANTLR3_BITSET_LIST FOLLOW_dType_in_lstArgsGLA414	= { FOLLOW_dType_in_lstArgsGLA414_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_dType437  */
static	ANTLR3_BITWORD FOLLOW_ID_in_dType437_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_dType437	= { FOLLOW_ID_in_dType437_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_scanner_in_statement458  */
static	ANTLR3_BITWORD FOLLOW_scanner_in_statement458_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_scanner_in_statement458	= { FOLLOW_scanner_in_statement458_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_waypoint_in_statement466  */
static	ANTLR3_BITWORD FOLLOW_waypoint_in_statement466_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_waypoint_in_statement466	= { FOLLOW_waypoint_in_statement466_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_query_in_statement475  */
static	ANTLR3_BITWORD FOLLOW_query_in_statement475_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_query_in_statement475	= { FOLLOW_query_in_statement475_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_writer_in_statement483  */
static	ANTLR3_BITWORD FOLLOW_writer_in_statement483_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_writer_in_statement483	= { FOLLOW_writer_in_statement483_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WRITER___in_writer501  */
static	ANTLR3_BITWORD FOLLOW_WRITER___in_writer501_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_WRITER___in_writer501	= { FOLLOW_WRITER___in_writer501_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_writer505  */
static	ANTLR3_BITWORD FOLLOW_ID_in_writer505_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_writer505	= { FOLLOW_ID_in_writer505_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_writer509  */
static	ANTLR3_BITWORD FOLLOW_ID_in_writer509_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000), ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_writer509	= { FOLLOW_ID_in_writer509_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_connList_in_writer513  */
static	ANTLR3_BITWORD FOLLOW_connList_in_writer513_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_connList_in_writer513	= { FOLLOW_connList_in_writer513_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SCANNER___in_scanner544  */
static	ANTLR3_BITWORD FOLLOW_SCANNER___in_scanner544_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_SCANNER___in_scanner544	= { FOLLOW_SCANNER___in_scanner544_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_scanner548  */
static	ANTLR3_BITWORD FOLLOW_ID_in_scanner548_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020008) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_scanner548	= { FOLLOW_ID_in_scanner548_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_scanner567  */
static	ANTLR3_BITWORD FOLLOW_ID_in_scanner567_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_scanner567	= { FOLLOW_ID_in_scanner567_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WAYPOINT___in_waypoint596  */
static	ANTLR3_BITWORD FOLLOW_WAYPOINT___in_waypoint596_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_WAYPOINT___in_waypoint596	= { FOLLOW_WAYPOINT___in_waypoint596_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_waypoint598  */
static	ANTLR3_BITWORD FOLLOW_ID_in_waypoint598_bits[]	= { ANTLR3_UINT64_LIT(0x00000000000001E8), ANTLR3_UINT64_LIT(0x0000004002005000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_waypoint598	= { FOLLOW_ID_in_waypoint598_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_wpDefinition_in_waypoint603  */
static	ANTLR3_BITWORD FOLLOW_wpDefinition_in_waypoint603_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008), ANTLR3_UINT64_LIT(0x0000004000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_wpDefinition_in_waypoint603	= { FOLLOW_wpDefinition_in_waypoint603_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bypassRule_in_waypoint606  */
static	ANTLR3_BITWORD FOLLOW_bypassRule_in_waypoint606_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008), ANTLR3_UINT64_LIT(0x0000004000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_bypassRule_in_waypoint606	= { FOLLOW_bypassRule_in_waypoint606_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_wpbodyStatement_in_waypoint609  */
static	ANTLR3_BITWORD FOLLOW_wpbodyStatement_in_waypoint609_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_wpbodyStatement_in_waypoint609	= { FOLLOW_wpbodyStatement_in_waypoint609_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QUERRY___in_query631  */
static	ANTLR3_BITWORD FOLLOW_QUERRY___in_query631_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_QUERRY___in_query631	= { FOLLOW_QUERRY___in_query631_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_query634  */
static	ANTLR3_BITWORD FOLLOW_ID_in_query634_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020008), ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_query634	= { FOLLOW_ID_in_query634_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qBodyStatement_in_query641  */
static	ANTLR3_BITWORD FOLLOW_qBodyStatement_in_query641_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008), ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_qBodyStatement_in_query641	= { FOLLOW_qBodyStatement_in_query641_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WAYPOINT___in_qBodyStatement664  */
static	ANTLR3_BITWORD FOLLOW_WAYPOINT___in_qBodyStatement664_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_WAYPOINT___in_qBodyStatement664	= { FOLLOW_WAYPOINT___in_qBodyStatement664_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_qBodyStatement666  */
static	ANTLR3_BITWORD FOLLOW_ID_in_qBodyStatement666_bits[]	= { ANTLR3_UINT64_LIT(0x00000000000001F8), ANTLR3_UINT64_LIT(0x0000002000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_qBodyStatement666	= { FOLLOW_ID_in_qBodyStatement666_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bodyStatement_in_qBodyStatement671  */
static	ANTLR3_BITWORD FOLLOW_bodyStatement_in_qBodyStatement671_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_bodyStatement_in_qBodyStatement671	= { FOLLOW_bodyStatement_in_qBodyStatement671_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QUERRY___in_wpbodyStatement688  */
static	ANTLR3_BITWORD FOLLOW_QUERRY___in_wpbodyStatement688_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_QUERRY___in_wpbodyStatement688	= { FOLLOW_QUERRY___in_wpbodyStatement688_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_wpbodyStatement690  */
static	ANTLR3_BITWORD FOLLOW_ID_in_wpbodyStatement690_bits[]	= { ANTLR3_UINT64_LIT(0x00000000000001F8), ANTLR3_UINT64_LIT(0x0000002000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_wpbodyStatement690	= { FOLLOW_ID_in_wpbodyStatement690_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bodyStatement_in_wpbodyStatement694  */
static	ANTLR3_BITWORD FOLLOW_bodyStatement_in_wpbodyStatement694_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_bodyStatement_in_wpbodyStatement694	= { FOLLOW_bodyStatement_in_wpbodyStatement694_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rules_in_bodyStatement711  */
static	ANTLR3_BITWORD FOLLOW_rules_in_bodyStatement711_bits[]	= { ANTLR3_UINT64_LIT(0x00000000000001F2), ANTLR3_UINT64_LIT(0x0000002000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_rules_in_bodyStatement711	= { FOLLOW_rules_in_bodyStatement711_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_filterRule_in_rules727  */
static	ANTLR3_BITWORD FOLLOW_filterRule_in_rules727_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_filterRule_in_rules727	= { FOLLOW_filterRule_in_rules727_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_synthRule_in_rules733  */
static	ANTLR3_BITWORD FOLLOW_synthRule_in_rules733_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_synthRule_in_rules733	= { FOLLOW_synthRule_in_rules733_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_aggregateRule_in_rules739  */
static	ANTLR3_BITWORD FOLLOW_aggregateRule_in_rules739_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_aggregateRule_in_rules739	= { FOLLOW_aggregateRule_in_rules739_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printRule_in_rules745  */
static	ANTLR3_BITWORD FOLLOW_printRule_in_rules745_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_printRule_in_rules745	= { FOLLOW_printRule_in_rules745_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_joinRule_in_rules751  */
static	ANTLR3_BITWORD FOLLOW_joinRule_in_rules751_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_joinRule_in_rules751	= { FOLLOW_joinRule_in_rules751_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_glaRule_in_rules757  */
static	ANTLR3_BITWORD FOLLOW_glaRule_in_rules757_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_glaRule_in_rules757	= { FOLLOW_glaRule_in_rules757_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FILTER_in_filterRule781  */
static	ANTLR3_BITWORD FOLLOW_FILTER_in_filterRule781_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_FILTER_in_filterRule781	= { FOLLOW_FILTER_in_filterRule781_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_filterRule783  */
static	ANTLR3_BITWORD FOLLOW_expr_in_filterRule783_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_filterRule783	= { FOLLOW_expr_in_filterRule783_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SYNTHESIZE_in_synthRule812  */
static	ANTLR3_BITWORD FOLLOW_SYNTHESIZE_in_synthRule812_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_SYNTHESIZE_in_synthRule812	= { FOLLOW_SYNTHESIZE_in_synthRule812_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_synthRule816  */
static	ANTLR3_BITWORD FOLLOW_ID_in_synthRule816_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_synthRule816	= { FOLLOW_ID_in_synthRule816_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_synthRule820  */
static	ANTLR3_BITWORD FOLLOW_ID_in_synthRule820_bits[]	= { ANTLR3_UINT64_LIT(0x600000000115C000), ANTLR3_UINT64_LIT(0x0000008000000003) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_synthRule820	= { FOLLOW_ID_in_synthRule820_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_synthRule822  */
static	ANTLR3_BITWORD FOLLOW_expr_in_synthRule822_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_synthRule822	= { FOLLOW_expr_in_synthRule822_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AGGREGATE_in_aggregateRule851  */
static	ANTLR3_BITWORD FOLLOW_AGGREGATE_in_aggregateRule851_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_AGGREGATE_in_aggregateRule851	= { FOLLOW_AGGREGATE_in_aggregateRule851_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_aggregateRule855  */
static	ANTLR3_BITWORD FOLLOW_ID_in_aggregateRule855_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_aggregateRule855	= { FOLLOW_ID_in_aggregateRule855_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_aggregateRule859  */
static	ANTLR3_BITWORD FOLLOW_ID_in_aggregateRule859_bits[]	= { ANTLR3_UINT64_LIT(0x600000000115C000), ANTLR3_UINT64_LIT(0x0000008000000003) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_aggregateRule859	= { FOLLOW_ID_in_aggregateRule859_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_aggregateRule861  */
static	ANTLR3_BITWORD FOLLOW_expr_in_aggregateRule861_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_aggregateRule861	= { FOLLOW_expr_in_aggregateRule861_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PRINT_in_printRule890  */
static	ANTLR3_BITWORD FOLLOW_PRINT_in_printRule890_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_PRINT_in_printRule890	= { FOLLOW_PRINT_in_printRule890_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_printRule892  */
static	ANTLR3_BITWORD FOLLOW_expr_in_printRule892_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008), ANTLR3_UINT64_LIT(0x0000000000080200) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_printRule892	= { FOLLOW_expr_in_printRule892_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printAtts_in_printRule895  */
static	ANTLR3_BITWORD FOLLOW_printAtts_in_printRule895_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_printAtts_in_printRule895	= { FOLLOW_printAtts_in_printRule895_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printFile_in_printRule898  */
static	ANTLR3_BITWORD FOLLOW_printFile_in_printRule898_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_printFile_in_printRule898	= { FOLLOW_printFile_in_printRule898_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTWT_in_printAtts927  */
static	ANTLR3_BITWORD FOLLOW_ATTWT_in_printAtts927_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTWT_in_printAtts927	= { FOLLOW_ATTWT_in_printAtts927_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_printAtts931  */
static	ANTLR3_BITWORD FOLLOW_ID_in_printAtts931_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_printAtts931	= { FOLLOW_ID_in_printAtts931_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_printAtts935  */
static	ANTLR3_BITWORD FOLLOW_ID_in_printAtts935_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_printAtts935	= { FOLLOW_ID_in_printAtts935_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTWT_in_printAtts949  */
static	ANTLR3_BITWORD FOLLOW_ATTWT_in_printAtts949_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTWT_in_printAtts949	= { FOLLOW_ATTWT_in_printAtts949_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_printAtts953  */
static	ANTLR3_BITWORD FOLLOW_ID_in_printAtts953_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_printAtts953	= { FOLLOW_ID_in_printAtts953_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_printAtts957  */
static	ANTLR3_BITWORD FOLLOW_ID_in_printAtts957_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_printAtts957	= { FOLLOW_ID_in_printAtts957_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ctAtt_in_ctAttList991  */
static	ANTLR3_BITWORD FOLLOW_ctAtt_in_ctAttList991_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001140002) };
static  ANTLR3_BITSET_LIST FOLLOW_ctAtt_in_ctAttList991	= { FOLLOW_ctAtt_in_ctAttList991_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ctAtt_in_ctAttList998  */
static	ANTLR3_BITWORD FOLLOW_ctAtt_in_ctAttList998_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001140002) };
static  ANTLR3_BITSET_LIST FOLLOW_ctAtt_in_ctAttList998	= { FOLLOW_ctAtt_in_ctAttList998_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_ctAtt1027  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_ctAtt1027_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_ctAtt1027	= { FOLLOW_STRING_in_ctAtt1027_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INT_in_ctAtt1033  */
static	ANTLR3_BITWORD FOLLOW_INT_in_ctAtt1033_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INT_in_ctAtt1033	= { FOLLOW_INT_in_ctAtt1033_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FLOAT_in_ctAtt1039  */
static	ANTLR3_BITWORD FOLLOW_FLOAT_in_ctAtt1039_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FLOAT_in_ctAtt1039	= { FOLLOW_FLOAT_in_ctAtt1039_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LIST_in_printFile1069  */
static	ANTLR3_BITWORD FOLLOW_LIST_in_printFile1069_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LIST_in_printFile1069	= { FOLLOW_LIST_in_printFile1069_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_printFile1073  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_printFile1073_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_printFile1073	= { FOLLOW_STRING_in_printFile1073_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_glaDef1098  */
static	ANTLR3_BITWORD FOLLOW_ID_in_glaDef1098_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_glaDef1098	= { FOLLOW_ID_in_glaDef1098_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_glaTemplate_in_glaDef1102  */
static	ANTLR3_BITWORD FOLLOW_glaTemplate_in_glaDef1102_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_glaTemplate_in_glaDef1102	= { FOLLOW_glaTemplate_in_glaDef1102_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GLATEMPLATE_in_glaTemplate1135  */
static	ANTLR3_BITWORD FOLLOW_GLATEMPLATE_in_glaTemplate1135_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_GLATEMPLATE_in_glaTemplate1135	= { FOLLOW_GLATEMPLATE_in_glaTemplate1135_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_glaTemplArg_in_glaTemplate1141  */
static	ANTLR3_BITWORD FOLLOW_glaTemplArg_in_glaTemplate1141_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001140048), ANTLR3_UINT64_LIT(0x0000000000080200) };
static  ANTLR3_BITSET_LIST FOLLOW_glaTemplArg_in_glaTemplate1141	= { FOLLOW_glaTemplArg_in_glaTemplate1141_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LIST_in_glaTemplArg1176  */
static	ANTLR3_BITWORD FOLLOW_LIST_in_glaTemplArg1176_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LIST_in_glaTemplArg1176	= { FOLLOW_LIST_in_glaTemplArg1176_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attC_in_glaTemplArg1180  */
static	ANTLR3_BITWORD FOLLOW_attC_in_glaTemplArg1180_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008), ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_attC_in_glaTemplArg1180	= { FOLLOW_attC_in_glaTemplArg1180_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attC_in_glaTemplArg1186  */
static	ANTLR3_BITWORD FOLLOW_attC_in_glaTemplArg1186_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008), ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_attC_in_glaTemplArg1186	= { FOLLOW_attC_in_glaTemplArg1186_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attWT_in_glaTemplArg1200  */
static	ANTLR3_BITWORD FOLLOW_attWT_in_glaTemplArg1200_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_attWT_in_glaTemplArg1200	= { FOLLOW_attWT_in_glaTemplArg1200_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GLA_in_glaTemplArg1211  */
static	ANTLR3_BITWORD FOLLOW_GLA_in_glaTemplArg1211_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_GLA_in_glaTemplArg1211	= { FOLLOW_GLA_in_glaTemplArg1211_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_glaDef_in_glaTemplArg1213  */
static	ANTLR3_BITWORD FOLLOW_glaDef_in_glaTemplArg1213_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_glaDef_in_glaTemplArg1213	= { FOLLOW_glaDef_in_glaTemplArg1213_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_glaTemplArg1225  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_glaTemplArg1225_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_glaTemplArg1225	= { FOLLOW_STRING_in_glaTemplArg1225_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INT_in_glaTemplArg1237  */
static	ANTLR3_BITWORD FOLLOW_INT_in_glaTemplArg1237_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INT_in_glaTemplArg1237	= { FOLLOW_INT_in_glaTemplArg1237_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FLOAT_in_glaTemplArg1249  */
static	ANTLR3_BITWORD FOLLOW_FLOAT_in_glaTemplArg1249_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FLOAT_in_glaTemplArg1249	= { FOLLOW_FLOAT_in_glaTemplArg1249_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTWT_in_attWT1270  */
static	ANTLR3_BITWORD FOLLOW_ATTWT_in_attWT1270_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTWT_in_attWT1270	= { FOLLOW_ATTWT_in_attWT1270_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_attWT1274  */
static	ANTLR3_BITWORD FOLLOW_ID_in_attWT1274_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_attWT1274	= { FOLLOW_ID_in_attWT1274_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_attWT1278  */
static	ANTLR3_BITWORD FOLLOW_ID_in_attWT1278_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_attWT1278	= { FOLLOW_ID_in_attWT1278_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTC_in_attC1300  */
static	ANTLR3_BITWORD FOLLOW_ATTC_in_attC1300_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTC_in_attC1300	= { FOLLOW_ATTC_in_attC1300_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_attC1307  */
static	ANTLR3_BITWORD FOLLOW_ID_in_attC1307_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020008) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_attC1307	= { FOLLOW_ID_in_attC1307_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_attC1327  */
static	ANTLR3_BITWORD FOLLOW_ID_in_attC1327_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020008) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_attC1327	= { FOLLOW_ID_in_attC1327_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GLA_in_glaRule1371  */
static	ANTLR3_BITWORD FOLLOW_GLA_in_glaRule1371_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_GLA_in_glaRule1371	= { FOLLOW_GLA_in_glaRule1371_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PLUS_in_glaRule1374  */
static	ANTLR3_BITWORD FOLLOW_PLUS_in_glaRule1374_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001160000) };
static  ANTLR3_BITSET_LIST FOLLOW_PLUS_in_glaRule1374	= { FOLLOW_PLUS_in_glaRule1374_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ctAttList_in_glaRule1380  */
static	ANTLR3_BITWORD FOLLOW_ctAttList_in_glaRule1380_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_ctAttList_in_glaRule1380	= { FOLLOW_ctAttList_in_glaRule1380_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_glaDef_in_glaRule1383  */
static	ANTLR3_BITWORD FOLLOW_glaDef_in_glaRule1383_bits[]	= { ANTLR3_UINT64_LIT(0x600000000115C008), ANTLR3_UINT64_LIT(0x0000000000000203) };
static  ANTLR3_BITSET_LIST FOLLOW_glaDef_in_glaRule1383	= { FOLLOW_glaDef_in_glaRule1383_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attLWT_in_glaRule1385  */
static	ANTLR3_BITWORD FOLLOW_attLWT_in_glaRule1385_bits[]	= { ANTLR3_UINT64_LIT(0x600000000115C008), ANTLR3_UINT64_LIT(0x0000000000000203) };
static  ANTLR3_BITSET_LIST FOLLOW_attLWT_in_glaRule1385	= { FOLLOW_attLWT_in_glaRule1385_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_glaRule1392  */
static	ANTLR3_BITWORD FOLLOW_expression_in_glaRule1392_bits[]	= { ANTLR3_UINT64_LIT(0x600000000115C008), ANTLR3_UINT64_LIT(0x0000000000000003) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_glaRule1392	= { FOLLOW_expression_in_glaRule1392_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTWT_in_attLWT1420  */
static	ANTLR3_BITWORD FOLLOW_ATTWT_in_attLWT1420_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTWT_in_attLWT1420	= { FOLLOW_ATTWT_in_attLWT1420_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_attLWT1424  */
static	ANTLR3_BITWORD FOLLOW_ID_in_attLWT1424_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_attLWT1424	= { FOLLOW_ID_in_attLWT1424_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_attLWT1428  */
static	ANTLR3_BITWORD FOLLOW_ID_in_attLWT1428_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_attLWT1428	= { FOLLOW_ID_in_attLWT1428_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BYPASS_in_bypassRule1449  */
static	ANTLR3_BITWORD FOLLOW_BYPASS_in_bypassRule1449_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BYPASS_in_bypassRule1449	= { FOLLOW_BYPASS_in_bypassRule1449_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_bypassRule1451  */
static	ANTLR3_BITWORD FOLLOW_ID_in_bypassRule1451_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_bypassRule1451	= { FOLLOW_ID_in_bypassRule1451_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_JOIN_in_joinRule1479  */
static	ANTLR3_BITWORD FOLLOW_JOIN_in_joinRule1479_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_JOIN_in_joinRule1479	= { FOLLOW_JOIN_in_joinRule1479_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attributeList_in_joinRule1481  */
static	ANTLR3_BITWORD FOLLOW_attributeList_in_joinRule1481_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_attributeList_in_joinRule1481	= { FOLLOW_attributeList_in_joinRule1481_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATT_in_attribute1510  */
static	ANTLR3_BITWORD FOLLOW_ATT_in_attribute1510_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ATT_in_attribute1510	= { FOLLOW_ATT_in_attribute1510_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SELECT___in_selectWP1534  */
static	ANTLR3_BITWORD FOLLOW_SELECT___in_selectWP1534_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_SELECT___in_selectWP1534	= { FOLLOW_SELECT___in_selectWP1534_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_connList_in_selectWP1539  */
static	ANTLR3_BITWORD FOLLOW_connList_in_selectWP1539_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_connList_in_selectWP1539	= { FOLLOW_connList_in_selectWP1539_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_JOIN_in_joinWP1564  */
static	ANTLR3_BITWORD FOLLOW_JOIN_in_joinWP1564_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_JOIN_in_joinWP1564	= { FOLLOW_JOIN_in_joinWP1564_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attributeList_in_joinWP1566  */
static	ANTLR3_BITWORD FOLLOW_attributeList_in_joinWP1566_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000), ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_attributeList_in_joinWP1566	= { FOLLOW_attributeList_in_joinWP1566_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_connList_in_joinWP1571  */
static	ANTLR3_BITWORD FOLLOW_connList_in_joinWP1571_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_connList_in_joinWP1571	= { FOLLOW_connList_in_joinWP1571_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTS_in_attributeList1587  */
static	ANTLR3_BITWORD FOLLOW_ATTS_in_attributeList1587_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTS_in_attributeList1587	= { FOLLOW_ATTS_in_attributeList1587_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attribute_in_attributeList1592  */
static	ANTLR3_BITWORD FOLLOW_attribute_in_attributeList1592_bits[]	= { ANTLR3_UINT64_LIT(0x2000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_attribute_in_attributeList1592	= { FOLLOW_attribute_in_attributeList1592_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AGGREGATE_in_aggregateWP1613  */
static	ANTLR3_BITWORD FOLLOW_AGGREGATE_in_aggregateWP1613_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_AGGREGATE_in_aggregateWP1613	= { FOLLOW_AGGREGATE_in_aggregateWP1613_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_connList_in_aggregateWP1623  */
static	ANTLR3_BITWORD FOLLOW_connList_in_aggregateWP1623_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_connList_in_aggregateWP1623	= { FOLLOW_connList_in_aggregateWP1623_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GLA_in_glaWP1650  */
static	ANTLR3_BITWORD FOLLOW_GLA_in_glaWP1650_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_GLA_in_glaWP1650	= { FOLLOW_GLA_in_glaWP1650_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PLUS_in_glaWP1653  */
static	ANTLR3_BITWORD FOLLOW_PLUS_in_glaWP1653_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000), ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_PLUS_in_glaWP1653	= { FOLLOW_PLUS_in_glaWP1653_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_connList_in_glaWP1667  */
static	ANTLR3_BITWORD FOLLOW_connList_in_glaWP1667_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_connList_in_glaWP1667	= { FOLLOW_connList_in_glaWP1667_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PRINT_in_printWP1688  */
static	ANTLR3_BITWORD FOLLOW_PRINT_in_printWP1688_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_PRINT_in_printWP1688	= { FOLLOW_PRINT_in_printWP1688_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_connList_in_printWP1698  */
static	ANTLR3_BITWORD FOLLOW_connList_in_printWP1698_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_connList_in_printWP1698	= { FOLLOW_connList_in_printWP1698_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_wayPointCN_in_connList1715  */
static	ANTLR3_BITWORD FOLLOW_wayPointCN_in_connList1715_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020002), ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_wayPointCN_in_connList1715	= { FOLLOW_wayPointCN_in_connList1715_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_wayPointCN1736  */
static	ANTLR3_BITWORD FOLLOW_ID_in_wayPointCN1736_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_wayPointCN1736	= { FOLLOW_ID_in_wayPointCN1736_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TERMCONN_in_wayPointCN1746  */
static	ANTLR3_BITWORD FOLLOW_TERMCONN_in_wayPointCN1746_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_TERMCONN_in_wayPointCN1746	= { FOLLOW_TERMCONN_in_wayPointCN1746_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_wayPointCN1748  */
static	ANTLR3_BITWORD FOLLOW_ID_in_wayPointCN1748_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_wayPointCN1748	= { FOLLOW_ID_in_wayPointCN1748_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TEXTLOADER___in_textloaderWP1779  */
static	ANTLR3_BITWORD FOLLOW_TEXTLOADER___in_textloaderWP1779_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_TEXTLOADER___in_textloaderWP1779	= { FOLLOW_TEXTLOADER___in_textloaderWP1779_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTFROM_in_textloaderWP1792  */
static	ANTLR3_BITWORD FOLLOW_ATTFROM_in_textloaderWP1792_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTFROM_in_textloaderWP1792	= { FOLLOW_ATTFROM_in_textloaderWP1792_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_textloaderWP1794  */
static	ANTLR3_BITWORD FOLLOW_ID_in_textloaderWP1794_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_textloaderWP1794	= { FOLLOW_ID_in_textloaderWP1794_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEPARATOR_in_textloaderWP1804  */
static	ANTLR3_BITWORD FOLLOW_SEPARATOR_in_textloaderWP1804_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_SEPARATOR_in_textloaderWP1804	= { FOLLOW_SEPARATOR_in_textloaderWP1804_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_textloaderWP1808  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_textloaderWP1808_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_textloaderWP1808	= { FOLLOW_STRING_in_textloaderWP1808_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FILE___in_textloaderWP1818  */
static	ANTLR3_BITWORD FOLLOW_FILE___in_textloaderWP1818_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_FILE___in_textloaderWP1818	= { FOLLOW_FILE___in_textloaderWP1818_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_textloaderWP1822  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_textloaderWP1822_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040008) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_textloaderWP1822	= { FOLLOW_STRING_in_textloaderWP1822_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INT_in_textloaderWP1827  */
static	ANTLR3_BITWORD FOLLOW_INT_in_textloaderWP1827_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_INT_in_textloaderWP1827	= { FOLLOW_INT_in_textloaderWP1827_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_selectWP_in_wpDefinition1851  */
static	ANTLR3_BITWORD FOLLOW_selectWP_in_wpDefinition1851_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_selectWP_in_wpDefinition1851	= { FOLLOW_selectWP_in_wpDefinition1851_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_joinWP_in_wpDefinition1859  */
static	ANTLR3_BITWORD FOLLOW_joinWP_in_wpDefinition1859_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_joinWP_in_wpDefinition1859	= { FOLLOW_joinWP_in_wpDefinition1859_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_aggregateWP_in_wpDefinition1867  */
static	ANTLR3_BITWORD FOLLOW_aggregateWP_in_wpDefinition1867_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_aggregateWP_in_wpDefinition1867	= { FOLLOW_aggregateWP_in_wpDefinition1867_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printWP_in_wpDefinition1875  */
static	ANTLR3_BITWORD FOLLOW_printWP_in_wpDefinition1875_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_printWP_in_wpDefinition1875	= { FOLLOW_printWP_in_wpDefinition1875_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_textloaderWP_in_wpDefinition1883  */
static	ANTLR3_BITWORD FOLLOW_textloaderWP_in_wpDefinition1883_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_textloaderWP_in_wpDefinition1883	= { FOLLOW_textloaderWP_in_wpDefinition1883_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_glaWP_in_wpDefinition1891  */
static	ANTLR3_BITWORD FOLLOW_glaWP_in_wpDefinition1891_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_glaWP_in_wpDefinition1891	= { FOLLOW_glaWP_in_wpDefinition1891_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expr1914  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expr1914_bits[]	= { ANTLR3_UINT64_LIT(0x600000000115C002), ANTLR3_UINT64_LIT(0x0000000000000003) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expr1914	= { FOLLOW_expression_in_expr1914_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expr1928  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expr1928_bits[]	= { ANTLR3_UINT64_LIT(0x600000000115C002), ANTLR3_UINT64_LIT(0x0000000000000003) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expr1928	= { FOLLOW_expression_in_expr1928_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_103_in_expr1944  */
static	ANTLR3_BITWORD FOLLOW_103_in_expr1944_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_103_in_expr1944	= { FOLLOW_103_in_expr1944_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expr1948  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expr1948_bits[]	= { ANTLR3_UINT64_LIT(0x600000000115C000), ANTLR3_UINT64_LIT(0x0000000000000003) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expr1948	= { FOLLOW_expression_in_expr1948_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expr1955  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expr1955_bits[]	= { ANTLR3_UINT64_LIT(0x600000000115C000), ANTLR3_UINT64_LIT(0x0000000000000003) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expr1955	= { FOLLOW_expression_in_expr1955_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expr1962  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expr1962_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expr1962	= { FOLLOW_expression_in_expr1962_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_in_expression1997  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_in_expression1997_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_in_expression1997	= { FOLLOW_OPERATOR_in_expression1997_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression2001  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression2001_bits[]	= { ANTLR3_UINT64_LIT(0x600000000115C000), ANTLR3_UINT64_LIT(0x0000000000000003) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression2001	= { FOLLOW_expression_in_expression2001_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression2014  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression2014_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression2014	= { FOLLOW_expression_in_expression2014_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UOPERATOR_in_expression2031  */
static	ANTLR3_BITWORD FOLLOW_UOPERATOR_in_expression2031_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_UOPERATOR_in_expression2031	= { FOLLOW_UOPERATOR_in_expression2031_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression2035  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression2035_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression2035	= { FOLLOW_expression_in_expression2035_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FUNCTION_in_expression2052  */
static	ANTLR3_BITWORD FOLLOW_FUNCTION_in_expression2052_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_FUNCTION_in_expression2052	= { FOLLOW_FUNCTION_in_expression2052_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_expression2054  */
static	ANTLR3_BITWORD FOLLOW_ID_in_expression2054_bits[]	= { ANTLR3_UINT64_LIT(0x600000000115C008), ANTLR3_UINT64_LIT(0x0000000000000003) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_expression2054	= { FOLLOW_ID_in_expression2054_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression2060  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression2060_bits[]	= { ANTLR3_UINT64_LIT(0x600000000115C008), ANTLR3_UINT64_LIT(0x0000000000000003) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression2060	= { FOLLOW_expression_in_expression2060_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MATCH_DP_in_expression2079  */
static	ANTLR3_BITWORD FOLLOW_MATCH_DP_in_expression2079_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_MATCH_DP_in_expression2079	= { FOLLOW_MATCH_DP_in_expression2079_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_expression2083  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_expression2083_bits[]	= { ANTLR3_UINT64_LIT(0x600000000115C000), ANTLR3_UINT64_LIT(0x0000000000000003) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_expression2083	= { FOLLOW_STRING_in_expression2083_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression2087  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression2087_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression2087	= { FOLLOW_expression_in_expression2087_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CASE_DP_in_expression2104  */
static	ANTLR3_BITWORD FOLLOW_CASE_DP_in_expression2104_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_CASE_DP_in_expression2104	= { FOLLOW_CASE_DP_in_expression2104_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression2109  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression2109_bits[]	= { ANTLR3_UINT64_LIT(0x600000000115C008), ANTLR3_UINT64_LIT(0x0000000000000003) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression2109	= { FOLLOW_expression_in_expression2109_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATT_in_expression2128  */
static	ANTLR3_BITWORD FOLLOW_ATT_in_expression2128_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ATT_in_expression2128	= { FOLLOW_ATT_in_expression2128_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INT_in_expression2136  */
static	ANTLR3_BITWORD FOLLOW_INT_in_expression2136_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INT_in_expression2136	= { FOLLOW_INT_in_expression2136_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BOOL_T_in_expression2142  */
static	ANTLR3_BITWORD FOLLOW_BOOL_T_in_expression2142_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BOOL_T_in_expression2142	= { FOLLOW_BOOL_T_in_expression2142_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_expression2151  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_expression2151_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_expression2151	= { FOLLOW_STRING_in_expression2151_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FLOAT_in_expression2160  */
static	ANTLR3_BITWORD FOLLOW_FLOAT_in_expression2160_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FLOAT_in_expression2160	= { FOLLOW_FLOAT_in_expression2160_bits, 1	};
     

 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start parse
 * DPtree.g:80:1: parse[LemonTranslator* trans] : ( complexStatement )+ ;
 */
static void
parse(pDPtree ctx, LemonTranslator* trans)
{   
    /* Initialize rule variables
     */


    {
        // DPtree.g:80:31: ( ( complexStatement )+ )
        // DPtree.g:80:33: ( complexStatement )+
        {
            {

                      lT = trans;
                    
            }
            // DPtree.g:82:7: ( complexStatement )+
            {
                int cnt1=0;

                for (;;)
                {
                    int alt1=2;
            	switch ( LA(1) ) 
            	{
            	case NEWSTATEMENT:
            	case OLDSTATEMENT:
            	case FUNCTION:
            	case OPDEF:
            	case DELWAYPOINT:
            	case DELQUERY:
            	case CRDATATYPE:
            	case CRSYNONIM:
            	case RUN__:
            	case CRGLA:
            	case CRRELATION:
            	case FLUSHTOKEN:
            	case QUITTOKEN:
            		{
            			alt1=1;
            		}
            	    break;

            	}

            	switch (alt1) 
            	{
            	    case 1:
            	        // DPtree.g:82:7: complexStatement
            	        {
            	            FOLLOWPUSH(FOLLOW_complexStatement_in_parse63);
            	            complexStatement(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleparseEx;
            	            }


            	        }
            	        break;

            	    default:
            	    
            		if ( cnt1 >= 1 )
            		{
            		    goto loop1;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleparseEx;
            	}
            	cnt1++;
                }
                loop1: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleparseEx; /* Prevent compiler warnings */
    ruleparseEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end parse */

/** 
 * $ANTLR start complexStatement
 * DPtree.g:84:1: complexStatement : ( ^( NEWSTATEMENT statement[true] ) | ^( OLDSTATEMENT statement[false] ) | ^( DELWAYPOINT ID ) | ^( DELQUERY ID ) | ^( CRDATATYPE ID s= STRING ) | ^( CRSYNONIM tp= ID s= ID ) | ^( FUNCTION ID (s= STRING )? dType lstArgsFc ) | ^( OPDEF n= STRING (s= STRING )? dType lstArgsFc ) | ^( CRGLA ID (s= STRING )? ^( TPATT (ret= lstArgsGLA ) ) ^( TPATT (args= lstArgsGLA ) ) ) | relationCR | FLUSHTOKEN | runStmt | QUITTOKEN );
 */
static void
complexStatement(pDPtree ctx)
{   
    pANTLR3_BASE_TREE    s;
    pANTLR3_BASE_TREE    tp;
    pANTLR3_BASE_TREE    n;
    pANTLR3_BASE_TREE    ID1;
    pANTLR3_BASE_TREE    ID2;
    pANTLR3_BASE_TREE    ID3;
    pANTLR3_BASE_TREE    ID8;
    vector<string> ret;
    #undef	RETURN_TYPE_ret
    #define	RETURN_TYPE_ret vector<string>

    vector<string> args;
    #undef	RETURN_TYPE_args
    #define	RETURN_TYPE_args vector<string>

    vector<string> lstArgsFc4;
    #undef	RETURN_TYPE_lstArgsFc4
    #define	RETURN_TYPE_lstArgsFc4 vector<string>

    string dType5;
    #undef	RETURN_TYPE_dType5
    #define	RETURN_TYPE_dType5 string

    vector<string> lstArgsFc6;
    #undef	RETURN_TYPE_lstArgsFc6
    #define	RETURN_TYPE_lstArgsFc6 vector<string>

    string dType7;
    #undef	RETURN_TYPE_dType7
    #define	RETURN_TYPE_dType7 string

    /* Initialize rule variables
     */


    s       = NULL;
    tp       = NULL;
    n       = NULL;
    ID1       = NULL;
    ID2       = NULL;
    ID3       = NULL;
    ID8       = NULL;







    {
        {
            //  DPtree.g:85:3: ( ^( NEWSTATEMENT statement[true] ) | ^( OLDSTATEMENT statement[false] ) | ^( DELWAYPOINT ID ) | ^( DELQUERY ID ) | ^( CRDATATYPE ID s= STRING ) | ^( CRSYNONIM tp= ID s= ID ) | ^( FUNCTION ID (s= STRING )? dType lstArgsFc ) | ^( OPDEF n= STRING (s= STRING )? dType lstArgsFc ) | ^( CRGLA ID (s= STRING )? ^( TPATT (ret= lstArgsGLA ) ) ^( TPATT (args= lstArgsGLA ) ) ) | relationCR | FLUSHTOKEN | runStmt | QUITTOKEN )
            
            ANTLR3_UINT32 alt5;

            alt5=13;

            switch ( LA(1) ) 
            {
            case NEWSTATEMENT:
            	{
            		alt5=1;
            	}
                break;
            case OLDSTATEMENT:
            	{
            		alt5=2;
            	}
                break;
            case DELWAYPOINT:
            	{
            		alt5=3;
            	}
                break;
            case DELQUERY:
            	{
            		alt5=4;
            	}
                break;
            case CRDATATYPE:
            	{
            		alt5=5;
            	}
                break;
            case CRSYNONIM:
            	{
            		alt5=6;
            	}
                break;
            case FUNCTION:
            	{
            		alt5=7;
            	}
                break;
            case OPDEF:
            	{
            		alt5=8;
            	}
                break;
            case CRGLA:
            	{
            		alt5=9;
            	}
                break;
            case CRRELATION:
            	{
            		alt5=10;
            	}
                break;
            case FLUSHTOKEN:
            	{
            		alt5=11;
            	}
                break;
            case RUN__:
            	{
            		alt5=12;
            	}
                break;
            case QUITTOKEN:
            	{
            		alt5=13;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 5;
                EXCEPTION->state        = 0;


                goto rulecomplexStatementEx;
            }

            switch (alt5) 
            {
        	case 1:
        	    // DPtree.g:85:5: ^( NEWSTATEMENT statement[true] )
        	    {
        	         MATCHT(NEWSTATEMENT, &FOLLOW_NEWSTATEMENT_in_complexStatement76); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_statement_in_complexStatement78);
        	        statement(ctx, true);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // DPtree.g:86:5: ^( OLDSTATEMENT statement[false] )
        	    {
        	         MATCHT(OLDSTATEMENT, &FOLLOW_OLDSTATEMENT_in_complexStatement87); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_statement_in_complexStatement89);
        	        statement(ctx, false);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // DPtree.g:87:5: ^( DELWAYPOINT ID )
        	    {
        	         MATCHT(DELWAYPOINT, &FOLLOW_DELWAYPOINT_in_complexStatement98); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }

        	         MATCHT(ID, &FOLLOW_ID_in_complexStatement100); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // DPtree.g:88:5: ^( DELQUERY ID )
        	    {
        	         MATCHT(DELQUERY, &FOLLOW_DELQUERY_in_complexStatement110); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }

        	        ID1 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_complexStatement112); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }

        	        {
        	             QueryID q=qm.GetQueryID(TXT(ID1)); lT->DeleteQuery(q); 
        	        }

        	    }
        	    break;
        	case 5:
        	    // DPtree.g:89:5: ^( CRDATATYPE ID s= STRING )
        	    {
        	         MATCHT(CRDATATYPE, &FOLLOW_CRDATATYPE_in_complexStatement122); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }

        	        ID2 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_complexStatement124); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }

        	        s = (pANTLR3_BASE_TREE) MATCHT(STRING, &FOLLOW_STRING_in_complexStatement128); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }

        	        {
        	             dTM.AddBaseType(STR(ID2), STRS(s)); 
        	        }

        	    }
        	    break;
        	case 6:
        	    // DPtree.g:90:5: ^( CRSYNONIM tp= ID s= ID )
        	    {
        	         MATCHT(CRSYNONIM, &FOLLOW_CRSYNONIM_in_complexStatement138); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }

        	        tp = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_complexStatement142); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }

        	        s = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_complexStatement146); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }

        	        {
        	             dTM.AddSynonymType(STR(tp), STR(s)); 
        	        }

        	    }
        	    break;
        	case 7:
        	    // DPtree.g:91:5: ^( FUNCTION ID (s= STRING )? dType lstArgsFc )
        	    {
        	         MATCHT(FUNCTION, &FOLLOW_FUNCTION_in_complexStatement156); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }

        	        ID3 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_complexStatement158); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	        // DPtree.g:91:19: (s= STRING )?
        	        {
        	            int alt2=2;
        	            switch ( LA(1) ) 
        	            {
        	                case STRING:
        	                	{
        	                		alt2=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt2) 
        	            {
        	        	case 1:
        	        	    // DPtree.g:91:20: s= STRING
        	        	    {
        	        	        s = (pANTLR3_BASE_TREE) MATCHT(STRING, &FOLLOW_STRING_in_complexStatement163); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecomplexStatementEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }
        	        FOLLOWPUSH(FOLLOW_dType_in_complexStatement167);
        	        dType5=dType(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_lstArgsFc_in_complexStatement169);
        	        lstArgsFc4=lstArgsFc(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }

        	        {
        	             dTM.AddFunctions(STR(ID3), lstArgsFc4, dType5, true); /* string ignored for now */ 
        	        }

        	    }
        	    break;
        	case 8:
        	    // DPtree.g:92:5: ^( OPDEF n= STRING (s= STRING )? dType lstArgsFc )
        	    {
        	         MATCHT(OPDEF, &FOLLOW_OPDEF_in_complexStatement178); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }

        	        n = (pANTLR3_BASE_TREE) MATCHT(STRING, &FOLLOW_STRING_in_complexStatement182); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	        // DPtree.g:92:22: (s= STRING )?
        	        {
        	            int alt3=2;
        	            switch ( LA(1) ) 
        	            {
        	                case STRING:
        	                	{
        	                		alt3=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt3) 
        	            {
        	        	case 1:
        	        	    // DPtree.g:92:23: s= STRING
        	        	    {
        	        	        s = (pANTLR3_BASE_TREE) MATCHT(STRING, &FOLLOW_STRING_in_complexStatement187); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecomplexStatementEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }
        	        FOLLOWPUSH(FOLLOW_dType_in_complexStatement191);
        	        dType7=dType(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_lstArgsFc_in_complexStatement193);
        	        lstArgsFc6=lstArgsFc(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }

        	        {
        	             dTM.AddFunctions(STRS(n), lstArgsFc6, dType7, true); /* string ignored for now */ 
        	        }

        	    }
        	    break;
        	case 9:
        	    // DPtree.g:93:5: ^( CRGLA ID (s= STRING )? ^( TPATT (ret= lstArgsGLA ) ) ^( TPATT (args= lstArgsGLA ) ) )
        	    {
        	         MATCHT(CRGLA, &FOLLOW_CRGLA_in_complexStatement202); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }

        	        ID8 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_complexStatement204); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	        // DPtree.g:93:16: (s= STRING )?
        	        {
        	            int alt4=2;
        	            switch ( LA(1) ) 
        	            {
        	                case STRING:
        	                	{
        	                		alt4=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt4) 
        	            {
        	        	case 1:
        	        	    // DPtree.g:93:17: s= STRING
        	        	    {
        	        	        s = (pANTLR3_BASE_TREE) MATCHT(STRING, &FOLLOW_STRING_in_complexStatement209); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecomplexStatementEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }
        	         MATCHT(TPATT, &FOLLOW_TPATT_in_complexStatement214); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }

        	        // DPtree.g:93:36: (ret= lstArgsGLA )
        	        // DPtree.g:93:37: ret= lstArgsGLA
        	        {
        	            FOLLOWPUSH(FOLLOW_lstArgsGLA_in_complexStatement219);
        	            ret=lstArgsGLA(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulecomplexStatementEx;
        	            }


        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }

        	         MATCHT(TPATT, &FOLLOW_TPATT_in_complexStatement224); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }

        	        // DPtree.g:93:62: (args= lstArgsGLA )
        	        // DPtree.g:93:63: args= lstArgsGLA
        	        {
        	            FOLLOWPUSH(FOLLOW_lstArgsGLA_in_complexStatement229);
        	            args=lstArgsGLA(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulecomplexStatementEx;
        	            }


        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }

        	        {
        	             dTM.AddGLA(STR(ID8), args, ret); 
        	        }

        	    }
        	    break;
        	case 10:
        	    // DPtree.g:94:5: relationCR
        	    {
        	        FOLLOWPUSH(FOLLOW_relationCR_in_complexStatement240);
        	        relationCR(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	    }
        	    break;
        	case 11:
        	    // DPtree.g:95:5: FLUSHTOKEN
        	    {
        	         MATCHT(FLUSHTOKEN, &FOLLOW_FLUSHTOKEN_in_complexStatement246); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }

        	        {
        	            dTM.Save(); catalog.SaveCatalog();
        	        }

        	    }
        	    break;
        	case 12:
        	    // DPtree.g:96:5: runStmt
        	    {
        	        FOLLOWPUSH(FOLLOW_runStmt_in_complexStatement254);
        	        runStmt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }


        	    }
        	    break;
        	case 13:
        	    // DPtree.g:97:5: QUITTOKEN
        	    {
        	         MATCHT(QUITTOKEN, &FOLLOW_QUITTOKEN_in_complexStatement260); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomplexStatementEx;
        	        }

        	        {
        	             exit(0); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulecomplexStatementEx; /* Prevent compiler warnings */
    rulecomplexStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end complexStatement */

/** 
 * $ANTLR start runStmt
 * DPtree.g:100:1: runStmt : ^( RUN__ ( ID )+ ) ;
 */
static void
runStmt(pDPtree ctx)
{   
    pANTLR3_BASE_TREE    ID9;

    /* Initialize rule variables
     */


    QueryIDSet qrys;
    ID9       = NULL;

    {
        // DPtree.g:103:3: ( ^( RUN__ ( ID )+ ) )
        // DPtree.g:103:5: ^( RUN__ ( ID )+ )
        {
             MATCHT(RUN__, &FOLLOW_RUN___in_runStmt284); 
            if  (HASEXCEPTION())
            {
                goto rulerunStmtEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulerunStmtEx;
            }

            // DPtree.g:103:13: ( ID )+
            {
                int cnt6=0;

                for (;;)
                {
                    int alt6=2;
            	switch ( LA(1) ) 
            	{
            	case ID:
            		{
            			alt6=1;
            		}
            	    break;

            	}

            	switch (alt6) 
            	{
            	    case 1:
            	        // DPtree.g:103:14: ID
            	        {
            	            ID9 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_runStmt287); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulerunStmtEx;
            	            }

            	            {

            	                        QueryID lq = qm.GetQueryID(TXT(ID9));
            	                        // check lq to ensur it is valid
            	                        qrys.Union(lq);
            	                        
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt6 >= 1 )
            		{
            		    goto loop6;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulerunStmtEx;
            	}
            	cnt6++;
                }
                loop6: ;	/* Jump to here if this rule does not match */
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulerunStmtEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerunStmtEx; /* Prevent compiler warnings */
    rulerunStmtEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                    lT->Run(qrys);
                }
            }


    return ;
}
/* $ANTLR end runStmt */

/** 
 * $ANTLR start relationCR
 * DPtree.g:110:1: relationCR : ^( CRRELATION x= ID ( ^( TPATT n= ID t= ID ) )+ ) ;
 */
static void
relationCR(pDPtree ctx)
{   
    pANTLR3_BASE_TREE    x;
    pANTLR3_BASE_TREE    n;
    pANTLR3_BASE_TREE    t;

    /* Initialize rule variables
     */


     Schema newSch; int index = 0; 
    x       = NULL;
    n       = NULL;
    t       = NULL;

    {
        // DPtree.g:113:3: ( ^( CRRELATION x= ID ( ^( TPATT n= ID t= ID ) )+ ) )
        // DPtree.g:113:5: ^( CRRELATION x= ID ( ^( TPATT n= ID t= ID ) )+ )
        {
             MATCHT(CRRELATION, &FOLLOW_CRRELATION_in_relationCR315); 
            if  (HASEXCEPTION())
            {
                goto rulerelationCREx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulerelationCREx;
            }

            x = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_relationCR319); 
            if  (HASEXCEPTION())
            {
                goto rulerelationCREx;
            }

            {
                newSch.SetRelationName(TXT(x));/* set relation name */
            }
            // DPtree.g:114:7: ( ^( TPATT n= ID t= ID ) )+
            {
                int cnt7=0;

                for (;;)
                {
                    int alt7=2;
            	switch ( LA(1) ) 
            	{
            	case TPATT:
            		{
            			alt7=1;
            		}
            	    break;

            	}

            	switch (alt7) 
            	{
            	    case 1:
            	        // DPtree.g:114:9: ^( TPATT n= ID t= ID )
            	        {
            	             MATCHT(TPATT, &FOLLOW_TPATT_in_relationCR332); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulerelationCREx;
            	            }


            	            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulerelationCREx;
            	            }

            	            n = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_relationCR336); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulerelationCREx;
            	            }

            	            t = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_relationCR340); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulerelationCREx;
            	            }


            	            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulerelationCREx;
            	            }

            	            {
            	                 Attribute att; att.SetName(TXT(n)); string ty(string(TXT(t))); att.SetType(ty); att.SetIndex(++index); newSch.AddAttribute(att);/* add attribte n with type t */ 
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt7 >= 1 )
            		{
            		    goto loop7;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulerelationCREx;
            	}
            	cnt7++;
                }
                loop7: ;	/* Jump to here if this rule does not match */
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulerelationCREx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerelationCREx; /* Prevent compiler warnings */
    rulerelationCREx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     catalog.AddSchema(newSch);/* register the relatin with catalog */ 
                }
            }


    return ;
}
/* $ANTLR end relationCR */

/** 
 * $ANTLR start lstArgsFc
 * DPtree.g:119:1: lstArgsFc returns [vector<string> vecT] : ( dType )* ;
 */
static vector<string>
lstArgsFc(pDPtree ctx)
{   
    vector<string> vecT;

    string dType10;
    #undef	RETURN_TYPE_dType10
    #define	RETURN_TYPE_dType10 string

    /* Initialize rule variables
     */


    {
        // DPtree.g:120:3: ( ( dType )* )
        // DPtree.g:120:4: ( dType )*
        {

            // DPtree.g:120:4: ( dType )*

            for (;;)
            {
                int alt8=2;
                switch ( LA(1) ) 
                {
                case ID:
                	{
                		alt8=1;
                	}
                    break;

                }

                switch (alt8) 
                {
            	case 1:
            	    // DPtree.g:120:6: dType
            	    {
            	        FOLLOWPUSH(FOLLOW_dType_in_lstArgsFc380);
            	        dType10=dType(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelstArgsFcEx;
            	        }

            	        {
            	             vecT.push_back(dType10); 
            	        }

            	    }
            	    break;

            	default:
            	    goto loop8;	/* break out of the loop */
            	    break;
                }
            }
            loop8: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulelstArgsFcEx; /* Prevent compiler warnings */
    rulelstArgsFcEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return vecT;
}
/* $ANTLR end lstArgsFc */

/** 
 * $ANTLR start lstArgsGLA
 * DPtree.g:123:1: lstArgsGLA returns [vector<string> vecT] : f= dType (o= dType )* ;
 */
static vector<string>
lstArgsGLA(pDPtree ctx)
{   
    vector<string> vecT;

    string f;
    #undef	RETURN_TYPE_f
    #define	RETURN_TYPE_f string

    string o;
    #undef	RETURN_TYPE_o
    #define	RETURN_TYPE_o string

    /* Initialize rule variables
     */





    {
        // DPtree.g:124:5: (f= dType (o= dType )* )
        // DPtree.g:124:7: f= dType (o= dType )*
        {
            FOLLOWPUSH(FOLLOW_dType_in_lstArgsGLA406);
            f=dType(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulelstArgsGLAEx;
            }

            {
                vecT.push_back(f);
            }

            // DPtree.g:124:42: (o= dType )*

            for (;;)
            {
                int alt9=2;
                switch ( LA(1) ) 
                {
                case ID:
                	{
                		alt9=1;
                	}
                    break;

                }

                switch (alt9) 
                {
            	case 1:
            	    // DPtree.g:124:44: o= dType
            	    {
            	        FOLLOWPUSH(FOLLOW_dType_in_lstArgsGLA414);
            	        o=dType(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelstArgsGLAEx;
            	        }

            	        {
            	            vecT.push_back(o); 
            	        }

            	    }
            	    break;

            	default:
            	    goto loop9;	/* break out of the loop */
            	    break;
                }
            }
            loop9: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulelstArgsGLAEx; /* Prevent compiler warnings */
    rulelstArgsGLAEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return vecT;
}
/* $ANTLR end lstArgsGLA */

/** 
 * $ANTLR start dType
 * DPtree.g:127:1: dType returns [string type] : ID ;
 */
static string
dType(pDPtree ctx)
{   
    string type;

    pANTLR3_BASE_TREE    ID11;

    /* Initialize rule variables
     */


    ID11       = NULL;

    {
        // DPtree.g:128:3: ( ID )
        // DPtree.g:128:5: ID
        {
            ID11 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_dType437); 
            if  (HASEXCEPTION())
            {
                goto ruledTypeEx;
            }

            {
                type=TXT(ID11);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledTypeEx; /* Prevent compiler warnings */
    ruledTypeEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return type;
}
/* $ANTLR end dType */

/** 
 * $ANTLR start statement
 * DPtree.g:131:1: statement[bool isNew] : ( scanner | waypoint[isNew] | query | writer );
 */
static void
statement(pDPtree ctx, bool isNew)
{   
    /* Initialize rule variables
     */


    {
        {
            //  DPtree.g:132:5: ( scanner | waypoint[isNew] | query | writer )
            
            ANTLR3_UINT32 alt10;

            alt10=4;

            switch ( LA(1) ) 
            {
            case SCANNER__:
            	{
            		alt10=1;
            	}
                break;
            case WAYPOINT__:
            	{
            		alt10=2;
            	}
                break;
            case QUERRY__:
            	{
            		alt10=3;
            	}
                break;
            case WRITER__:
            	{
            		alt10=4;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 10;
                EXCEPTION->state        = 0;


                goto rulestatementEx;
            }

            switch (alt10) 
            {
        	case 1:
        	    // DPtree.g:132:10: scanner
        	    {
        	        FOLLOWPUSH(FOLLOW_scanner_in_statement458);
        	        scanner(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // DPtree.g:133:7: waypoint[isNew]
        	    {
        	        FOLLOWPUSH(FOLLOW_waypoint_in_statement466);
        	        waypoint(ctx, isNew);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // DPtree.g:134:7: query
        	    {
        	        FOLLOWPUSH(FOLLOW_query_in_statement475);
        	        query(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // DPtree.g:135:7: writer
        	    {
        	        FOLLOWPUSH(FOLLOW_writer_in_statement483);
        	        writer(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end statement */

/** 
 * $ANTLR start writer
 * DPtree.g:138:1: writer : ^( WRITER__ a= ID b= ID connList ) ;
 */
static void
writer(pDPtree ctx)
{   
    pANTLR3_BASE_TREE    a;
    pANTLR3_BASE_TREE    b;

    /* Initialize rule variables
     */


    a       = NULL;
    b       = NULL;

    {
        // DPtree.g:138:8: ( ^( WRITER__ a= ID b= ID connList ) )
        // DPtree.g:139:5: ^( WRITER__ a= ID b= ID connList )
        {
             MATCHT(WRITER__, &FOLLOW_WRITER___in_writer501); 
            if  (HASEXCEPTION())
            {
                goto rulewriterEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulewriterEx;
            }

            a = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_writer505); 
            if  (HASEXCEPTION())
            {
                goto rulewriterEx;
            }

            b = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_writer509); 
            if  (HASEXCEPTION())
            {
                goto rulewriterEx;
            }

            {

                        // set wp to current scanner
                        wp = WayPointID::GetIdByName((const char*)(a->getText(a))->chars);
                        // set the query
                        SlotContainer attribs;
                        am.GetAttributesSlots(TXT(a), attribs); // put attributes in attribs
                        WayPointID scanner = WayPointID::GetIdByName(TXT(a));
                        lT->AddScannerWP(scanner, TXT(a), attribs);
                        qry = qm.GetQueryID((const char*) (b->getText(b))->chars);
                        lT->AddWriter(wp, qry);
                        // now wp is set for connList
                      
            }
            FOLLOWPUSH(FOLLOW_connList_in_writer513);
            connList(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewriterEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulewriterEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulewriterEx; /* Prevent compiler warnings */
    rulewriterEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end writer */

/** 
 * $ANTLR start scanner
 * DPtree.g:153:1: scanner : ^( SCANNER__ a= ID (b= ID )? ) ;
 */
static void
scanner(pDPtree ctx)
{   
    pANTLR3_BASE_TREE    a;
    pANTLR3_BASE_TREE    b;

    /* Initialize rule variables
     */


     string sName; // scanner name
                string rName; // relatin name
              
    a       = NULL;
    b       = NULL;

    {
        // DPtree.g:157:5: ( ^( SCANNER__ a= ID (b= ID )? ) )
        // DPtree.g:157:10: ^( SCANNER__ a= ID (b= ID )? )
        {
             MATCHT(SCANNER__, &FOLLOW_SCANNER___in_scanner544); 
            if  (HASEXCEPTION())
            {
                goto rulescannerEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulescannerEx;
            }

            a = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_scanner548); 
            if  (HASEXCEPTION())
            {
                goto rulescannerEx;
            }

            {
                 sName=(char*)(a->getText(a))->chars; rName=sName;
            }

            // DPtree.g:158:13: (b= ID )?
            {
                int alt11=2;
                switch ( LA(1) ) 
                {
                    case ID:
                    	{
                    		alt11=1;
                    	}
                        break;
                }

                switch (alt11) 
                {
            	case 1:
            	    // DPtree.g:158:14: b= ID
            	    {
            	        b = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_scanner567); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulescannerEx;
            	        }

            	        {
            	            rName=(char*)(b->getText(b))->chars;
            	        }

            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulescannerEx;
            }

            {

                            SlotContainer attribs;
                            am.GetAttributesSlots(rName, attribs); // put attributes in attribs
                            WayPointID scanner = WayPointID::GetIdByName(sName.c_str());
                            lT->AddScannerWP(scanner, rName, attribs);
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulescannerEx; /* Prevent compiler warnings */
    rulescannerEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end scanner */

/** 
 * $ANTLR start waypoint
 * DPtree.g:166:1: waypoint[bool isNew] : ^( WAYPOINT__ ID ( wpDefinition )? ( bypassRule )* ( wpbodyStatement )* ) ;
 */
static void
waypoint(pDPtree ctx, bool isNew)
{   
    pANTLR3_BASE_TREE    ID12;

    /* Initialize rule variables
     */


    ID12       = NULL;

    {
        // DPtree.g:167:5: ( ^( WAYPOINT__ ID ( wpDefinition )? ( bypassRule )* ( wpbodyStatement )* ) )
        // DPtree.g:167:10: ^( WAYPOINT__ ID ( wpDefinition )? ( bypassRule )* ( wpbodyStatement )* )
        {
             MATCHT(WAYPOINT__, &FOLLOW_WAYPOINT___in_waypoint596); 
            if  (HASEXCEPTION())
            {
                goto rulewaypointEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulewaypointEx;
            }

            ID12 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_waypoint598); 
            if  (HASEXCEPTION())
            {
                goto rulewaypointEx;
            }

            {

                            if (isNew){
                                WayPointID nWp((const char*)(ID12->getText(ID12))->chars);
                                wp = nWp;
                            } else {
                                wp = WayPointID::GetIdByName((const char*)(ID12->getText(ID12))->chars);
                            }
                        
            }

            // DPtree.g:174:12: ( wpDefinition )?
            {
                int alt12=2;
                switch ( LA(1) ) 
                {
                    case JOIN:
                    case GLA:
                    case PRINT:
                    case AGGREGATE:
                    case SELECT__:
                    case TEXTLOADER__:
                    	{
                    		alt12=1;
                    	}
                        break;
                }

                switch (alt12) 
                {
            	case 1:
            	    // DPtree.g:174:12: wpDefinition
            	    {
            	        FOLLOWPUSH(FOLLOW_wpDefinition_in_waypoint603);
            	        wpDefinition(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulewaypointEx;
            	        }


            	    }
            	    break;

                }
            }

            // DPtree.g:174:26: ( bypassRule )*

            for (;;)
            {
                int alt13=2;
                switch ( LA(1) ) 
                {
                case BYPASS:
                	{
                		alt13=1;
                	}
                    break;

                }

                switch (alt13) 
                {
            	case 1:
            	    // DPtree.g:174:26: bypassRule
            	    {
            	        FOLLOWPUSH(FOLLOW_bypassRule_in_waypoint606);
            	        bypassRule(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulewaypointEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop13;	/* break out of the loop */
            	    break;
                }
            }
            loop13: ; /* Jump out to here if this rule does not match */


            // DPtree.g:174:38: ( wpbodyStatement )*

            for (;;)
            {
                int alt14=2;
                switch ( LA(1) ) 
                {
                case QUERRY__:
                	{
                		alt14=1;
                	}
                    break;

                }

                switch (alt14) 
                {
            	case 1:
            	    // DPtree.g:174:38: wpbodyStatement
            	    {
            	        FOLLOWPUSH(FOLLOW_wpbodyStatement_in_waypoint609);
            	        wpbodyStatement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulewaypointEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop14;	/* break out of the loop */
            	    break;
                }
            }
            loop14: ; /* Jump out to here if this rule does not match */


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulewaypointEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulewaypointEx; /* Prevent compiler warnings */
    rulewaypointEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end waypoint */

/** 
 * $ANTLR start query
 * DPtree.g:177:1: query : ^( QUERRY__ ( ID )+ ( qBodyStatement )* ) ;
 */
static void
query(pDPtree ctx)
{   
    pANTLR3_BASE_TREE    ID13;

    /* Initialize rule variables
     */


    ID13       = NULL;

    {
        // DPtree.g:178:3: ( ^( QUERRY__ ( ID )+ ( qBodyStatement )* ) )
        // DPtree.g:178:8: ^( QUERRY__ ( ID )+ ( qBodyStatement )* )
        {
             MATCHT(QUERRY__, &FOLLOW_QUERRY___in_query631); 
            if  (HASEXCEPTION())
            {
                goto rulequeryEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulequeryEx;
            }

            // DPtree.g:178:19: ( ID )+
            {
                int cnt15=0;

                for (;;)
                {
                    int alt15=2;
            	switch ( LA(1) ) 
            	{
            	case ID:
            		{
            			alt15=1;
            		}
            	    break;

            	}

            	switch (alt15) 
            	{
            	    case 1:
            	        // DPtree.g:178:20: ID
            	        {
            	            ID13 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_query634); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulequeryEx;
            	            }

            	            {
            	                 qry = qm.GetQueryID((const char*) (ID13->getText(ID13))->chars); /*qm.AddNewQuery(string((const char*) (ID13->getText(ID13))->chars), qry);*/ 
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt15 >= 1 )
            		{
            		    goto loop15;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulequeryEx;
            	}
            	cnt15++;
                }
                loop15: ;	/* Jump to here if this rule does not match */
            }

            // DPtree.g:178:146: ( qBodyStatement )*

            for (;;)
            {
                int alt16=2;
                switch ( LA(1) ) 
                {
                case WAYPOINT__:
                	{
                		alt16=1;
                	}
                    break;

                }

                switch (alt16) 
                {
            	case 1:
            	    // DPtree.g:178:146: qBodyStatement
            	    {
            	        FOLLOWPUSH(FOLLOW_qBodyStatement_in_query641);
            	        qBodyStatement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulequeryEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop16;	/* break out of the loop */
            	    break;
                }
            }
            loop16: ; /* Jump out to here if this rule does not match */


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulequeryEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulequeryEx; /* Prevent compiler warnings */
    rulequeryEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end query */

/** 
 * $ANTLR start qBodyStatement
 * DPtree.g:182:1: qBodyStatement : ^( WAYPOINT__ ID bodyStatement ) ;
 */
static void
qBodyStatement(pDPtree ctx)
{   
    pANTLR3_BASE_TREE    ID14;

    /* Initialize rule variables
     */


    ID14       = NULL;

    {
        // DPtree.g:183:5: ( ^( WAYPOINT__ ID bodyStatement ) )
        // DPtree.g:183:10: ^( WAYPOINT__ ID bodyStatement )
        {
             MATCHT(WAYPOINT__, &FOLLOW_WAYPOINT___in_qBodyStatement664); 
            if  (HASEXCEPTION())
            {
                goto ruleqBodyStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleqBodyStatementEx;
            }

            ID14 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_qBodyStatement666); 
            if  (HASEXCEPTION())
            {
                goto ruleqBodyStatementEx;
            }

            {

                            wp = WayPointID::GetIdByName((char*)(ID14->getText(ID14))->chars);
                            //wpType=typeMap[wp];
                        
            }
            FOLLOWPUSH(FOLLOW_bodyStatement_in_qBodyStatement671);
            bodyStatement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleqBodyStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleqBodyStatementEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleqBodyStatementEx; /* Prevent compiler warnings */
    ruleqBodyStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end qBodyStatement */

/** 
 * $ANTLR start wpbodyStatement
 * DPtree.g:189:1: wpbodyStatement : ^( QUERRY__ ID bodyStatement ) ;
 */
static void
wpbodyStatement(pDPtree ctx)
{   
    pANTLR3_BASE_TREE    ID15;

    /* Initialize rule variables
     */


    ID15       = NULL;

    {
        // DPtree.g:190:3: ( ^( QUERRY__ ID bodyStatement ) )
        // DPtree.g:190:5: ^( QUERRY__ ID bodyStatement )
        {
             MATCHT(QUERRY__, &FOLLOW_QUERRY___in_wpbodyStatement688); 
            if  (HASEXCEPTION())
            {
                goto rulewpbodyStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulewpbodyStatementEx;
            }

            ID15 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_wpbodyStatement690); 
            if  (HASEXCEPTION())
            {
                goto rulewpbodyStatementEx;
            }

            {
                qry = qm.GetQueryID((const char*) (ID15->getText(ID15))->chars);
            }
            FOLLOWPUSH(FOLLOW_bodyStatement_in_wpbodyStatement694);
            bodyStatement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewpbodyStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulewpbodyStatementEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulewpbodyStatementEx; /* Prevent compiler warnings */
    rulewpbodyStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end wpbodyStatement */

/** 
 * $ANTLR start bodyStatement
 * DPtree.g:193:1: bodyStatement : ( rules )* ;
 */
static void
bodyStatement(pDPtree ctx)
{   
    /* Initialize rule variables
     */


    {
        // DPtree.g:194:3: ( ( rules )* )
        // DPtree.g:194:8: ( rules )*
        {

            // DPtree.g:194:8: ( rules )*

            for (;;)
            {
                int alt17=2;
                switch ( LA(1) ) 
                {
                case FILTER:
                case JOIN:
                case GLA:
                case PRINT:
                case AGGREGATE:
                case SYNTHESIZE:
                	{
                		alt17=1;
                	}
                    break;

                }

                switch (alt17) 
                {
            	case 1:
            	    // DPtree.g:194:8: rules
            	    {
            	        FOLLOWPUSH(FOLLOW_rules_in_bodyStatement711);
            	        rules(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebodyStatementEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop17;	/* break out of the loop */
            	    break;
                }
            }
            loop17: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulebodyStatementEx; /* Prevent compiler warnings */
    rulebodyStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end bodyStatement */

/** 
 * $ANTLR start rules
 * DPtree.g:197:1: rules : ( filterRule | synthRule | aggregateRule | printRule | joinRule | glaRule );
 */
static void
rules(pDPtree ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  DPtree.g:197:7: ( filterRule | synthRule | aggregateRule | printRule | joinRule | glaRule )
            
            ANTLR3_UINT32 alt18;

            alt18=6;

            switch ( LA(1) ) 
            {
            case FILTER:
            	{
            		alt18=1;
            	}
                break;
            case SYNTHESIZE:
            	{
            		alt18=2;
            	}
                break;
            case AGGREGATE:
            	{
            		alt18=3;
            	}
                break;
            case PRINT:
            	{
            		alt18=4;
            	}
                break;
            case JOIN:
            	{
            		alt18=5;
            	}
                break;
            case GLA:
            	{
            		alt18=6;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 18;
                EXCEPTION->state        = 0;


                goto rulerulesEx;
            }

            switch (alt18) 
            {
        	case 1:
        	    // DPtree.g:198:5: filterRule
        	    {
        	        FOLLOWPUSH(FOLLOW_filterRule_in_rules727);
        	        filterRule(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerulesEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // DPtree.g:199:5: synthRule
        	    {
        	        FOLLOWPUSH(FOLLOW_synthRule_in_rules733);
        	        synthRule(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerulesEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // DPtree.g:200:5: aggregateRule
        	    {
        	        FOLLOWPUSH(FOLLOW_aggregateRule_in_rules739);
        	        aggregateRule(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerulesEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // DPtree.g:201:5: printRule
        	    {
        	        FOLLOWPUSH(FOLLOW_printRule_in_rules745);
        	        printRule(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerulesEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // DPtree.g:202:5: joinRule
        	    {
        	        FOLLOWPUSH(FOLLOW_joinRule_in_rules751);
        	        joinRule(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerulesEx;
        	        }


        	    }
        	    break;
        	case 6:
        	    // DPtree.g:203:5: glaRule
        	    {
        	        FOLLOWPUSH(FOLLOW_glaRule_in_rules757);
        	        glaRule(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerulesEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulerulesEx; /* Prevent compiler warnings */
    rulerulesEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end rules */

/** 
 * $ANTLR start filterRule
 * DPtree.g:206:1: filterRule : ^( FILTER expr[atts, cstStr] ) ;
 */
static void
filterRule(pDPtree ctx)
{   
    string expr16;
    #undef	RETURN_TYPE_expr16
    #define	RETURN_TYPE_expr16 string

    /* Initialize rule variables
     */


    SlotContainer atts; /* the set of attributes */
          string cstStr; /* the constants used in the expression */
            
    {
        // DPtree.g:210:4: ( ^( FILTER expr[atts, cstStr] ) )
        // DPtree.g:210:6: ^( FILTER expr[atts, cstStr] )
        {
             MATCHT(FILTER, &FOLLOW_FILTER_in_filterRule781); 
            if  (HASEXCEPTION())
            {
                goto rulefilterRuleEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulefilterRuleEx;
            }

            FOLLOWPUSH(FOLLOW_expr_in_filterRule783);
            expr16=expr(ctx, atts, cstStr);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefilterRuleEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulefilterRuleEx;
            }

            {
                 lT->AddFilter(wp, qry, atts, expr16, cstStr); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefilterRuleEx; /* Prevent compiler warnings */
    rulefilterRuleEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end filterRule */

/** 
 * $ANTLR start synthRule
 * DPtree.g:213:1: synthRule : ^( SYNTHESIZE a= ID t= ID expr[atts, cstStr] ) ;
 */
static void
synthRule(pDPtree ctx)
{   
    pANTLR3_BASE_TREE    a;
    pANTLR3_BASE_TREE    t;
    string expr17;
    #undef	RETURN_TYPE_expr17
    #define	RETURN_TYPE_expr17 string

    /* Initialize rule variables
     */


    SlotContainer atts; /* the set of attributes */
          string cstStr; /* the constants used in the expression */
            
    a       = NULL;
    t       = NULL;

    {
        // DPtree.g:217:5: ( ^( SYNTHESIZE a= ID t= ID expr[atts, cstStr] ) )
        // DPtree.g:217:7: ^( SYNTHESIZE a= ID t= ID expr[atts, cstStr] )
        {
             MATCHT(SYNTHESIZE, &FOLLOW_SYNTHESIZE_in_synthRule812); 
            if  (HASEXCEPTION())
            {
                goto rulesynthRuleEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulesynthRuleEx;
            }

            a = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_synthRule816); 
            if  (HASEXCEPTION())
            {
                goto rulesynthRuleEx;
            }

            t = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_synthRule820); 
            if  (HASEXCEPTION())
            {
                goto rulesynthRuleEx;
            }

            FOLLOWPUSH(FOLLOW_expr_in_synthRule822);
            expr17=expr(ctx, atts, cstStr);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesynthRuleEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulesynthRuleEx;
            }

            {

                      SlotID sID = am.AddSynthesizedAttribute(qry, (const char*)(a->getText(a))->chars,
                                                                (const char*)(t->getText(t))->chars);
                      lT->AddSynthesized(wp,qry, sID, atts, expr17, cstStr);
                    
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesynthRuleEx; /* Prevent compiler warnings */
    rulesynthRuleEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end synthRule */

/** 
 * $ANTLR start aggregateRule
 * DPtree.g:224:1: aggregateRule : ^( AGGREGATE name= ID type= ID expr[atts, cstStr] ) ;
 */
static void
aggregateRule(pDPtree ctx)
{   
    pANTLR3_BASE_TREE    name;
    pANTLR3_BASE_TREE    type;
    string expr18;
    #undef	RETURN_TYPE_expr18
    #define	RETURN_TYPE_expr18 string

    /* Initialize rule variables
     */


    SlotContainer atts; /* the set of attributes */
          string cstStr; /* the constants used in the expression */
            
    name       = NULL;
    type       = NULL;

    {
        // DPtree.g:228:5: ( ^( AGGREGATE name= ID type= ID expr[atts, cstStr] ) )
        // DPtree.g:228:7: ^( AGGREGATE name= ID type= ID expr[atts, cstStr] )
        {
             MATCHT(AGGREGATE, &FOLLOW_AGGREGATE_in_aggregateRule851); 
            if  (HASEXCEPTION())
            {
                goto ruleaggregateRuleEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleaggregateRuleEx;
            }

            name = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_aggregateRule855); 
            if  (HASEXCEPTION())
            {
                goto ruleaggregateRuleEx;
            }

            type = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_aggregateRule859); 
            if  (HASEXCEPTION())
            {
                goto ruleaggregateRuleEx;
            }

            FOLLOWPUSH(FOLLOW_expr_in_aggregateRule861);
            expr18=expr(ctx, atts, cstStr);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleaggregateRuleEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleaggregateRuleEx;
            }

            {

                            SlotID aggID = am.AddSynthesizedAttribute(qry, (const char*)(name->getText(name))->chars, "DOUBLE");
                            lT->AddAggregate(wp,qry, aggID, (const char*)(type->getText(type))->chars, atts, expr18, cstStr);
                    
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleaggregateRuleEx; /* Prevent compiler warnings */
    ruleaggregateRuleEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end aggregateRule */

/** 
 * $ANTLR start printRule
 * DPtree.g:234:1: printRule : ^( PRINT expr[atts, cstStr] printAtts[names, types] printFile[file] ) ;
 */
static void
printRule(pDPtree ctx)
{   
    string expr19;
    #undef	RETURN_TYPE_expr19
    #define	RETURN_TYPE_expr19 string

    /* Initialize rule variables
     */


    SlotContainer atts; /* the set of attributes */
          string cstStr; /* the constants used in the expression */
          string names;
          string types;
          string file;
            
    {
        // DPtree.g:241:5: ( ^( PRINT expr[atts, cstStr] printAtts[names, types] printFile[file] ) )
        // DPtree.g:241:7: ^( PRINT expr[atts, cstStr] printAtts[names, types] printFile[file] )
        {
             MATCHT(PRINT, &FOLLOW_PRINT_in_printRule890); 
            if  (HASEXCEPTION())
            {
                goto ruleprintRuleEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleprintRuleEx;
            }

            FOLLOWPUSH(FOLLOW_expr_in_printRule892);
            expr19=expr(ctx, atts, cstStr);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprintRuleEx;
            }

            FOLLOWPUSH(FOLLOW_printAtts_in_printRule895);
            printAtts(ctx, names, types);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprintRuleEx;
            }

            FOLLOWPUSH(FOLLOW_printFile_in_printRule898);
            printFile(ctx, file);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprintRuleEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleprintRuleEx;
            }

            {
                 lT->AddPrint(wp, qry, atts, expr19, cstStr, names, types, file); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleprintRuleEx; /* Prevent compiler warnings */
    ruleprintRuleEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end printRule */

/** 
 * $ANTLR start printAtts
 * DPtree.g:244:1: printAtts[string& names, string& types] : ( | ^( ATTWT n= ID t= ID ) ( ^( ATTWT n= ID t= ID ) )* );
 */
static void
printAtts(pDPtree ctx, string& names, string& types)
{   
    pANTLR3_BASE_TREE    n;
    pANTLR3_BASE_TREE    t;

    /* Initialize rule variables
     */


    n       = NULL;
    t       = NULL;

    {
        {
            //  DPtree.g:245:5: ( | ^( ATTWT n= ID t= ID ) ( ^( ATTWT n= ID t= ID ) )* )
            
            ANTLR3_UINT32 alt20;

            alt20=2;

            switch ( LA(1) ) 
            {
            case UP:
            case LIST:
            	{
            		alt20=1;
            	}
                break;
            case ATTWT:
            	{
            		alt20=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 20;
                EXCEPTION->state        = 0;


                goto ruleprintAttsEx;
            }

            switch (alt20) 
            {
        	case 1:
        	    // DPtree.g:246:5: 
        	    {
        	    }
        	    break;
        	case 2:
        	    // DPtree.g:246:7: ^( ATTWT n= ID t= ID ) ( ^( ATTWT n= ID t= ID ) )*
        	    {
        	         MATCHT(ATTWT, &FOLLOW_ATTWT_in_printAtts927); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprintAttsEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprintAttsEx;
        	        }

        	        n = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_printAtts931); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprintAttsEx;
        	        }

        	        t = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_printAtts935); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprintAttsEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprintAttsEx;
        	        }

        	        {
        	             names+=TXT(n); types+=TXT(t); 
        	        }

        	        // DPtree.g:247:7: ( ^( ATTWT n= ID t= ID ) )*

        	        for (;;)
        	        {
        	            int alt19=2;
        	            switch ( LA(1) ) 
        	            {
        	            case ATTWT:
        	            	{
        	            		alt19=1;
        	            	}
        	                break;

        	            }

        	            switch (alt19) 
        	            {
        	        	case 1:
        	        	    // DPtree.g:247:9: ^( ATTWT n= ID t= ID )
        	        	    {
        	        	         MATCHT(ATTWT, &FOLLOW_ATTWT_in_printAtts949); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleprintAttsEx;
        	        	        }


        	        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleprintAttsEx;
        	        	        }

        	        	        n = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_printAtts953); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleprintAttsEx;
        	        	        }

        	        	        t = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_printAtts957); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleprintAttsEx;
        	        	        }


        	        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleprintAttsEx;
        	        	        }

        	        	        {
        	        	             names+=","; names+=TXT(n); types+=","; types+=TXT(t); 
        	        	        }

        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop19;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop19: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleprintAttsEx; /* Prevent compiler warnings */
    ruleprintAttsEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end printAtts */

/** 
 * $ANTLR start ctAttList
 * DPtree.g:250:1: ctAttList[string& ctArgs] : ( | a= ctAtt (b= ctAtt )* );
 */
static void
ctAttList(pDPtree ctx, string& ctArgs)
{   
    string a;
    #undef	RETURN_TYPE_a
    #define	RETURN_TYPE_a string

    string b;
    #undef	RETURN_TYPE_b
    #define	RETURN_TYPE_b string

    /* Initialize rule variables
     */





    {
        {
            //  DPtree.g:251:5: ( | a= ctAtt (b= ctAtt )* )
            
            ANTLR3_UINT32 alt22;

            alt22=2;

            switch ( LA(1) ) 
            {
            case ID:
            	{
            		alt22=1;
            	}
                break;
            case INT:
            case FLOAT:
            case STRING:
            	{
            		alt22=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 22;
                EXCEPTION->state        = 0;


                goto rulectAttListEx;
            }

            switch (alt22) 
            {
        	case 1:
        	    // DPtree.g:252:5: 
        	    {
        	    }
        	    break;
        	case 2:
        	    // DPtree.g:252:7: a= ctAtt (b= ctAtt )*
        	    {
        	        FOLLOWPUSH(FOLLOW_ctAtt_in_ctAttList991);
        	        a=ctAtt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulectAttListEx;
        	        }

        	        {
        	            ctArgs+=a;
        	        }

        	        // DPtree.g:252:31: (b= ctAtt )*

        	        for (;;)
        	        {
        	            int alt21=2;
        	            switch ( LA(1) ) 
        	            {
        	            case INT:
        	            case FLOAT:
        	            case STRING:
        	            	{
        	            		alt21=1;
        	            	}
        	                break;

        	            }

        	            switch (alt21) 
        	            {
        	        	case 1:
        	        	    // DPtree.g:252:32: b= ctAtt
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_ctAtt_in_ctAttList998);
        	        	        b=ctAtt(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulectAttListEx;
        	        	        }

        	        	        {
        	        	            ctArgs+=", "; ctArgs+=b;
        	        	        }

        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop21;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop21: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulectAttListEx; /* Prevent compiler warnings */
    rulectAttListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end ctAttList */

/** 
 * $ANTLR start ctAtt
 * DPtree.g:255:1: ctAtt returns [string s] : (a= STRING | a= INT | a= FLOAT ) ;
 */
static string
ctAtt(pDPtree ctx)
{   
    string s;

    pANTLR3_BASE_TREE    a;

    /* Initialize rule variables
     */


    a       = NULL;

    {
        // DPtree.g:256:5: ( (a= STRING | a= INT | a= FLOAT ) )
        // DPtree.g:256:7: (a= STRING | a= INT | a= FLOAT )
        {

            // DPtree.g:256:7: (a= STRING | a= INT | a= FLOAT )
            {
                int alt23=3;
                switch ( LA(1) ) 
                {
                case STRING:
                	{
                		alt23=1;
                	}
                    break;
                case INT:
                	{
                		alt23=2;
                	}
                    break;
                case FLOAT:
                	{
                		alt23=3;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 23;
                    EXCEPTION->state        = 0;


                    goto rulectAttEx;
                }

                switch (alt23) 
                {
            	case 1:
            	    // DPtree.g:256:8: a= STRING
            	    {
            	        a = (pANTLR3_BASE_TREE) MATCHT(STRING, &FOLLOW_STRING_in_ctAtt1027); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulectAttEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // DPtree.g:256:19: a= INT
            	    {
            	        a = (pANTLR3_BASE_TREE) MATCHT(INT, &FOLLOW_INT_in_ctAtt1033); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulectAttEx;
            	        }


            	    }
            	    break;
            	case 3:
            	    // DPtree.g:256:27: a= FLOAT
            	    {
            	        a = (pANTLR3_BASE_TREE) MATCHT(FLOAT, &FOLLOW_FLOAT_in_ctAtt1039); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulectAttEx;
            	        }


            	    }
            	    break;

                }
            }
            {
                s=(char*)((a->getText(a))->chars);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulectAttEx; /* Prevent compiler warnings */
    rulectAttEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return s;
}
/* $ANTLR end ctAtt */

/** 
 * $ANTLR start printFile
 * DPtree.g:259:1: printFile[string& s] : ( | ^( LIST a= STRING ) );
 */
static void
printFile(pDPtree ctx, string& s)
{   
    pANTLR3_BASE_TREE    a;

    /* Initialize rule variables
     */


    a       = NULL;

    {
        {
            //  DPtree.g:260:5: ( | ^( LIST a= STRING ) )
            
            ANTLR3_UINT32 alt24;

            alt24=2;

            switch ( LA(1) ) 
            {
            case UP:
            	{
            		alt24=1;
            	}
                break;
            case LIST:
            	{
            		alt24=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 24;
                EXCEPTION->state        = 0;


                goto ruleprintFileEx;
            }

            switch (alt24) 
            {
        	case 1:
        	    // DPtree.g:261:5: 
        	    {
        	    }
        	    break;
        	case 2:
        	    // DPtree.g:261:7: ^( LIST a= STRING )
        	    {
        	         MATCHT(LIST, &FOLLOW_LIST_in_printFile1069); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprintFileEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprintFileEx;
        	        }

        	        a = (pANTLR3_BASE_TREE) MATCHT(STRING, &FOLLOW_STRING_in_printFile1073); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprintFileEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleprintFileEx;
        	        }

        	        {
        	            s=STRS(a);
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleprintFileEx; /* Prevent compiler warnings */
    ruleprintFileEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end printFile */

/** 
 * $ANTLR start glaDef
 * DPtree.g:265:1: glaDef returns [string name, string defs] : ID glaTemplate[$name,$defs] ;
 */
static DPtree_glaDef_return
glaDef(pDPtree ctx)
{   
    DPtree_glaDef_return retval;

    pANTLR3_BASE_TREE    ID20;

    /* Initialize rule variables
     */


    ID20       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    {
        // DPtree.g:266:3: ( ID glaTemplate[$name,$defs] )
        // DPtree.g:266:5: ID glaTemplate[$name,$defs]
        {
            ID20 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_glaDef1098); 
            if  (HASEXCEPTION())
            {
                goto ruleglaDefEx;
            }

            {
                retval.name=(const char*) (ID20->getText(ID20))->chars;
            }
            FOLLOWPUSH(FOLLOW_glaTemplate_in_glaDef1102);
            glaTemplate(ctx, retval.name, retval.defs);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleglaDefEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleglaDefEx; /* Prevent compiler warnings */
    ruleglaDefEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return retval;
}
/* $ANTLR end glaDef */

/** 
 * $ANTLR start glaTemplate
 * DPtree.g:269:1: glaTemplate[string& name, string& defs] : ( | ^( GLATEMPLATE ( glaTemplArg[args, defs] )* ) );
 */
static void
glaTemplate(pDPtree ctx, string& name, string& defs)
{   
    /* Initialize rule variables
     */


     string args; 
    {
        {
            //  DPtree.g:271:5: ( | ^( GLATEMPLATE ( glaTemplArg[args, defs] )* ) )
            
            ANTLR3_UINT32 alt26;

            alt26=2;

            switch ( LA(1) ) 
            {
            case UP:
            case GLA:
            case MATCH_DP:
            case CASE_DP:
            case BOOL_T:
            case INT:
            case FLOAT:
            case STRING:
            case ATT:
            case FUNCTION:
            case OPERATOR:
            case UOPERATOR:
            case ATTWT:
            case LIST:
            	{
            		alt26=1;
            	}
                break;
            case GLATEMPLATE:
            	{
            		alt26=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 26;
                EXCEPTION->state        = 0;


                goto ruleglaTemplateEx;
            }

            switch (alt26) 
            {
        	case 1:
        	    // DPtree.g:271:23: 
        	    {
        	        {
        	             defs+="#include \""; defs+=name; defs+=".h\"\n"; 
        	        }

        	    }
        	    break;
        	case 2:
        	    // DPtree.g:272:7: ^( GLATEMPLATE ( glaTemplArg[args, defs] )* )
        	    {
        	         MATCHT(GLATEMPLATE, &FOLLOW_GLATEMPLATE_in_glaTemplate1135); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglaTemplateEx;
        	        }


        	        if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
        	            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleglaTemplateEx;
        	            }


        	            // DPtree.g:272:22: ( glaTemplArg[args, defs] )*

        	            for (;;)
        	            {
        	                int alt25=2;
        	                switch ( LA(1) ) 
        	                {
        	                case GLA:
        	                case INT:
        	                case FLOAT:
        	                case STRING:
        	                case ATTWT:
        	                case LIST:
        	                	{
        	                		alt25=1;
        	                	}
        	                    break;

        	                }

        	                switch (alt25) 
        	                {
        	            	case 1:
        	            	    // DPtree.g:272:23: glaTemplArg[args, defs]
        	            	    {
        	            	        {
        	            	            args+=",";
        	            	        }
        	            	        FOLLOWPUSH(FOLLOW_glaTemplArg_in_glaTemplate1141);
        	            	        glaTemplArg(ctx, args, defs);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto ruleglaTemplateEx;
        	            	        }


        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop25;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop25: ; /* Jump out to here if this rule does not match */


        	            MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleglaTemplateEx;
        	            }

        	        }
        	        {

        	                     // form the template instantiation code and change name to temp
        	                        defs+="\nm4_include(</";
        	                     defs+=name+".h.m4/>)\n";
        	                     string tempName = GenerateTemp("GLA_%d");
        	                     defs+=name;
        	                     defs+="(";
        	                     defs+=tempName; // args has comma
        	                     defs+=args;
        	                     defs+=")\n";
        	                     name=tempName; // new name
        	                    
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleglaTemplateEx; /* Prevent compiler warnings */
    ruleglaTemplateEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end glaTemplate */

/** 
 * $ANTLR start glaTemplArg
 * DPtree.g:287:1: glaTemplArg[string& args, string& defs] : ( ^( LIST attC[args] ( attC[args] )* ) | attWT[args] | GLA glaDef | s= STRING | i= INT | f= FLOAT );
 */
static void
glaTemplArg(pDPtree ctx, string& args, string& defs)
{   
    pANTLR3_BASE_TREE    s;
    pANTLR3_BASE_TREE    i;
    pANTLR3_BASE_TREE    f;
    DPtree_glaDef_return glaDef21;
    #undef	RETURN_TYPE_glaDef21
    #define	RETURN_TYPE_glaDef21 DPtree_glaDef_return

    /* Initialize rule variables
     */


    s       = NULL;
    i       = NULL;
    f       = NULL;

    {
        {
            //  DPtree.g:288:5: ( ^( LIST attC[args] ( attC[args] )* ) | attWT[args] | GLA glaDef | s= STRING | i= INT | f= FLOAT )
            
            ANTLR3_UINT32 alt28;

            alt28=6;

            switch ( LA(1) ) 
            {
            case LIST:
            	{
            		alt28=1;
            	}
                break;
            case ATTWT:
            	{
            		alt28=2;
            	}
                break;
            case GLA:
            	{
            		alt28=3;
            	}
                break;
            case STRING:
            	{
            		alt28=4;
            	}
                break;
            case INT:
            	{
            		alt28=5;
            	}
                break;
            case FLOAT:
            	{
            		alt28=6;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 28;
                EXCEPTION->state        = 0;


                goto ruleglaTemplArgEx;
            }

            switch (alt28) 
            {
        	case 1:
        	    // DPtree.g:288:7: ^( LIST attC[args] ( attC[args] )* )
        	    {
        	         MATCHT(LIST, &FOLLOW_LIST_in_glaTemplArg1176); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglaTemplArgEx;
        	        }


        	        {
        	            args+="</";
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglaTemplArgEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_attC_in_glaTemplArg1180);
        	        attC(ctx, args);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglaTemplArgEx;
        	        }


        	        // DPtree.g:288:39: ( attC[args] )*

        	        for (;;)
        	        {
        	            int alt27=2;
        	            switch ( LA(1) ) 
        	            {
        	            case ATTC:
        	            	{
        	            		alt27=1;
        	            	}
        	                break;

        	            }

        	            switch (alt27) 
        	            {
        	        	case 1:
        	        	    // DPtree.g:288:40: attC[args]
        	        	    {
        	        	        {
        	        	            args+=",";
        	        	        }
        	        	        FOLLOWPUSH(FOLLOW_attC_in_glaTemplArg1186);
        	        	        attC(ctx, args);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleglaTemplArgEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop27;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop27: ; /* Jump out to here if this rule does not match */

        	        {
        	            args+="/>";
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglaTemplArgEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // DPtree.g:289:7: attWT[args]
        	    {
        	        FOLLOWPUSH(FOLLOW_attWT_in_glaTemplArg1200);
        	        attWT(ctx, args);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglaTemplArgEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // DPtree.g:290:7: GLA glaDef
        	    {
        	         MATCHT(GLA, &FOLLOW_GLA_in_glaTemplArg1211); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglaTemplArgEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_glaDef_in_glaTemplArg1213);
        	        glaDef21=glaDef(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglaTemplArgEx;
        	        }

        	        {

        	                  // glue the definitions accumulated
        	                  defs+=glaDef21.defs;
        	                  // add the name to current definition
        	                  args+=glaDef21.name;
        	                
        	        }

        	    }
        	    break;
        	case 4:
        	    // DPtree.g:296:7: s= STRING
        	    {
        	        s = (pANTLR3_BASE_TREE) MATCHT(STRING, &FOLLOW_STRING_in_glaTemplArg1225); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglaTemplArgEx;
        	        }

        	        {
        	             args+=TXTN(s); 
        	        }

        	    }
        	    break;
        	case 5:
        	    // DPtree.g:297:7: i= INT
        	    {
        	        i = (pANTLR3_BASE_TREE) MATCHT(INT, &FOLLOW_INT_in_glaTemplArg1237); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglaTemplArgEx;
        	        }

        	        {
        	             args+=TXT(i); 
        	        }

        	    }
        	    break;
        	case 6:
        	    // DPtree.g:298:7: f= FLOAT
        	    {
        	        f = (pANTLR3_BASE_TREE) MATCHT(FLOAT, &FOLLOW_FLOAT_in_glaTemplArg1249); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglaTemplArgEx;
        	        }

        	        {
        	             args+=TXT(f); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleglaTemplArgEx; /* Prevent compiler warnings */
    ruleglaTemplArgEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end glaTemplArg */

/** 
 * $ANTLR start attWT
 * DPtree.g:301:1: attWT[string& args] : ^( ATTWT att= ID type= ID ) ;
 */
static void
attWT(pDPtree ctx, string& args)
{   
    pANTLR3_BASE_TREE    att;
    pANTLR3_BASE_TREE    type;

    /* Initialize rule variables
     */


    att       = NULL;
    type       = NULL;

    {
        // DPtree.g:302:5: ( ^( ATTWT att= ID type= ID ) )
        // DPtree.g:302:7: ^( ATTWT att= ID type= ID )
        {
             MATCHT(ATTWT, &FOLLOW_ATTWT_in_attWT1270); 
            if  (HASEXCEPTION())
            {
                goto ruleattWTEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleattWTEx;
            }

            att = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_attWT1274); 
            if  (HASEXCEPTION())
            {
                goto ruleattWTEx;
            }

            type = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_attWT1278); 
            if  (HASEXCEPTION())
            {
                goto ruleattWTEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleattWTEx;
            }

            {

                      args+="(";
                      args+=(const char*) (att->getText(att))->chars;
                      args+=",";
                      args+=(const char*) (type->getText(type))->chars;
                      args+=")";
                    
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleattWTEx; /* Prevent compiler warnings */
    ruleattWTEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end attWT */

/** 
 * $ANTLR start attC
 * DPtree.g:311:1: attC[string& args] : ^( ATTC a= ID (b= ID )* ) ;
 */
static void
attC(pDPtree ctx, string& args)
{   
    pANTLR3_BASE_TREE    a;
    pANTLR3_BASE_TREE    b;

    /* Initialize rule variables
     */


    a       = NULL;
    b       = NULL;

    {
        // DPtree.g:312:5: ( ^( ATTC a= ID (b= ID )* ) )
        // DPtree.g:312:7: ^( ATTC a= ID (b= ID )* )
        {
             MATCHT(ATTC, &FOLLOW_ATTC_in_attC1300); 
            if  (HASEXCEPTION())
            {
                goto ruleattCEx;
            }


            {
                args+="(";
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleattCEx;
            }

            a = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_attC1307); 
            if  (HASEXCEPTION())
            {
                goto ruleattCEx;
            }

            {
                 args+=TXT(a); 
            }

            // DPtree.g:313:13: (b= ID )*

            for (;;)
            {
                int alt29=2;
                switch ( LA(1) ) 
                {
                case ID:
                	{
                		alt29=1;
                	}
                    break;

                }

                switch (alt29) 
                {
            	case 1:
            	    // DPtree.g:313:15: b= ID
            	    {
            	        b = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_attC1327); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleattCEx;
            	        }

            	        {
            	             args+=','; args+=TXT(b);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop29;	/* break out of the loop */
            	    break;
                }
            }
            loop29: ; /* Jump out to here if this rule does not match */

            {
                args+=')';
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleattCEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleattCEx; /* Prevent compiler warnings */
    ruleattCEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end attC */

/** 
 * $ANTLR start glaRule
 * DPtree.g:317:1: glaRule : ^( GLA ( PLUS )? ctAttList[ctArgs] glaDef ( attLWT[outAtts, outTypes] )* (a= expression[atts, cstStr] )* ) ;
 */
static void
glaRule(pDPtree ctx)
{   
    DPtree_expression_return a;
    #undef	RETURN_TYPE_a
    #define	RETURN_TYPE_a DPtree_expression_return

    DPtree_glaDef_return glaDef22;
    #undef	RETURN_TYPE_glaDef22
    #define	RETURN_TYPE_glaDef22 DPtree_glaDef_return

    /* Initialize rule variables
     */



                SlotContainer atts; /* the set of attributes */
                SlotContainer outAtts; /**output attributes */
                string cstStr; /* the constants used in the expression */
                string sExpr; // the entire expression representing the arguments
                ExprListInfo lInfo;
                string ctArgs="("; /* constructor arguments*/
                std::vector<std::string> outTypes;
                bool isLarge = false;
            



    {
        // DPtree.g:328:5: ( ^( GLA ( PLUS )? ctAttList[ctArgs] glaDef ( attLWT[outAtts, outTypes] )* (a= expression[atts, cstStr] )* ) )
        // DPtree.g:328:7: ^( GLA ( PLUS )? ctAttList[ctArgs] glaDef ( attLWT[outAtts, outTypes] )* (a= expression[atts, cstStr] )* )
        {
             MATCHT(GLA, &FOLLOW_GLA_in_glaRule1371); 
            if  (HASEXCEPTION())
            {
                goto ruleglaRuleEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleglaRuleEx;
            }


            // DPtree.g:328:13: ( PLUS )?
            {
                int alt30=2;
                switch ( LA(1) ) 
                {
                    case PLUS:
                    	{
                    		alt30=1;
                    	}
                        break;
                }

                switch (alt30) 
                {
            	case 1:
            	    // DPtree.g:328:14: PLUS
            	    {
            	         MATCHT(PLUS, &FOLLOW_PLUS_in_glaRule1374); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleglaRuleEx;
            	        }

            	        {
            	            isLarge = true;
            	        }

            	    }
            	    break;

                }
            }
            FOLLOWPUSH(FOLLOW_ctAttList_in_glaRule1380);
            ctAttList(ctx, ctArgs);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleglaRuleEx;
            }

            FOLLOWPUSH(FOLLOW_glaDef_in_glaRule1383);
            glaDef22=glaDef(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleglaRuleEx;
            }


            // DPtree.g:328:64: ( attLWT[outAtts, outTypes] )*

            for (;;)
            {
                int alt31=2;
                switch ( LA(1) ) 
                {
                case ATTWT:
                	{
                		alt31=1;
                	}
                    break;

                }

                switch (alt31) 
                {
            	case 1:
            	    // DPtree.g:328:64: attLWT[outAtts, outTypes]
            	    {
            	        FOLLOWPUSH(FOLLOW_attLWT_in_glaRule1385);
            	        attLWT(ctx, outAtts, outTypes);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleglaRuleEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop31;	/* break out of the loop */
            	    break;
                }
            }
            loop31: ; /* Jump out to here if this rule does not match */


            // DPtree.g:328:91: (a= expression[atts, cstStr] )*

            for (;;)
            {
                int alt32=2;
                switch ( LA(1) ) 
                {
                case MATCH_DP:
                case CASE_DP:
                case BOOL_T:
                case INT:
                case FLOAT:
                case STRING:
                case ATT:
                case FUNCTION:
                case OPERATOR:
                case UOPERATOR:
                	{
                		alt32=1;
                	}
                    break;

                }

                switch (alt32) 
                {
            	case 1:
            	    // DPtree.g:328:92: a= expression[atts, cstStr]
            	    {
            	        FOLLOWPUSH(FOLLOW_expression_in_glaRule1392);
            	        a=expression(ctx, atts, cstStr);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleglaRuleEx;
            	        }

            	        {
            	               lInfo.Add(a.sExpr, a.type, a.isCT); 
            	        }

            	    }
            	    break;

            	default:
            	    goto loop32;	/* break out of the loop */
            	    break;
                }
            }
            loop32: ; /* Jump out to here if this rule does not match */


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleglaRuleEx;
            }

            {

                        // This is we get in return
                            string glaName((const char *) (STRSTREAM->toStringSS(STRSTREAM, glaDef22.start, glaDef22.start))->chars );
                            // Check if operator exists
                #ifdef ENFORCE_GLA_TYPES
                           vector<ArgFormat> actArgs;
                           if (!dTM.IsGLA(glaName, outTypes, lInfo.GetListTypes(), actArgs)) {
                               printf("\nERROR: GLA %s with arguments %s do not exist",
                                      glaName.c_str(), lInfo.GetTypesDesc().c_str());
                           } else {
                               // Need to tell the expression info list about the actual types of the
                               // arguments and any special formatting needed using the vector of
                               // ArgFormats.
                               lInfo.Prepare( cstStr, actArgs );
                           }
                #else
                           lInfo.Prepare( cstStr );
                #endif
                           /** in future, check if the function is pure as well */
                           bool isCT = lInfo.IsListConstant();

                           std::vector<string> eVals = lInfo.Generate();
                           sExpr = "(";
                           for (int i=0; i<eVals.size(); i++){
                               if (i>0) {
                                   sExpr += ",";
                               }

                               sExpr += eVals[i];
                           }
                           sExpr += ")";

                           ctArgs+=")";

                            if( isLarge )
                                lT->AddGLALarge(wp, qry, outAtts, glaDef22.name, glaDef22.defs, ctArgs, atts, sExpr, cstStr);
                            else
                               lT->AddGLA(wp,qry, outAtts, glaDef22.name, glaDef22.defs, ctArgs, atts, sExpr, cstStr);
                    
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleglaRuleEx; /* Prevent compiler warnings */
    ruleglaRuleEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end glaRule */

/** 
 * $ANTLR start attLWT
 * DPtree.g:369:1: attLWT[SlotContainer& outAtts, vector<string> &outTypes] : ^( ATTWT att= ID type= ID ) ;
 */
static void
attLWT(pDPtree ctx, SlotContainer& outAtts, vector<string> &outTypes)
{   
    pANTLR3_BASE_TREE    att;
    pANTLR3_BASE_TREE    type;

    /* Initialize rule variables
     */


    att       = NULL;
    type       = NULL;

    {
        // DPtree.g:370:5: ( ^( ATTWT att= ID type= ID ) )
        // DPtree.g:370:7: ^( ATTWT att= ID type= ID )
        {
             MATCHT(ATTWT, &FOLLOW_ATTWT_in_attLWT1420); 
            if  (HASEXCEPTION())
            {
                goto ruleattLWTEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleattLWTEx;
            }

            att = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_attLWT1424); 
            if  (HASEXCEPTION())
            {
                goto ruleattLWTEx;
            }

            type = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_attLWT1428); 
            if  (HASEXCEPTION())
            {
                goto ruleattLWTEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleattLWTEx;
            }

            {

                            SlotID glaID = am.AddSynthesizedAttribute(qry, (const char*)(att->getText(att))->chars,
                                                                      (const char*)(type->getText(type))->chars);
                            string t((const char*)((type->getText(type))->chars));
                            outTypes.push_back(t);
                            outAtts.Append(glaID);
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleattLWTEx; /* Prevent compiler warnings */
    ruleattLWTEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end attLWT */

/** 
 * $ANTLR start bypassRule
 * DPtree.g:379:1: bypassRule : ^( BYPASS ID ) ;
 */
static void
bypassRule(pDPtree ctx)
{   
    pANTLR3_BASE_TREE    ID23;

    /* Initialize rule variables
     */


    ID23       = NULL;

    {
        // DPtree.g:379:12: ( ^( BYPASS ID ) )
        // DPtree.g:380:5: ^( BYPASS ID )
        {
             MATCHT(BYPASS, &FOLLOW_BYPASS_in_bypassRule1449); 
            if  (HASEXCEPTION())
            {
                goto rulebypassRuleEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulebypassRuleEx;
            }

            ID23 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_bypassRule1451); 
            if  (HASEXCEPTION())
            {
                goto rulebypassRuleEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulebypassRuleEx;
            }

            {

                      qry = qm.GetQueryID((const char*) (ID23->getText(ID23))->chars);
                      lT->AddBypass(wp,qry);
                    
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulebypassRuleEx; /* Prevent compiler warnings */
    rulebypassRuleEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end bypassRule */

/** 
 * $ANTLR start joinRule
 * DPtree.g:386:1: joinRule : ^( JOIN attributeList[atts] ) ;
 */
static void
joinRule(pDPtree ctx)
{   
    /* Initialize rule variables
     */


    SlotContainer atts; /* the set of attributes */ 
    {
        // DPtree.g:388:5: ( ^( JOIN attributeList[atts] ) )
        // DPtree.g:388:7: ^( JOIN attributeList[atts] )
        {
             MATCHT(JOIN, &FOLLOW_JOIN_in_joinRule1479); 
            if  (HASEXCEPTION())
            {
                goto rulejoinRuleEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulejoinRuleEx;
            }

            FOLLOWPUSH(FOLLOW_attributeList_in_joinRule1481);
            attributeList(ctx, atts);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulejoinRuleEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulejoinRuleEx;
            }

            {

                lT->AddJoin(wp, qry, atts);

            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulejoinRuleEx; /* Prevent compiler warnings */
    rulejoinRuleEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end joinRule */

/** 
 * $ANTLR start attribute
 * DPtree.g:393:1: attribute returns [SlotID slot] : att= ATT ;
 */
static SlotID
attribute(pDPtree ctx)
{   
    SlotID slot;

    pANTLR3_BASE_TREE    att;

    /* Initialize rule variables
     */


    att       = NULL;

    {
        // DPtree.g:394:5: (att= ATT )
        // DPtree.g:394:11: att= ATT
        {
            att = (pANTLR3_BASE_TREE) MATCHT(ATT, &FOLLOW_ATT_in_attribute1510); 
            if  (HASEXCEPTION())
            {
                goto ruleattributeEx;
            }

            {

                            slot= am.GetAttributeSlot((char*)(att->getText(att))->chars);
                            WARNINGIF( !slot.IsValid(), "Attribute does not exist");
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleattributeEx; /* Prevent compiler warnings */
    ruleattributeEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return slot;
}
/* $ANTLR end attribute */

/** 
 * $ANTLR start selectWP
 * DPtree.g:400:1: selectWP : ^( SELECT__ connList ) ;
 */
static void
selectWP(pDPtree ctx)
{   
    /* Initialize rule variables
     */


    {
        // DPtree.g:401:5: ( ^( SELECT__ connList ) )
        // DPtree.g:401:10: ^( SELECT__ connList )
        {
             MATCHT(SELECT__, &FOLLOW_SELECT___in_selectWP1534); 
            if  (HASEXCEPTION())
            {
                goto ruleselectWPEx;
            }


            {

                            lT->AddSelectionWP(wp);
                        
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleselectWPEx;
            }

            FOLLOWPUSH(FOLLOW_connList_in_selectWP1539);
            connList(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleselectWPEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleselectWPEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleselectWPEx; /* Prevent compiler warnings */
    ruleselectWPEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end selectWP */

/** 
 * $ANTLR start joinWP
 * DPtree.g:406:1: joinWP : ^( JOIN attributeList[atts] connList ) ;
 */
static void
joinWP(pDPtree ctx)
{   
    /* Initialize rule variables
     */


    SlotContainer atts;
    {
        // DPtree.g:408:5: ( ^( JOIN attributeList[atts] connList ) )
        // DPtree.g:408:7: ^( JOIN attributeList[atts] connList )
        {
             MATCHT(JOIN, &FOLLOW_JOIN_in_joinWP1564); 
            if  (HASEXCEPTION())
            {
                goto rulejoinWPEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulejoinWPEx;
            }

            FOLLOWPUSH(FOLLOW_attributeList_in_joinWP1566);
            attributeList(ctx, atts);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulejoinWPEx;
            }

            {
                 lT->AddJoinWP(wp, atts); 
            }
            FOLLOWPUSH(FOLLOW_connList_in_joinWP1571);
            connList(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulejoinWPEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulejoinWPEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulejoinWPEx; /* Prevent compiler warnings */
    rulejoinWPEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end joinWP */

/** 
 * $ANTLR start attributeList
 * DPtree.g:411:1: attributeList[SlotContainer& atts] : ^( ATTS (a= attribute )+ ) ;
 */
static void
attributeList(pDPtree ctx, SlotContainer& atts)
{   
    SlotID a;
    #undef	RETURN_TYPE_a
    #define	RETURN_TYPE_a SlotID

    /* Initialize rule variables
     */


    {
        // DPtree.g:412:1: ( ^( ATTS (a= attribute )+ ) )
        // DPtree.g:412:3: ^( ATTS (a= attribute )+ )
        {
             MATCHT(ATTS, &FOLLOW_ATTS_in_attributeList1587); 
            if  (HASEXCEPTION())
            {
                goto ruleattributeListEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleattributeListEx;
            }

            // DPtree.g:412:10: (a= attribute )+
            {
                int cnt33=0;

                for (;;)
                {
                    int alt33=2;
            	switch ( LA(1) ) 
            	{
            	case ATT:
            		{
            			alt33=1;
            		}
            	    break;

            	}

            	switch (alt33) 
            	{
            	    case 1:
            	        // DPtree.g:412:11: a= attribute
            	        {
            	            FOLLOWPUSH(FOLLOW_attribute_in_attributeList1592);
            	            a=attribute(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleattributeListEx;
            	            }

            	            {
            	                atts.Append(a);
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt33 >= 1 )
            		{
            		    goto loop33;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleattributeListEx;
            	}
            	cnt33++;
                }
                loop33: ;	/* Jump to here if this rule does not match */
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleattributeListEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleattributeListEx; /* Prevent compiler warnings */
    ruleattributeListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end attributeList */

/** 
 * $ANTLR start aggregateWP
 * DPtree.g:415:1: aggregateWP : ^( AGGREGATE connList ) ;
 */
static void
aggregateWP(pDPtree ctx)
{   
    /* Initialize rule variables
     */


    {
        // DPtree.g:416:3: ( ^( AGGREGATE connList ) )
        // DPtree.g:416:8: ^( AGGREGATE connList )
        {
             MATCHT(AGGREGATE, &FOLLOW_AGGREGATE_in_aggregateWP1613); 
            if  (HASEXCEPTION())
            {
                goto ruleaggregateWPEx;
            }


            {

                        lT->AddAggregateWP(wp);
                    
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleaggregateWPEx;
            }

            FOLLOWPUSH(FOLLOW_connList_in_aggregateWP1623);
            connList(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleaggregateWPEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleaggregateWPEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleaggregateWPEx; /* Prevent compiler warnings */
    ruleaggregateWPEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end aggregateWP */

/** 
 * $ANTLR start glaWP
 * DPtree.g:422:1: glaWP : ^( GLA ( PLUS )? connList ) ;
 */
static void
glaWP(pDPtree ctx)
{   
    /* Initialize rule variables
     */



            bool isLarge = false;
        
    {
        // DPtree.g:426:5: ( ^( GLA ( PLUS )? connList ) )
        // DPtree.g:426:7: ^( GLA ( PLUS )? connList )
        {
             MATCHT(GLA, &FOLLOW_GLA_in_glaWP1650); 
            if  (HASEXCEPTION())
            {
                goto ruleglaWPEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleglaWPEx;
            }


            // DPtree.g:426:13: ( PLUS )?
            {
                int alt34=2;
                switch ( LA(1) ) 
                {
                    case PLUS:
                    	{
                    		alt34=1;
                    	}
                        break;
                }

                switch (alt34) 
                {
            	case 1:
            	    // DPtree.g:426:14: PLUS
            	    {
            	         MATCHT(PLUS, &FOLLOW_PLUS_in_glaWP1653); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleglaWPEx;
            	        }

            	        {
            	            isLarge = true;
            	        }

            	    }
            	    break;

                }
            }
            {

                        if( isLarge )
                            lT->AddGLALargeWP(wp);
                        else
                            lT->AddGLAWP(wp);
                    
            }
            FOLLOWPUSH(FOLLOW_connList_in_glaWP1667);
            connList(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleglaWPEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleglaWPEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleglaWPEx; /* Prevent compiler warnings */
    ruleglaWPEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end glaWP */

/** 
 * $ANTLR start printWP
 * DPtree.g:435:1: printWP : ^( PRINT connList ) ;
 */
static void
printWP(pDPtree ctx)
{   
    /* Initialize rule variables
     */


    {
        // DPtree.g:436:5: ( ^( PRINT connList ) )
        // DPtree.g:436:10: ^( PRINT connList )
        {
             MATCHT(PRINT, &FOLLOW_PRINT_in_printWP1688); 
            if  (HASEXCEPTION())
            {
                goto ruleprintWPEx;
            }


            {

                      lT->AddPrintWP(wp);
                      
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleprintWPEx;
            }

            FOLLOWPUSH(FOLLOW_connList_in_printWP1698);
            connList(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprintWPEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleprintWPEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleprintWPEx; /* Prevent compiler warnings */
    ruleprintWPEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end printWP */

/** 
 * $ANTLR start connList
 * DPtree.g:442:1: connList : ( wayPointCN )+ ;
 */
static void
connList(pDPtree ctx)
{   
    /* Initialize rule variables
     */


    {
        // DPtree.g:443:5: ( ( wayPointCN )+ )
        // DPtree.g:443:7: ( wayPointCN )+
        {
            // DPtree.g:443:7: ( wayPointCN )+
            {
                int cnt35=0;

                for (;;)
                {
                    int alt35=2;
            	switch ( LA(1) ) 
            	{
            	case ID:
            	case TERMCONN:
            		{
            			alt35=1;
            		}
            	    break;

            	}

            	switch (alt35) 
            	{
            	    case 1:
            	        // DPtree.g:443:7: wayPointCN
            	        {
            	            FOLLOWPUSH(FOLLOW_wayPointCN_in_connList1715);
            	            wayPointCN(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleconnListEx;
            	            }


            	        }
            	        break;

            	    default:
            	    
            		if ( cnt35 >= 1 )
            		{
            		    goto loop35;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleconnListEx;
            	}
            	cnt35++;
                }
                loop35: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleconnListEx; /* Prevent compiler warnings */
    ruleconnListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end connList */

/** 
 * $ANTLR start wayPointCN
 * DPtree.g:446:1: wayPointCN : ( ID | TERMCONN ID );
 */
static void
wayPointCN(pDPtree ctx)
{   
    pANTLR3_BASE_TREE    ID24;
    pANTLR3_BASE_TREE    ID25;

    /* Initialize rule variables
     */


    ID24       = NULL;
    ID25       = NULL;

    {
        {
            //  DPtree.g:447:5: ( ID | TERMCONN ID )
            
            ANTLR3_UINT32 alt36;

            alt36=2;

            switch ( LA(1) ) 
            {
            case ID:
            	{
            		alt36=1;
            	}
                break;
            case TERMCONN:
            	{
            		alt36=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 36;
                EXCEPTION->state        = 0;


                goto rulewayPointCNEx;
            }

            switch (alt36) 
            {
        	case 1:
        	    // DPtree.g:447:10: ID
        	    {
        	        ID24 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_wayPointCN1736); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewayPointCNEx;
        	        }

        	        {

        	                      WayPointID nWP = WayPointID::GetIdByName((char*)(ID24->getText(ID24))->chars);
        	                      lT->AddEdge(nWP, wp);
        	                    
        	        }

        	    }
        	    break;
        	case 2:
        	    // DPtree.g:451:7: TERMCONN ID
        	    {
        	         MATCHT(TERMCONN, &FOLLOW_TERMCONN_in_wayPointCN1746); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewayPointCNEx;
        	        }

        	        ID25 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_wayPointCN1748); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewayPointCNEx;
        	        }

        	        {

        	                      WayPointID nWP = WayPointID::GetIdByName((char*)(ID25->getText(ID25))->chars);
        	                      lT->AddTerminatingEdge(nWP, wp);
        	                    
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulewayPointCNEx; /* Prevent compiler warnings */
    rulewayPointCNEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end wayPointCN */

/** 
 * $ANTLR start textloaderWP
 * DPtree.g:457:1: textloaderWP : ^( TEXTLOADER__ ( ^( ATTFROM ID ) | ^( SEPARATOR a= STRING ) | ^( FILE__ b= STRING ( INT )? ) )+ ) ;
 */
static void
textloaderWP(pDPtree ctx)
{   
    pANTLR3_BASE_TREE    a;
    pANTLR3_BASE_TREE    b;
    pANTLR3_BASE_TREE    ID26;
    pANTLR3_BASE_TREE    INT27;

    /* Initialize rule variables
     */


     SlotContainer attribs; char sep; string tablePattern; int count = 0;
    a       = NULL;
    b       = NULL;
    ID26       = NULL;
    INT27       = NULL;

    {
        // DPtree.g:460:3: ( ^( TEXTLOADER__ ( ^( ATTFROM ID ) | ^( SEPARATOR a= STRING ) | ^( FILE__ b= STRING ( INT )? ) )+ ) )
        // DPtree.g:461:5: ^( TEXTLOADER__ ( ^( ATTFROM ID ) | ^( SEPARATOR a= STRING ) | ^( FILE__ b= STRING ( INT )? ) )+ )
        {
             MATCHT(TEXTLOADER__, &FOLLOW_TEXTLOADER___in_textloaderWP1779); 
            if  (HASEXCEPTION())
            {
                goto ruletextloaderWPEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruletextloaderWPEx;
            }

            // DPtree.g:461:20: ( ^( ATTFROM ID ) | ^( SEPARATOR a= STRING ) | ^( FILE__ b= STRING ( INT )? ) )+
            {
                int cnt38=0;

                for (;;)
                {
                    int alt38=4;
            	switch ( LA(1) ) 
            	{
            	case ATTFROM:
            		{
            			alt38=1;
            		}
            	    break;
            	case SEPARATOR:
            		{
            			alt38=2;
            		}
            	    break;
            	case FILE__:
            		{
            			alt38=3;
            		}
            	    break;

            	}

            	switch (alt38) 
            	{
            	    case 1:
            	        // DPtree.g:462:9: ^( ATTFROM ID )
            	        {
            	             MATCHT(ATTFROM, &FOLLOW_ATTFROM_in_textloaderWP1792); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletextloaderWPEx;
            	            }


            	            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletextloaderWPEx;
            	            }

            	            ID26 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_textloaderWP1794); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletextloaderWPEx;
            	            }


            	            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletextloaderWPEx;
            	            }

            	            {
            	                 am.GetAttributesSlots(TXT(ID26), attribs);
            	            }

            	        }
            	        break;
            	    case 2:
            	        // DPtree.g:463:5: ^( SEPARATOR a= STRING )
            	        {
            	             MATCHT(SEPARATOR, &FOLLOW_SEPARATOR_in_textloaderWP1804); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletextloaderWPEx;
            	            }


            	            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletextloaderWPEx;
            	            }

            	            a = (pANTLR3_BASE_TREE) MATCHT(STRING, &FOLLOW_STRING_in_textloaderWP1808); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletextloaderWPEx;
            	            }


            	            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletextloaderWPEx;
            	            }

            	            {
            	                sep = char(*(StripQuotes(TXT(a)).c_str()));
            	            }

            	        }
            	        break;
            	    case 3:
            	        // DPtree.g:464:5: ^( FILE__ b= STRING ( INT )? )
            	        {
            	             MATCHT(FILE__, &FOLLOW_FILE___in_textloaderWP1818); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletextloaderWPEx;
            	            }


            	            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletextloaderWPEx;
            	            }

            	            b = (pANTLR3_BASE_TREE) MATCHT(STRING, &FOLLOW_STRING_in_textloaderWP1822); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletextloaderWPEx;
            	            }

            	            {
            	                 tablePattern = TXTS(b); count=1; 
            	            }

            	            // DPtree.g:464:61: ( INT )?
            	            {
            	                int alt37=2;
            	                switch ( LA(1) ) 
            	                {
            	                    case INT:
            	                    	{
            	                    		alt37=1;
            	                    	}
            	                        break;
            	                }

            	                switch (alt37) 
            	                {
            	            	case 1:
            	            	    // DPtree.g:464:62: INT
            	            	    {
            	            	        INT27 = (pANTLR3_BASE_TREE) MATCHT(INT, &FOLLOW_INT_in_textloaderWP1827); 
            	            	        if  (HASEXCEPTION())
            	            	        {
            	            	            goto ruletextloaderWPEx;
            	            	        }

            	            	        {
            	            	            count= atoi(TXT(INT27));
            	            	        }

            	            	    }
            	            	    break;

            	                }
            	            }

            	            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletextloaderWPEx;
            	            }


            	        }
            	        break;

            	    default:
            	    
            		if ( cnt38 >= 1 )
            		{
            		    goto loop38;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruletextloaderWPEx;
            	}
            	cnt38++;
                }
                loop38: ;	/* Jump to here if this rule does not match */
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruletextloaderWPEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletextloaderWPEx; /* Prevent compiler warnings */
    ruletextloaderWPEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     lT->AddTextLoaderWP(wp, attribs, sep, attribs, tablePattern, count); 
                }
            }


    return ;
}
/* $ANTLR end textloaderWP */

/** 
 * $ANTLR start wpDefinition
 * DPtree.g:468:1: wpDefinition : ( selectWP | joinWP | aggregateWP | printWP | textloaderWP | glaWP );
 */
static void
wpDefinition(pDPtree ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  DPtree.g:469:3: ( selectWP | joinWP | aggregateWP | printWP | textloaderWP | glaWP )
            
            ANTLR3_UINT32 alt39;

            alt39=6;

            switch ( LA(1) ) 
            {
            case SELECT__:
            	{
            		alt39=1;
            	}
                break;
            case JOIN:
            	{
            		alt39=2;
            	}
                break;
            case AGGREGATE:
            	{
            		alt39=3;
            	}
                break;
            case PRINT:
            	{
            		alt39=4;
            	}
                break;
            case TEXTLOADER__:
            	{
            		alt39=5;
            	}
                break;
            case GLA:
            	{
            		alt39=6;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 39;
                EXCEPTION->state        = 0;


                goto rulewpDefinitionEx;
            }

            switch (alt39) 
            {
        	case 1:
        	    // DPtree.g:469:5: selectWP
        	    {
        	        FOLLOWPUSH(FOLLOW_selectWP_in_wpDefinition1851);
        	        selectWP(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewpDefinitionEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // DPtree.g:470:7: joinWP
        	    {
        	        FOLLOWPUSH(FOLLOW_joinWP_in_wpDefinition1859);
        	        joinWP(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewpDefinitionEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // DPtree.g:471:7: aggregateWP
        	    {
        	        FOLLOWPUSH(FOLLOW_aggregateWP_in_wpDefinition1867);
        	        aggregateWP(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewpDefinitionEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // DPtree.g:472:7: printWP
        	    {
        	        FOLLOWPUSH(FOLLOW_printWP_in_wpDefinition1875);
        	        printWP(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewpDefinitionEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // DPtree.g:473:7: textloaderWP
        	    {
        	        FOLLOWPUSH(FOLLOW_textloaderWP_in_wpDefinition1883);
        	        textloaderWP(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewpDefinitionEx;
        	        }


        	    }
        	    break;
        	case 6:
        	    // DPtree.g:474:7: glaWP
        	    {
        	        FOLLOWPUSH(FOLLOW_glaWP_in_wpDefinition1891);
        	        glaWP(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewpDefinitionEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulewpDefinitionEx; /* Prevent compiler warnings */
    rulewpDefinitionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end wpDefinition */

/** 
 * $ANTLR start expr
 * DPtree.g:477:1: expr[SlotContainer& atts, string& cstStr] returns [string sExpr] : ( (a= expression[atts, cstStr] ) (b= expression[atts, cstStr] )* | ^( '?' a= expression[atts, cstStr] b= expression[atts, cstStr] c= expression[atts, cstStr] ) );
 */
static string
expr(pDPtree ctx, SlotContainer& atts, string& cstStr)
{   
    string sExpr;

    DPtree_expression_return a;
    #undef	RETURN_TYPE_a
    #define	RETURN_TYPE_a DPtree_expression_return

    DPtree_expression_return b;
    #undef	RETURN_TYPE_b
    #define	RETURN_TYPE_b DPtree_expression_return

    DPtree_expression_return c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c DPtree_expression_return

    /* Initialize rule variables
     */






    {
        {
            //  DPtree.g:477:66: ( (a= expression[atts, cstStr] ) (b= expression[atts, cstStr] )* | ^( '?' a= expression[atts, cstStr] b= expression[atts, cstStr] c= expression[atts, cstStr] ) )
            
            ANTLR3_UINT32 alt41;

            alt41=2;

            switch ( LA(1) ) 
            {
            case MATCH_DP:
            case CASE_DP:
            case BOOL_T:
            case INT:
            case FLOAT:
            case STRING:
            case ATT:
            case FUNCTION:
            case OPERATOR:
            case UOPERATOR:
            	{
            		alt41=1;
            	}
                break;
            case 103:
            	{
            		alt41=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 41;
                EXCEPTION->state        = 0;


                goto ruleexprEx;
            }

            switch (alt41) 
            {
        	case 1:
        	    // DPtree.g:478:5: (a= expression[atts, cstStr] ) (b= expression[atts, cstStr] )*
        	    {
        	        // DPtree.g:478:5: (a= expression[atts, cstStr] )
        	        // DPtree.g:478:6: a= expression[atts, cstStr]
        	        {
        	            FOLLOWPUSH(FOLLOW_expression_in_expr1914);
        	            a=expression(ctx, atts, cstStr);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleexprEx;
        	            }

        	            {
        	                sExpr+=a.sExpr;
        	            }

        	        }


        	        // DPtree.g:479:5: (b= expression[atts, cstStr] )*

        	        for (;;)
        	        {
        	            int alt40=2;
        	            switch ( LA(1) ) 
        	            {
        	            case MATCH_DP:
        	            case CASE_DP:
        	            case BOOL_T:
        	            case INT:
        	            case FLOAT:
        	            case STRING:
        	            case ATT:
        	            case FUNCTION:
        	            case OPERATOR:
        	            case UOPERATOR:
        	            	{
        	            		alt40=1;
        	            	}
        	                break;

        	            }

        	            switch (alt40) 
        	            {
        	        	case 1:
        	        	    // DPtree.g:479:6: b= expression[atts, cstStr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_expression_in_expr1928);
        	        	        b=expression(ctx, atts, cstStr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleexprEx;
        	        	        }

        	        	        {
        	        	            sExpr+=", "+b.sExpr;
        	        	        }

        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop40;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop40: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;
        	case 2:
        	    // DPtree.g:480:7: ^( '?' a= expression[atts, cstStr] b= expression[atts, cstStr] c= expression[atts, cstStr] )
        	    {
        	         MATCHT(103, &FOLLOW_103_in_expr1944); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expr1948);
        	        a=expression(ctx, atts, cstStr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }

        	        {
        	            sExpr+=a.sExpr;
        	        }
        	        FOLLOWPUSH(FOLLOW_expression_in_expr1955);
        	        b=expression(ctx, atts, cstStr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }

        	        {
        	            sExpr+="?";sExpr+=b.sExpr;
        	        }
        	        FOLLOWPUSH(FOLLOW_expression_in_expr1962);
        	        c=expression(ctx, atts, cstStr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }

        	        {
        	            sExpr+=":";sExpr+=c.sExpr;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleexprEx; /* Prevent compiler warnings */
    ruleexprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return sExpr;
}
/* $ANTLR end expr */

/** 
 * $ANTLR start expression
 * DPtree.g:484:1: expression[SlotContainer& atts, string& cstStr] returns [string sExpr, string type, bool isCT] : ( ^( OPERATOR a= expression[atts, cstStr] b= expression[atts, cstStr] ) | ^( UOPERATOR a= expression[atts, cstStr] ) | ^( FUNCTION ID (a= expression[atts, cstStr] )* ) | ^( MATCH_DP patt= STRING a= expression[atts, cstStr] ) | ^( CASE_DP (a= expression[atts, cstStr] )* ) | att= ATT | INT | BOOL_T | STRING | FLOAT );
 */
static DPtree_expression_return
expression(pDPtree ctx, SlotContainer& atts, string& cstStr)
{   
    DPtree_expression_return retval;

    pANTLR3_BASE_TREE    patt;
    pANTLR3_BASE_TREE    att;
    pANTLR3_BASE_TREE    OPERATOR28;
    pANTLR3_BASE_TREE    UOPERATOR29;
    pANTLR3_BASE_TREE    ID30;
    pANTLR3_BASE_TREE    INT31;
    pANTLR3_BASE_TREE    BOOL_T32;
    pANTLR3_BASE_TREE    STRING33;
    pANTLR3_BASE_TREE    FLOAT34;
    DPtree_expression_return a;
    #undef	RETURN_TYPE_a
    #define	RETURN_TYPE_a DPtree_expression_return

    DPtree_expression_return b;
    #undef	RETURN_TYPE_b
    #define	RETURN_TYPE_b DPtree_expression_return

    /* Initialize rule variables
     */


     ExprListInfo lInfo; 
    patt       = NULL;
    att       = NULL;
    OPERATOR28       = NULL;
    UOPERATOR29       = NULL;
    ID30       = NULL;
    INT31       = NULL;
    BOOL_T32       = NULL;
    STRING33       = NULL;
    FLOAT34       = NULL;


    retval.start = LT(1); retval.stop = retval.start;

    {
        {
            //  DPtree.g:486:3: ( ^( OPERATOR a= expression[atts, cstStr] b= expression[atts, cstStr] ) | ^( UOPERATOR a= expression[atts, cstStr] ) | ^( FUNCTION ID (a= expression[atts, cstStr] )* ) | ^( MATCH_DP patt= STRING a= expression[atts, cstStr] ) | ^( CASE_DP (a= expression[atts, cstStr] )* ) | att= ATT | INT | BOOL_T | STRING | FLOAT )
            
            ANTLR3_UINT32 alt44;

            alt44=10;

            switch ( LA(1) ) 
            {
            case OPERATOR:
            	{
            		alt44=1;
            	}
                break;
            case UOPERATOR:
            	{
            		alt44=2;
            	}
                break;
            case FUNCTION:
            	{
            		alt44=3;
            	}
                break;
            case MATCH_DP:
            	{
            		alt44=4;
            	}
                break;
            case CASE_DP:
            	{
            		alt44=5;
            	}
                break;
            case ATT:
            	{
            		alt44=6;
            	}
                break;
            case INT:
            	{
            		alt44=7;
            	}
                break;
            case BOOL_T:
            	{
            		alt44=8;
            	}
                break;
            case STRING:
            	{
            		alt44=9;
            	}
                break;
            case FLOAT:
            	{
            		alt44=10;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 44;
                EXCEPTION->state        = 0;


                goto ruleexpressionEx;
            }

            switch (alt44) 
            {
        	case 1:
        	    // DPtree.g:487:5: ^( OPERATOR a= expression[atts, cstStr] b= expression[atts, cstStr] )
        	    {
        	        OPERATOR28 = (pANTLR3_BASE_TREE) MATCHT(OPERATOR, &FOLLOW_OPERATOR_in_expression1997); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression2001);
        	        a=expression(ctx, atts, cstStr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             lInfo.Add(a.sExpr, a.type, a.isCT); 
        	        }
        	        FOLLOWPUSH(FOLLOW_expression_in_expression2014);
        	        b=expression(ctx, atts, cstStr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             lInfo.Add(b.sExpr, b.type, b.isCT); 
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {

        	                  string funcName((char*)((OPERATOR28->getText(OPERATOR28))->chars));
        	                  bool funcPure = true;
        	                  // This is we get in return
        	                  // Check if operator exists
        	            #ifdef ENFORCE_TYPES
        	                  vector<ArgFormat> actArgs;
        	                  if (!dTM.IsFunction(funcName, lInfo.GetListTypes(), retval.type, funcPure, actArgs)) {
        	                    printf("\nERROR: Operator %s with arguments %s do not exist",
        	                           funcName.c_str(), lInfo.GetTypesDesc().c_str());
        	                  }
        	                  else {
        	                      // Need to tell the expression info list about the actual types of the
        	                      // arguments and any special formatting needed using the vector of
        	                      // ArgFormats.
        	                      lInfo.Prepare( cstStr, actArgs );
        	                  }
        	            #else
        	                  lInfo.Prepare( cstStr );
        	            #endif

        	                  retval.isCT= lInfo.IsListConstant() && funcPure;

        	                  std::vector<string> eVals = lInfo.Generate();
        	                  retval.sExpr= "(";
        	                  retval.sExpr += eVals[0];
        	                  retval.sExpr += funcName;
        	                  retval.sExpr += eVals[1];
        	                  retval.sExpr += ")";
        	                
        	        }

        	    }
        	    break;
        	case 2:
        	    // DPtree.g:519:5: ^( UOPERATOR a= expression[atts, cstStr] )
        	    {
        	        UOPERATOR29 = (pANTLR3_BASE_TREE) MATCHT(UOPERATOR, &FOLLOW_UOPERATOR_in_expression2031); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression2035);
        	        a=expression(ctx, atts, cstStr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {

        	                  lInfo.Add(a.sExpr, a.type, a.isCT);

        	                  string funcName((char*)((UOPERATOR29->getText(UOPERATOR29))->chars));
        	                  bool funcPure = true;
        	                  // This is we get in return
        	                  // Check if operator exists
        	            #ifdef ENFORCE_TYPES
        	                  vector<ArgFormat> actArgs;
        	                  if (!dTM.IsFunction(funcName, lInfo.GetListTypes(), retval.type, funcPure, actArgs)) {
        	                    printf("\nERROR: Operator %s with arguments %s do not exist",
        	                           funcName.c_str(), lInfo.GetTypesDesc().c_str());
        	                  }
        	                  else {
        	                      // Need to tell the expression info list about the actual types of the
        	                      // arguments and any special formatting needed using the vector of
        	                      // ArgFormats.
        	                      lInfo.Prepare( cstStr, actArgs );
        	                  }
        	            #else
        	                  lInfo.Prepare( cstStr );
        	            #endif
        	                  retval.isCT= lInfo.IsListConstant() && funcPure;

        	                  std::vector<string> eVals = lInfo.Generate();
        	                  retval.sExpr= "(";
        	                  retval.sExpr += funcName.c_str();
        	                  retval.sExpr += eVals[0];
        	                  retval.sExpr += ")";
        	                
        	        }

        	    }
        	    break;
        	case 3:
        	    // DPtree.g:551:5: ^( FUNCTION ID (a= expression[atts, cstStr] )* )
        	    {
        	         MATCHT(FUNCTION, &FOLLOW_FUNCTION_in_expression2052); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        ID30 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_expression2054); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        // DPtree.g:551:20: (a= expression[atts, cstStr] )*

        	        for (;;)
        	        {
        	            int alt42=2;
        	            switch ( LA(1) ) 
        	            {
        	            case MATCH_DP:
        	            case CASE_DP:
        	            case BOOL_T:
        	            case INT:
        	            case FLOAT:
        	            case STRING:
        	            case ATT:
        	            case FUNCTION:
        	            case OPERATOR:
        	            case UOPERATOR:
        	            	{
        	            		alt42=1;
        	            	}
        	                break;

        	            }

        	            switch (alt42) 
        	            {
        	        	case 1:
        	        	    // DPtree.g:551:21: a= expression[atts, cstStr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_expression_in_expression2060);
        	        	        a=expression(ctx, atts, cstStr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleexpressionEx;
        	        	        }

        	        	        {
        	        	               lInfo.Add(a.sExpr, a.type, a.isCT); 
        	        	        }

        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop42;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop42: ; /* Jump out to here if this rule does not match */


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {

        	                  string funcName((char*)((ID30->getText(ID30))->chars));
        	                  bool funcPure = true;
        	                  // This is we get in return
        	                  // Check if operator exists
        	            #ifdef ENFORCE_TYPES
        	                  vector<ArgFormat> actArgs;
        	                  if (!dTM.IsFunction(funcName, lInfo.GetListTypes(), retval.type, funcPure, actArgs)) {
        	                    printf("\nERROR: Operator %s with arguments %s do not exist",
        	                           funcName.c_str(), lInfo.GetTypesDesc().c_str());
        	                  }
        	                  else {
        	                      // Need to tell the expression info list about the actual types of the
        	                      // arguments and any special formatting needed using the vector of
        	                      // ArgFormats.
        	                      lInfo.Prepare( cstStr, actArgs );
        	                  }
        	            #else
        	                  lInfo.Prepare( cstStr );
        	            #endif
        	                  retval.isCT= lInfo.IsListConstant() && funcPure;

        	                  std::vector<string> eVals = lInfo.Generate();
        	                  retval.sExpr= funcName.c_str();
        	                  retval.sExpr += "(";
        	                  for (int i=0; i<eVals.size(); i++){
        	                    if (i>0) {
        	                      retval.sExpr += ",";
        	                    }

        	                    retval.sExpr += eVals[i];
        	                  }
        	                  retval.sExpr += ")";

        	        }

        	    }
        	    break;
        	case 4:
        	    // DPtree.g:586:3: ^( MATCH_DP patt= STRING a= expression[atts, cstStr] )
        	    {
        	         MATCHT(MATCH_DP, &FOLLOW_MATCH_DP_in_expression2079); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        patt = (pANTLR3_BASE_TREE) MATCHT(STRING, &FOLLOW_STRING_in_expression2083); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression2087);
        	        a=expression(ctx, atts, cstStr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             lInfo.Add(a.sExpr, a.type, a.isCT); 
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {

        	                  // for a pattern matcher, we have to build an expression
        	                  // of the form: PatternMather ctObj(pattern)
        	                  // then on use do ctObj.IsMatch(expr)

        	                  retval.isCT= lInfo.IsListConstant();

        	                  lInfo.Prepare( cstStr );
        	                  std::vector<string> eVals = lInfo.Generate();
        	                  // new constant
        	                  int ctNo = ExprListInfo::NextVar();
        	                  // add def of matcher object
        	                  ostringstream match;
        	                  match << "PatternMatcher ct" << ctNo << "( string("
        	                        <<  TXTN(patt) << ") );" << endl;

        	                  cstStr+=match.str();
        	                  // now the expression
        	                  ostringstream expr;
        	                  expr << "ct" << ctNo << ".IsMatch(" << eVals[0] << ")";
        	                  retval.sExpr+=expr.str();
        	               
        	        }

        	    }
        	    break;
        	case 5:
        	    // DPtree.g:609:3: ^( CASE_DP (a= expression[atts, cstStr] )* )
        	    {
        	         MATCHT(CASE_DP, &FOLLOW_CASE_DP_in_expression2104); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
        	            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleexpressionEx;
        	            }


        	            // DPtree.g:609:13: (a= expression[atts, cstStr] )*

        	            for (;;)
        	            {
        	                int alt43=2;
        	                switch ( LA(1) ) 
        	                {
        	                case MATCH_DP:
        	                case CASE_DP:
        	                case BOOL_T:
        	                case INT:
        	                case FLOAT:
        	                case STRING:
        	                case ATT:
        	                case FUNCTION:
        	                case OPERATOR:
        	                case UOPERATOR:
        	                	{
        	                		alt43=1;
        	                	}
        	                    break;

        	                }

        	                switch (alt43) 
        	                {
        	            	case 1:
        	            	    // DPtree.g:609:14: a= expression[atts, cstStr]
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_expression_in_expression2109);
        	            	        a=expression(ctx, atts, cstStr);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto ruleexpressionEx;
        	            	        }

        	            	        {
        	            	               lInfo.Add(a.sExpr, a.type, a.isCT); 
        	            	        }

        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop43;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop43: ; /* Jump out to here if this rule does not match */


        	            MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleexpressionEx;
        	            }

        	        }
        	        {

        	                  // just like a function. For now we only support the 3-argument case
        	                  retval.isCT= lInfo.IsListConstant();

        	                  lInfo.Prepare( cstStr );
        	                  std::vector<string> eVals = lInfo.Generate();
        	                  FATALIF(eVals.size()!=3, "We only support CASE(test, true_expr, false_expr) for now");
        	                  retval.sExpr= retval.sExpr+"("+eVals[0]+") ? ("+eVals[1]+") : ("+eVals[2]+")";
        	               
        	        }

        	    }
        	    break;
        	case 6:
        	    // DPtree.g:619:3: att= ATT
        	    {
        	        att = (pANTLR3_BASE_TREE) MATCHT(ATT, &FOLLOW_ATT_in_expression2128); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {

        	                string longName = (char*)(att->getText(att))->chars;
        	                SlotID slot = am.GetAttributeSlot(longName.c_str());
        	                FATALIF( !slot.IsValid(), "Attribute does not exist, how did this happen?");
        	                atts.Append(slot);
        	                // Add the attribute long name string to the expression
        	                retval.sExpr= longName;
        	                // Find the correct function to get attr type
        	                retval.type= dTM.GetBaseType(am.GetAttributeType(longName.c_str()));
        	                retval.isCT= false;

        	        }

        	    }
        	    break;
        	case 7:
        	    // DPtree.g:631:3: INT
        	    {
        	        INT31 = (pANTLR3_BASE_TREE) MATCHT(INT, &FOLLOW_INT_in_expression2136); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {

        	                string sExpr_text((char*)((INT31->getText(INT31))->chars));
        	                retval.sExpr= sExpr_text;
        	                if( sExpr_text[sExpr_text.size()-1] == 'L') // Literal long int
        	                    retval.type= "BIGINT";
        	                else
        	                    retval.type= "INT";          // Literal int
        	                retval.isCT= true;

        	        }

        	    }
        	    break;
        	case 8:
        	    // DPtree.g:641:3: BOOL_T
        	    {
        	        BOOL_T32 = (pANTLR3_BASE_TREE) MATCHT(BOOL_T, &FOLLOW_BOOL_T_in_expression2142); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {

        	                retval.sExpr= (char*)((BOOL_T32->getText(BOOL_T32))->chars);
        	                retval.type= "bool";
        	                retval.isCT= true;

        	        }

        	    }
        	    break;
        	case 9:
        	    // DPtree.g:647:6: STRING
        	    {
        	        STRING33 = (pANTLR3_BASE_TREE) MATCHT(STRING, &FOLLOW_STRING_in_expression2151); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {

        	                retval.sExpr= TXTN(STRING33);
        	                retval.type= "STRING_LITERAL";
        	                retval.isCT= true;

        	        }

        	    }
        	    break;
        	case 10:
        	    // DPtree.g:653:6: FLOAT
        	    {
        	        FLOAT34 = (pANTLR3_BASE_TREE) MATCHT(FLOAT, &FOLLOW_FLOAT_in_expression2160); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {

        	                string sExpr_text((char*) ((FLOAT34->getText(FLOAT34))->chars));
        	                retval.sExpr= (char*)((FLOAT34->getText(FLOAT34))->chars);
        	                if( sExpr_text[sExpr_text.size()-1] == 'L' )    // Literal long double
        	                    retval.type= "DOUBLE";
        	                else if( sExpr_text[sExpr_text.size() -1] == 'f' )  // Literal float
        	                    retval.type= "FLOAT";
        	                else    // Literal double
        	                    retval.type= "DOUBLE";
        	                retval.isCT= true;

        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleexpressionEx; /* Prevent compiler warnings */
    ruleexpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return retval;
}
/* $ANTLR end expression */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
